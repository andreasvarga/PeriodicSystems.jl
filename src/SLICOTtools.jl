module SLICOTtools
# Collection of wrappers extracted from SLCOTMath.jl generated by Ralph Smith
# based on the SLICOT_jll library (created by the courtesy of Ralph Smith)
using SLICOT_jll
using LinearAlgebra
using LinearAlgebra: BlasInt

export mb03vd!, mb03vy!, mb03bd!

function chkargsok(ret::BlasInt)
    if ret < 0
        throw(ArgumentError("invalid argument #$(-ret) to SLICOT call"))
    end
end

const BlasBool = BlasInt

"""
    mb03vd!(n::Integer, p::Integer, ilo::Integer, ihi::Integer, A::Array{Float64, 3}, tau::AbstractMatrix{Float64}) -> info::Int64

Reduce a product of `p` real general matrices `A = A_1*A_2*...*A_p`
to upper Hessenberg form, `H = H_1*H_2*...*H_p`, where `H_1` is
upper Hessenberg, and `H_2`, ..., `H_p` are upper triangular, by using
orthogonal similarity transformations on `A`,

        Q_1' * A_1 * Q_2 = H_1,
        Q_2' * A_2 * Q_3 = H_2,
               ...
        Q_p' * A_p * Q_1 = H_p.

`H_1`, `H_2`, ..., `H_p` overwrite `A_1`, `A_2`, ..., `A_p`. 

See the SLICOT documentation of `MB03VD` for details.
"""
function mb03vd!(n::Integer, p::Integer, ilo::Integer, ihi::Integer,
    a::Array{Float64,3}, tau::AbstractMatrix{Float64})

    lda1 = max(1,stride(a,2))
    lda2 = max(1,stride(a,3)÷lda1)
    ldtau = max(1,stride(tau,2))
    info = Ref{BlasInt}()
    dwork = Vector{Float64}(undef, n)

    ccall((:mb03vd_, libslicot), Cvoid, (Ref{BlasInt}, Ref{BlasInt},
            Ref{BlasInt}, Ref{BlasInt}, Ptr{Float64}, Ref{BlasInt},
            Ref{BlasInt}, Ptr{Float64}, Ref{BlasInt}, Ptr{Float64},
            Ptr{BlasInt}), n, p, ilo, ihi, a, lda1, lda2, tau,
            ldtau, dwork, info)
    chkargsok(info[])

    return info[]
end

"""
     mb03vy!(n::Integer, p::Integer, ilo::Integer, ihi::Integer, A::Array{Float64, 3}, tau::AbstractMatrix{Float64}) -> info::Int64

Generate the real orthogonal matrices `Q_1`, `Q_2`, ..., `Q_p`,
which are defined as the product of `ihi-ilo` elementary reflectors
of order `n`, as returned in `A_1`, `A_2`, ..., `A_p` by `mb03vd!`:

     Q_j = H_j(ilo) H_j(ilo+1) . . . H_j(ihi-1).

`Q_1`, `Q_2`, ..., `Q_p` overwrite `A_1`, `A_2`, ..., `A_p`. 

See the SLICOT documentation of `MB03VY` for details.

"""
function mb03vy!(n::Integer, p::Integer, ilo::Integer, ihi::Integer,
    a::Array{Float64,3}, tau::AbstractMatrix{Float64})

    lda1 = max(1,stride(a,2))
    lda2 = max(1,stride(a,3)÷lda1)
    ldtau = max(1,stride(tau,2))
    info = Ref{BlasInt}()
    ldwork = BlasInt(-1)
    dwork = Vector{Float64}(undef, 1)

    local jlres
    for iwq in 1:2
        ccall((:mb03vy_, libslicot), Cvoid, (Ref{BlasInt}, Ref{BlasInt},
            Ref{BlasInt}, Ref{BlasInt}, Ptr{Float64}, Ref{BlasInt},
            Ref{BlasInt}, Ptr{Float64}, Ref{BlasInt}, Ptr{Float64},
            Ref{BlasInt}, Ptr{BlasInt}), n, p, ilo, ihi, a, lda1,
            lda2, tau, ldtau, dwork, ldwork, info)
        chkargsok(info[])
        if iwq == 1
            ldwork = BlasInt(real(dwork[1]))
            resize!(dwork, ldwork)
        end
    end

    return info[]
end


"""
    mb03bd!(job::AbstractChar, defl::AbstractChar, compq::AbstractChar, qind::AbstractVector{Int64}, k::Integer, n::Integer, h::Integer, 
            ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{Float64, 3}, q::Array{Float64, 3}, alphar::AbstractVector{Float64}, 
            alphai::AbstractVector{Float64}, beta::AbstractVector{Float64}, scal::AbstractVector{Int64}, liwork::Integer, ldwork::Integer) -> (info::Int64, iwarn::Int64)

Find the eigenvalues of the generalized matrix product

              s[1]           s[2]                 s[k]
      A[:,:,1]     * A[:,:,2]     * ... * A[:,:,k]

where `A[:,:,h]` is upper Hessenberg and `A[:,:,i]`, `i <> h`, is upper
triangular, using a double-shift version of the periodic
QZ method. In addition, `A` may be reduced to periodic Schur form:
`A[:,:,h]` is upper quasi-triangular and all the other factors
`A[:,:,i]` are upper triangular. Optionally, the 2-by-2 triangular
matrices corresponding to 2-by-2 diagonal blocks in `A[:,:,h]`
are so reduced that their product is a 2-by-2 diagonal matrix.

If `compq = 'U'` or `compq = 'I'`, then the orthogonal factors are
computed and stored in the array `Q` so that for `s[i] = 1`,

                    T
        Q[:,:,i](in)   A[:,:,i](in)   Q[:,:,mod(i,k)+1](in)
                                                            T 
    =   Q[:,:,i](out)  A[:,:,i](out)  Q[:,:,mod(i,k)+1](out),

and for `s[i] = -1`,

                             T
        Q[:,:,mod(i,k)+1](in)   A[:,:,i](in)   Q[:,:,i](in)
                                                            T 
    =   Q[:,:,mod(i,k)+1](out)  A[:,:,i](out)  Q[:,:,i](out).

A partial generation of the orthogonal factors can be realized
via the array `qind`.

See the SLICOT documentation of `MB03BD` for details.
"""
function mb03bd!(job::AbstractChar, defl::AbstractChar,
    compq::AbstractChar, qind::AbstractVector{BlasInt}, k::Integer,
    n::Integer, h::Integer, ilo::Integer, ihi::Integer,
    s::AbstractVector{BlasInt}, a::Array{Float64,3},
    q::Array{Float64,3},
    alphar::AbstractVector{Float64}, alphai::AbstractVector{Float64},
    beta::AbstractVector{Float64}, scal::AbstractVector{BlasInt},
    liwork::Integer, ldwork::Integer)

    lda1 = max(1,stride(a,2))
    lda2 = max(1,stride(a,3)÷lda1)
    ldq1 = max(1,stride(q,2))
    ldq2 = max(1,stride(q,3)÷ldq1)
    info = Ref{BlasInt}()
    iwarn = Ref{BlasInt}()
    iwork = Vector{BlasInt}(undef, liwork)
    dwork = Vector{Float64}(undef, ldwork)

    ccall((:mb03bd_, libslicot), Cvoid, (Ref{UInt8}, Ref{UInt8},
            Ref{UInt8}, Ptr{BlasInt}, Ref{BlasInt}, Ref{BlasInt},
            Ref{BlasInt}, Ref{BlasInt}, Ref{BlasInt}, Ptr{BlasInt},
            Ptr{Float64}, Ref{BlasInt}, Ref{BlasInt}, Ptr{Float64},
            Ref{BlasInt}, Ref{BlasInt}, Ptr{Float64}, Ptr{Float64},
            Ptr{Float64}, Ptr{BlasInt}, Ptr{BlasInt}, Ref{BlasInt},
            Ptr{Float64}, Ref{BlasInt}, Ptr{BlasInt}, Ptr{BlasInt},
            Clong, Clong, Clong), job, defl, compq, qind, k, n, h,
            ilo, ihi, s, a, lda1, lda2, q, ldq1, ldq2, alphar,
            alphai, beta, scal, iwork, liwork, dwork, ldwork, iwarn,
            info, 1, 1, 1)
    chkargsok(info[])

    return info[], iwarn[]
end

function mb03bz!(job::AbstractChar, compq::AbstractChar, k::Integer,
    n::Integer, ilo::Integer, ihi::Integer,
    s::AbstractVector{BlasInt}, a::Array{ComplexF64,3}, q::Array{ComplexF64,3},
    alpha::AbstractVector{ComplexF64},
    beta::AbstractVector{ComplexF64}, scal::AbstractVector{BlasInt},
    ldwork::Integer, lzwork::Integer)
"""
    mb03bz!(job::AbstractChar, compq::AbstractChar, k::Integer, n::Integer, 
            ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{ComplexF64, 3}, 
            q::Array{ComplexF64, 3}, alpha::AbstractVector{ComplexF64}, beta::AbstractVector{ComplexF64}, 
            scal::AbstractVector{Int64}, ldwork::Integer, lzwork::Integer) -> info::Int64

"""

    lda1 = max(1,stride(a,2))
    lda2 = max(1,stride(a,3)÷lda1)
    ldq1 = max(1,stride(q,2))
    ldq2 = max(1,stride(q,3)÷ldq1)
    info = Ref{BlasInt}()
    dwork = Vector{Float64}(undef, ldwork)
    zwork = Vector{ComplexF64}(undef, lzwork)

    ccall((:mb03bz_, libslicot), Cvoid, (Ref{UInt8}, Ref{UInt8},
            Ref{BlasInt}, Ref{BlasInt}, Ref{BlasInt}, Ref{BlasInt},
            Ptr{BlasInt}, Ptr{ComplexF64}, Ref{BlasInt},
            Ref{BlasInt}, Ptr{ComplexF64}, Ref{BlasInt},
            Ref{BlasInt}, Ptr{ComplexF64}, Ptr{ComplexF64},
            Ptr{BlasInt}, Ptr{Float64}, Ref{BlasInt},
            Ptr{ComplexF64}, Ref{BlasInt}, Ptr{BlasInt}, Clong,
            Clong), job, compq, k, n, ilo, ihi, s, a, lda1, lda2, q,
            ldq1, ldq2, alpha, beta, scal, dwork, ldwork, zwork,
            lzwork, info, 1, 1)
    chkargsok(info[])

    return info[]
end

end # module
