<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Analysis of periodic systems · PeriodicSystems.jl</title><meta name="title" content="Analysis of periodic systems · PeriodicSystems.jl"/><meta property="og:title" content="Analysis of periodic systems · PeriodicSystems.jl"/><meta property="twitter:title" content="Analysis of periodic systems · PeriodicSystems.jl"/><meta name="description" content="Documentation for PeriodicSystems.jl."/><meta property="og:description" content="Documentation for PeriodicSystems.jl."/><meta property="twitter:description" content="Documentation for PeriodicSystems.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PeriodicSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Data Types and Constructors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ps.html">Building periodic systems</a></li></ul></li><li><a class="tocitem" href="psconnect.html">Basic connections and operations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Basic conversions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="psconversions.html">Discretization of continuous-time periodic systems</a></li><li><a class="tocitem" href="pslifting.html">Conversions to LTI representations</a></li></ul></li><li class="is-active"><a class="tocitem" href="psanalysis.html">Analysis of periodic systems</a></li><li><a class="tocitem" href="pslyap.html">Periodic Lyapunov equation solvers</a></li><li><a class="tocitem" href="psric.html">Periodic Riccati equation solvers</a></li><li><a class="tocitem" href="psstab.html">Stabilization of periodic systems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="pstools.html">Periodic system utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="psanalysis.html">Analysis of periodic systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="psanalysis.html">Analysis of periodic systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andreasvarga/PeriodicSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/master/docs/src/psanalysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Analysis-of-periodic-systems"><a class="docs-heading-anchor" href="#Analysis-of-periodic-systems">Analysis of periodic systems</a><a id="Analysis-of-periodic-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-of-periodic-systems" title="Permalink"></a></h1><ul><li><strong><a href="psanalysis.html#PeriodicSystems.pspole"><code>pspole</code></a></strong>  Computation of the poles of a periodic system.</li><li><strong><a href="psanalysis.html#PeriodicSystems.pszero"><code>pszero</code></a></strong>  Computation of the zeros of a periodic system.</li><li><strong><a href="psanalysis.html#DescriptorSystems.isstable"><code>isstable</code></a></strong>  Assessment of stability of a periodic system.</li><li><strong><a href="psanalysis.html#PeriodicSystems.pshanorm"><code>pshanorm</code></a></strong>  Evaluation of the Hankel-norm of a periodic system.</li><li><strong><a href="psanalysis.html#PeriodicSystems.psh2norm"><code>psh2norm</code></a></strong>  Evaluation of the H2-norm of a periodic system.</li><li><strong><a href="psanalysis.html#PeriodicSystems.pslinfnorm"><code>pslinfnorm</code></a></strong>  Evaluation of the L∞/H∞-norm of a periodic system.</li><li><strong><a href="psanalysis.html#PeriodicSystems.pstimeresp"><code>pstimeresp</code></a></strong>  Time response of a periodic system.</li><li><strong><a href="psanalysis.html#PeriodicSystems.psstepresp"><code>psstepresp</code></a></strong>  Step response of a periodic system.</li><li><strong><a href="psanalysis.html#PeriodicSystems.pseval"><code>pseval</code></a></strong>  Evaluation of the value of the transfer function matrix of the lifted discrete-time periodic system.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pspole" href="#PeriodicSystems.pspole"><code>PeriodicSystems.pspole</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pspole(psys::PeriodicStateSpace{PM}[,K]; kwargs...) -&gt; val</code></pre><p>Return for the periodic system <code>psys = (A(t),B(t),C(t),D(t))</code> the complex vector <code>val</code> containing  the characteristic exponents of the periodic matrix <code>A(t)</code> (also called the <em>poles</em> of the system <code>psys</code>). </p><p>Depending on the underlying periodic matrix type <code>PM</code>, the optional argument <code>K</code> and keyword arguments <code>kwargs</code> may have the following values:</p><ul><li><p>if <code>PM = PeriodicFunctionMatrix</code>, or <code>PM = PeriodicSymbolicMatrix</code>, or <code>PM = PeriodicTimeSeriesMatrix</code>, then <code>K</code> is the number of factors used to express the monodromy matrix of <code>A(t)</code> (default: <code>K = 1</code>)  and <code>kwargs</code> are the keyword arguments of  <code>PeriodicMatrices.pseig(::PeriodicFunctionMatrix)</code>; </p></li><li><p>if <code>PM = HarmonicArray</code>, then <code>K</code> is the number of harmonic components used to represent the Fourier series of <code>A(t)</code> (default: <code>K = max(10,nh-1)</code>, <code>nh</code> is the number of harmonics terms of <code>A(t)</code>)  and <code>kwargs</code> are the keyword arguments of  <code>PeriodicMatrices.psceig(::HarmonicArray)</code>; </p></li><li><p>if <code>PM = FourierFunctionMatrix</code>, then <code>K</code> is the number of harmonic components used to represent the Fourier series of <code>A(t)</code> (default: <code>K = max(10,nh-1)</code>, <code>nh</code> is the number of harmonics terms of <code>A(t)</code>)  and <code>kwargs</code> are the keyword arguments of  <code>PeriodicMatrices.psceig(::FourierFunctionMatrix)</code>; </p></li><li><p>if <code>PM = PeriodicMatrix</code> or <code>PM = PeriodicArray</code>, then <code>K</code> is the starting sample time (default: <code>K = 1</code>)  and <code>kwargs</code> are the keyword arguments of  <code>PeriodicMatrices.psceig(::PeriodicMatrix)</code>; </p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pszero" href="#PeriodicSystems.pszero"><code>PeriodicSystems.pszero</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pszero(psys::PeriodicStateSpace{HarmonicArray}[, N]; P, atol, rtol, fast) -&gt; val
pszero(psys::PeriodicStateSpace{PeriodicFunctionMatrix}[, N]; P, atol, rtol, fast) -&gt; val
pszero(psys::PeriodicStateSpace{PeriodicSymbolicMatrix}[, N]; P, atol, rtol, fast) -&gt; val</code></pre><p>Compute the finite and infinite zeros of a continuous-time periodic system <code>psys = (A(t), B(t), C(t), D(t))</code> in <code>val</code>,  where the periodic system matrices <code>A(t)</code>, <code>B(t)</code>, <code>C(t)</code>, and <code>D(t)</code> are in a <em>Harmonic Array</em>, or  <em>Periodic Function Matrix</em>, or <em>Periodic Symbolic Matrix</em> representation  (the last two representation are automatically converted to a <em>Harmonic Array</em> representation).  <code>N</code> is the number of selected harmonic components in the Fourier series of the system matrices (default: <code>N = max(20,nh-1)</code>,  where <code>nh</code> is the maximum number of harmonics terms) and the keyword parameter <code>P</code> is the number of full periods  to be considered (default: <code>P = 1</code>) to build  a frequency-lifted LTI representation based on truncated block Toeplitz matrices. </p><p>The computation of the zeros of the <em>complex</em> lifted system is performed by reducing the corresponding system pencil  to an appropriate Kronecker-like form which exhibits the finite and infinite eigenvalues.  The reduction is performed using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. For a system <code>psys</code> of period <code>T</code>,  the finite zeros are determined as those eigenvalues which have imaginary parts in the interval <code>[-ω/2, ω/2]</code>, where <code>ω = 2π/(P*T)</code>. To eliminate possible spurious finite eigenvalues, the intersection of two finite eigenvalue sets is computed  for two lifted systems obtained for <code>N</code> and <code>N+2</code> harmonic components.     The infinite zeros are determined as the infinite zeros of the LTI system <code>(A(ti), B(ti), C(ti), D(ti))</code>  resulting for a random time value <code>ti</code>. <em>Warning:</em> While this evaluation of the number of infinite zeros mostly  provides the correct result, there is no theoretical assessment of this approach (counterexamples are welcome!). </p><p>The keyword arguments <code>atol</code>  and <code>rtol</code> specify the absolute and relative tolerances for the nonzero elements of the underlying lifted system pencil, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of the smallest dimension of the pencil, and <code>ϵ</code> is the  working machine epsilon. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L26-L55">source</a></section><section><div><pre><code class="language-julia hljs">pszero(psys::PeriodicStateSpece{FourierFunctionMatrix}[, N]; P, atol, rtol, fast) -&gt; val</code></pre><p>Compute the finite and infinite zeros of a continuous-time periodic system <code>psys = (Af(t), Bf(t), Cf(t), Df(t))</code> in <code>val</code>,  where the periodic system matrices <code>Af(t)</code>, <code>Bf(t)</code>, <code>Cf(t)</code>, and <code>Df(t)</code> are in a <em>Fourier Function Matrix</em> representation.  <code>N</code> is the number of selected harmonic components in the Fourier series of the system matrices (default: <code>N = max(20,nh-1)</code>,  where <code>nh</code> is the maximum number of harmonics terms) and the keyword parameter <code>P</code> is the number of full periods  to be considered (default: <code>P = 1</code>) to build  a frequency-lifted LTI representation based on truncated block Toeplitz matrices. </p><p>The computation of the zeros of the <em>real</em> lifted system is performed by reducing the corresponding system pencil  to an appropriate Kronecker-like form which exhibits the finite and infinite eigenvalues.  The reduction is performed using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. For a system <code>psys</code> of period <code>T</code>,  the finite zeros are determined as those eigenvalues which have imaginary parts in the interval <code>[-ω/2, ω/2]</code>, where <code>ω = 2π/(P*T)</code>.  To eliminate possible spurious finite eigenvalues, the intersection of two finite eigenvalue sets is computed  for two lifted systems obtained for <code>N</code> and <code>N+2</code> harmonic components.     The infinite zeros are determined as the infinite zeros of the LTI system <code>(Af(ti), Bf(ti), Cf(ti), Df(ti))</code>  resulting for a random time value <code>ti</code>. <em>Warning:</em> While this evaluation of the number of infinite zeros mostly  provides the correct result, there is no theoretical assessment of this approach (counterexamples are welcome!). </p><p>The keyword arguments <code>atol</code>  and <code>rtol</code> specify the absolute and relative tolerances for the nonzero elements of the underlying lifted system pencil, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of the smallest dimension of the pencil, and <code>ϵ</code> is the  working machine epsilon. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L90-L115">source</a></section><section><div><pre><code class="language-julia hljs"> pszero(psys::PeriodicStateSpace{PeriodicMatrix}[, K]; atol, rtol, fast) -&gt; val
 pszero(psys::PeriodicStateSpace{PeriodicArray}[, K]; atol, rtol, fast) -&gt; val</code></pre><p>Compute the finite and infinite zeros of a discrete-time periodic system <code>psys = (A(t), B(t), C(t), D(t))</code> in <code>val</code>,  where the periodic system matrices <code>A(t)</code>, <code>B(t)</code>, <code>C(t)</code>, and <code>D(t)</code> are in either <em>Periodic Matrix</em> or <em>Periodic Array</em> representation.  The optional argument <code>K</code> specifies a desired time to start the sequence of periodic matrices (default: <code>K = 1</code>).</p><p>The computation of zeros relies on the <em>fast</em> structure exploiting reduction of singular periodic pencils as described in [1],  which separates a matrix pencil <code>M-λN</code> which contains the infinite and finite zeros  and the left and right Kronecker indices. The reduction is performed using orthonal similarity transformations and involves rank decisions based  on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguments <code>atol</code> and <code>rtol</code> specify the absolute and relative tolerances for the nonzero elements of the periodic system matrices, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is proportional with the largest dimension of the periodic matrices,  and <code>ϵ</code> is the working machine epsilon. </p><p><em>References</em></p><p>[1] A. Varga and P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems &amp; Control Letters 50:371–381, 2003.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L156-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.isstable" href="#DescriptorSystems.isstable"><code>DescriptorSystems.isstable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> isstable(psys[, K = 1]; smarg = 1, fast = false, offset = sqrt(ϵ), kwargs...) -&gt; Bool</code></pre><p>Return <code>true</code> if the continuous-time periodic system <code>psys</code> has only stable characteristic multipliers and <code>false</code> otherwise. </p><p>To assess the stability, the absolute values of the characteristic multipliers (i.e., the eigenvalues of the monodromy matrix) must be less than <code>smarg-β</code>, where <code>smarg</code> is the discrete-time stability margin (default: <code>smarg = 1</code>)  and  <code>β</code> is an offset specified via the keyword parameter <code>offset = β</code> to be used to numerically assess the stability of eigenvalues. The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The monodromy matrix is determined as a product <code>K</code> state transition matrices (default: <code>K = 1</code>)  computed by integrating numerically a homogeneous linear ODE with periodic coefficients. If <code>fast = false</code> (default) then the characteristic multipliers are computed using an approach based on the periodic Schur decomposition [1], while if <code>fast = true</code>  the structure exploiting reduction [2] of an appropriate lifted pencil is employed.  This later option may occasionally lead to inaccurate results for large number of matrices. </p><p><em>References</em></p><p>[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.</p><p>[2] A. Varga &amp; P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L227-L251">source</a></section><section><div><pre><code class="language-julia hljs">isstable(psys; smarg = 1, fast = false, offset = sqrt(ϵ)) -&gt; Bool</code></pre><p>Return <code>true</code> if the discrete-time periodic system <code>psys</code> has only stable characteristic multipliers and <code>false</code> otherwise. </p><p>To assess the stability, the absolute values of the characteristic multipliers (i.e., the eigenvalues of the monodromy matrix) must be less than <code>smarg-β</code>, where <code>smarg</code> is the discrete-time stability margin (default: <code>smarg = 1</code>)  and  <code>β</code> is an offset specified via the keyword parameter <code>offset = β</code> to be used to numerically assess the stability of eigenvalues. The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>If <code>fast = false</code> (default) then the characteristic multipliers are computed using an approach based on the periodic Schur decomposition [1], while if <code>fast = true</code>  the structure exploiting reduction [2] of an appropriate lifted pencil is employed.  This later option may occasionally lead to inaccurate results for large number of matrices. </p><p><em>References</em></p><p>[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.</p><p>[2] A. Varga &amp; P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L257-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pshanorm" href="#PeriodicSystems.pshanorm"><code>PeriodicSystems.pshanorm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pshanorm(psys; smarg = 1, lifting = false, offset = sqrt(ϵ)) -&gt; nrm</code></pre><p>Compute the Hankel-norm of a stable discrete-time periodic system <code>psys = (A(t),B(t),C(t),D(t))</code>.   For the computation of the norm, the formulas given in [1] are employed.  The Hankel norm is computed as</p><pre><code class="nohighlight hljs"> nrm = maximum(sqrt(Λ(P(t)Q(t))),</code></pre><p>where <code>P(t)</code> is the controllability Gramian satisfying the periodic Lyapunov equation</p><pre><code class="nohighlight hljs"> P(t+1) = A(t)P(t)A(t)&#39; + B(t)B(t)&#39;,</code></pre><p>and <code>Q(t)</code> is the observability Gramian satisfying the periodic Lyapunov equation</p><pre><code class="nohighlight hljs">Q(t) = A(t)&#39;Q(t+1)A(t) + C(t)&#39;C(t) .</code></pre><p>To assess the stability, the absolute values of the characteristic multipliers of <code>A(t)</code>  must be less than <code>smarg-β</code>, where <code>smarg</code> is the discrete-time stability margin (default: <code>smarg = 1</code>)  and  <code>β</code> is an offset specified via the keyword parameter <code>offset = β</code> to be used to numerically assess the stability of eigenvalues. The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>If <code>lifting = false</code> (default), then the norm is evaluated using an approach based on the periodic Schur decomposition of <code>A(t)</code>,  while if <code>lifting = true</code> the norm of the lifted cyclic system is evaluated.   This later option may lead to excessive computational times for large matrices or large periods. </p><p><em>References</em></p><p>[1] S. Bittanti and P. Colaneri. Periodic Systems : Filtering and Control.     Springer-Verlag London, 2009. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L583-L613">source</a></section><section><div><pre><code class="language-julia hljs">pshanorm(psys, K; smarg = 1, offset = sqrt(ϵ), solver = &quot;&quot;, reltol = 1.e-4, abstol = 1.e-7) -&gt; nrm</code></pre><p>Compute the Hankel-norm of a stable continuous-time periodic system <code>psys = (A(t),B(t),C(t),D(t))</code>.   For the computation of the norm, the approach suggested in [1] is employed,  in conjunction with the multiple-shooting approach using <code>K</code> discretization points.   For a periodic system of period  <code>T</code>, the Hankel-norm is defined as</p><pre><code class="nohighlight hljs"> nrm = sqrt(max(Λ(P(t)Q(t)))), for t ∈ [0,T]</code></pre><p>where <code>P(t)</code> is the controllability Gramian satisfying the periodic differential Lyapunov equation</p><pre><code class="nohighlight hljs"> .
 P(t) = A(t)P(t)A(t)&#39; + B(t)B(t)&#39;,</code></pre><p>and <code>Q(t)</code> is the observability Gramian satisfying the periodic differential Lyapunov equation</p><pre><code class="nohighlight hljs"> .
-Q(t) = A(t)&#39;Q(t)A(t) + C(t)&#39;C(t) .</code></pre><p>The norm is evaluated from the <code>K</code> time values of <code>P(t)</code> and <code>Q(t)</code> in the interval <code>[0,T]</code> and  the precision is (usually) better for larger values of <code>K</code>.</p><p>To assess the stability, the absolute values of the characteristic multipliers of <code>A(t)</code>  must be less than <code>smarg-β</code>, where <code>smarg</code> is the discrete-time stability margin (default: <code>smarg = 1</code>)  and  <code>β</code> is an offset specified via the keyword parameter <code>offset = β</code> to be used to numerically assess the stability of eigenvalues. The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>,  together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),   absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and  stepsize <code>dt</code> (default: <code>dt = 0</code>). The value stepsize is relevant only if <code>solver = &quot;symplectic&quot;, in which case an adaptive stepsize strategy is used if</code>dt = 0<code>and a fixed stepsize is used if</code>dt &gt; 0<code>. Depending on the desired relative accuracy</code>reltol<code>, lower order solvers are employed for</code>reltol &gt;= 1.e-4<code>,  which are generally very efficient, but less accurate. If</code>reltol &lt; 1.e-4`, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p><em>References</em></p><p>[1] A. Varga, On solving periodic differential matrix equations with applications to periodic system norms computation.     Proc. CDC/ECC, Seville, p.6545-6550, 2005.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L633-L687">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.psh2norm" href="#PeriodicSystems.psh2norm"><code>PeriodicSystems.psh2norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">psh2norm(psys; adj = false, smarg = 1, fast = false, offset = sqrt(ϵ)) -&gt; nrm</code></pre><p>Compute the H2-norm of a discrete-time periodic system <code>psys = (A(t),B(t),C(t),D(t))</code>.   For the computation of the norm, the formulas given in [1] are employed.  For <code>adj = false</code> the norm is computed as</p><pre><code class="nohighlight hljs"> nrm = sqrt(sum(tr(C(t)P(t)C(t)&#39;+D(t)*D(t)&#39;))),</code></pre><p>where <code>P(t)</code> is the controllability Gramian satisfying the periodic Lyapunov equation</p><pre><code class="nohighlight hljs"> P(t+1) = A(t)P(t)A(t)&#39; + B(t)B(t)&#39;,</code></pre><p>while for <code>adj = true</code> the norm is computed as</p><pre><code class="nohighlight hljs">nrm = sqrt(sum(tr(B(t)&#39;Q(t+1)B(t)+D(t)&#39;*D(t)))),</code></pre><p>where <code>Q(t)</code> is the observability Gramian satisfying the periodic Lyapunov equation</p><pre><code class="nohighlight hljs">Q(t) = A(t)&#39;Q(t+1)A(t) + C(t)&#39;C(t) .</code></pre><p>The norm is set to infinity for an unstable system.</p><p>To assess the stability, the absolute values of the characteristic multipliers of <code>A(t)</code>  must be less than <code>smarg-β</code>, where <code>smarg</code> is the discrete-time stability margin (default: <code>smarg = 1</code>)  and  <code>β</code> is an offset specified via the keyword parameter <code>offset = β</code> to be used to numerically assess the stability of eigenvalues. The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>If <code>fast = false</code> (default) then the norm is evaluated using an approach based on the periodic Schur decomposition of <code>A(t)</code>,  while if <code>fast = true</code> the norm of the lifted standard system is evaluated.   This later option may occasionally lead to inaccurate results for large number of matrices. </p><p><em>References</em></p><p>[1] S. Bittanti and P. Colaneri. Periodic Systems : Filtering and Control.     Springer-Verlag London, 2009. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L285-L321">source</a></section><section><div><pre><code class="language-julia hljs">psh2norm(psys, K; adj = false, smarg = 1, fast = false, offset = sqrt(ϵ), solver = &quot;&quot;, reltol = 1.e-4, abstol = 1.e-7, quad = false) -&gt; nrm</code></pre><p>Compute the H2-norm of a continuous-time periodic system <code>psys = (A(t),B(t),C(t),D(t))</code>.   For the computation of the norm, the formulas given in [1] are employed,  in conjunction with the multiple-shooting approach of [2] using <code>K</code> discretization points.   For a periodic system of period  <code>T</code>, for <code>adj = false</code> the norm is computed as</p><pre><code class="nohighlight hljs"> nrm = sqrt(Integral(tr(C(t)P(t)C(t)&#39;)))dt/T),</code></pre><p>where <code>P(t)</code> is the controllability Gramian satisfying the periodic differential Lyapunov equation</p><pre><code class="nohighlight hljs"> .
 P(t) = A(t)P(t)A(t)&#39; + B(t)B(t)&#39;,</code></pre><p>while for <code>adj = true</code> the norm is computed as</p><pre><code class="nohighlight hljs">nrm = sqrt(Integral(tr(B(t)&#39;Q(t)B(t)))dt/T),</code></pre><p>where Q(t) is the observability Gramian satisfying the periodic differential Lyapunov equation</p><pre><code class="nohighlight hljs"> .
-Q(t) = A(t)&#39;Q(t)A(t) + C(t)&#39;C(t) .</code></pre><p>If <code>quad = true</code>, a simple quadrature formula based on the sum of time values is employed (see [2]). This option ensures a faster evaluation, but is potentially less accurate then the exact evaluation employed if <code>quad = false</code> (default). </p><p>The norm is set to infinity for an unstable system or for a non-zero <code>D(t)</code>.</p><p>To assess the stability, the absolute values of the characteristic multipliers of <code>A(t)</code>  must be less than <code>smarg-β</code>, where <code>smarg</code> is the discrete-time stability margin (default: <code>smarg = 1</code>)  and  <code>β</code> is an offset specified via the keyword parameter <code>offset = β</code> to be used to numerically assess the stability of eigenvalues. The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision.  If <code>fast = false</code> (default) then the stability is checked using an approach based on the periodic Schur decomposition of <code>A(t)</code>,  while if <code>fast = true</code> the stability is checked using a lifting-based approach.  </p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>,  together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),   absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and  stepsize <code>dt</code> (default: <code>dt = 0</code>). The value stepsize is relevant only if <code>solver = &quot;symplectic&quot;, in which case an adaptive stepsize strategy is used if</code>dt = 0<code>and a fixed stepsize is used if</code>dt &gt; 0<code>. Depending on the desired relative accuracy</code>reltol<code>, lower order solvers are employed for</code>reltol &gt;= 1.e-4<code>,  which are generally very efficient, but less accurate. If</code>reltol &lt; 1.e-4`, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p><em>References</em></p><p>[1] P. Colaneri. Continuous-time periodic systems in H2 and H∞: Part I: Theoretical Aspects.     Kybernetika, 36:211-242, 2000. </p><p>[2] A. Varga, On solving periodic differential matrix equations with applications to periodic system norms computation.     Proc. CDC/ECC, Seville, p.6545-6550, 2005.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L341-L406">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pslinfnorm" href="#PeriodicSystems.pslinfnorm"><code>PeriodicSystems.pslinfnorm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pslinfnorm(psys, hinfnorm = false, rtolinf = 0.001, fast = true, offset = sqrt(ϵ)) -&gt; (linfnorm, fpeak)
pshinfnorm(psys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ)) -&gt; (hinfnorm, fpeak)</code></pre><p>Compute for a discrete-time periodic system <code>psys = (A(t),B(t),C(t),D(t)</code> with the lifted transfer function  matrix <code>G(λ)</code>  the <code>L∞</code> norm <code>linfnorm</code> with <code>pslinfnorm</code> or the <code>H∞</code> norm <code>hinfnorm</code> with <code>pshinfnorm</code> (i.e.,  the peak gain of <code>G(λ)</code>) and  the corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved. If <code>hinfnorm = true</code>, the <code>H∞</code> norm is computed with <code>pslinfnorm</code>.</p><p>The <code>L∞</code> norm is infinite if <code>psys</code> has poles on the stability domain boundary,  i.e., on the unit circle. The <code>H∞</code> norm is infinite if <code>psys</code> has unstable poles. </p><p>To check the lack of poles on the stability domain boundary, the poles of <code>psys</code>  must not have moduli within the interval <code>[1-β,1+β]</code>, where <code>β</code> is the stability domain boundary offset.   The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>The computation of the <code>L∞</code> norm is based on the algorithm proposed in [1].  The involved computations of characteristic multipliers are performed either with the fast reduction method of [2],  if <code>fast = true</code> or if time-varying dimensions are present,  or the generalized periodic Schur decomposition based method of [3], if <code>fast = false</code>.  </p><p><em>References</em></p><p>[1] A. Varga. &quot;Computation of L∞-norm of linear discrete-time periodic systems.&quot; Proc. MTNS, Kyoto, 2007.</p><p>[2] A. Varga and P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems &amp; Control Letters 50:371–381, 2003.</p><p>[3] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L703-L740">source</a></section><section><div><pre><code class="language-julia hljs">pslinfnorm(psys, K = 100; hinfnorm = false, rtolinf = 0.001, offset = sqrt(ϵ), reltol, abstol, dt) -&gt; (linfnorm, fpeak)
pshinfnorm(psys, K = 100; rtolinf = 0.001, offset = sqrt(ϵ), reltol, abstol, dt) -&gt; (linfnorm, fpeak)</code></pre><p>Compute for a continuous-time periodic system <code>psys = (A(t),B(t),C(t),D(t)</code> the <code>L∞</code> norm <code>linfnorm</code> with <code>pslinfnorm</code> or the  <code>H∞</code> norm <code>hinfnorm</code> with <code>pshinfnorm</code> as defined in [1].  If <code>hinfnorm = true</code>, the <code>H∞</code> norm is computed with <code>pslinfnorm</code>. The corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved, is usually not determined, excepting in some limiting cases.    The <code>L∞</code> norm is infinite if <code>psys</code> has poles on the imaginary axis. </p><p>To check the lack of poles on the imaginary axis, the characteristic exponents of <code>A(t)</code>  must not have real parts in the interval <code>[-β,β]</code>, where <code>β</code> is the stability domain boundary offset.   The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>A bisection based algorith, as described in [2], is employed to approximate the <code>L∞</code> norm, and the keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>If <code>hinfnorm = true</code>, the <code>H∞</code> norm is computed.  In this case, the stability of the system is additionally checked and  the <code>H∞</code> norm is infinite for an unstable system. To check the stability, the characteristic exponents of <code>A(t)</code> must have real parts less than <code>-β</code>.</p><p>The ODE solver to be employed to compute the characteristic multipliers of the system Hamiltonian can be specified using the keyword argument <code>solver</code> (default: <code>solver = &quot;symplectic&quot;</code>)  together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),   absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and  stepsize <code>dt</code> (default: <code>dt = 0</code>). The value stepsize is relevant only if <code>solver = &quot;symplectic&quot;, in which case an adaptive stepsize strategy is used if</code>dt = 0<code>and a fixed stepsize is used if</code>dt &gt; 0<code>. Depending on the desired relative accuracy</code>reltol<code>, lower order solvers are employed for</code>reltol &gt;= 1.e-4<code>,  which are generally very efficient, but less accurate. If</code>reltol &lt; 1.e-4`, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p><em>References:</em>    </p><p>[1] P. Colaneri. Continuous-time periodic systems in H2 and H∞: Part I: Theoretical Aspects.     Kybernetika, 36:211-242, 2000. </p><p>[2] A. Varga, On solving periodic differential matrix equations with applications to periodic system norms computation.     Proc. CDC/ECC, Seville, p.6545-6550, 2005.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L1046-L1098">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pstimeresp" href="#PeriodicSystems.pstimeresp"><code>PeriodicSystems.pstimeresp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pstimeresp(sys, u, t, x0 = zeros(sys.nx); state_history = false, solver, reltol, abstol) -&gt; (y, tout, x)</code></pre><p>Compute the time response of a periodic system <code>sys = (A(t),B(t),C(t),D(t))</code> to the input signals  described by <code>u</code> and <code>t</code>. The time vector <code>t</code> consists of regularly spaced time samples.  The input <code>u</code> can be specified as a matrix with as many columns as the number of inputs of <code>sys</code>,  in which case its <code>i</code>-th row specifies the input values at time <code>t[i]</code>.  For a discrete-time system, <code>u</code> should be sampled at the same sampling rate <code>Ts</code> as <code>sys</code> and <code>t</code> must have all time steps equal to <code>Ts</code> or can be set to an empty vector.  For continuous-time models, the input values are interpolated between samples using   zero-order hold based interpolation.  The vector <code>x0</code> specifies the initial state vector at time <code>t[1]</code> and is set to zero when omitted. </p><p>The matrix <code>y</code> contains the resulting time history of the outputs of <code>sys</code> and  the vector <code>tout</code> contains the corresponding values of the time samples. The <code>i</code>-th row of <code>y</code> contains the output values at time <code>tout[i]</code>.   If the keyword parameter value <code>state_history = true</code> is used, then the matrix <code>x</code> contains  the resulting time history of the state vector and its <code>i</code>-th row <code>x[i,:]</code> contains  the state values at time <code>tout[i]</code>.  The column dimension of the matrix <code>x</code> is <code>n</code>, the dimension of the state vector.  For a discrete-time periodic system with time-varying state dimensions, <code>n</code> is the maximum value of the  dimensions of the state vector over one period. The components of <code>x[i,:]</code> have trailing zero values if the  corresponding state vector dimension is less than <code>n</code>.   By default, the state history is not saved and <code>x = nothing</code>.</p><p>For a continuous-time model an equivalent discretized model is determined to be used for simulation. The discretization is performed by determining the monodromy matrix as a product of  state transition matrices of the extended state-space matrix <code>[A(t) B(t); 0 0]</code>  by integrating numerically the corresponding homogeneous linear ODE.   The ODE solver to be employed can be  specified using the keyword argument <code>solver</code>, together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and/or  the fixed step length <code>dt</code> (default: <code>dt = Ts/10</code>). Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>For large numbers of product terms, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/pstimeresp.jl#L1-L56">source</a></section><section><div><pre><code class="language-julia hljs">pstimeresp(sys, u, t, x0 = zeros(sys.nx); state_history = false, solver, reltol, abstol) -&gt; (y, tout, x)</code></pre><p>Compute the time response of a continuous-time periodic system <code>sys = (A(t),B(t),C(t),D(t))</code> to the input signals  described by <code>u</code> and <code>t</code>. The time vector <code>t</code> consists of regularly spaced time samples.  The input <code>u</code> is specified as a vector of time dependent signals  with as many components as the number of inputs of <code>sys</code>.  The vector <code>x0</code> specifies the initial state vector at time <code>t[1]</code> and is set to zero when omitted. </p><p>The matrix <code>y</code> contains the resulting time history of the outputs of <code>sys</code> and  the vector <code>tout</code> contains the corresponding values of the time samples. The <code>i</code>-th row of <code>y</code> contains the output values at time <code>tout[i]</code>.   If the keyword parameter value <code>state_history = true</code> is used, then the matrix <code>x</code> contains  the resulting time history of the state vector and its <code>i</code>-th row contains  the state values at time <code>tout[i]</code>. By default, the state history is not computed and <code>x = nothing</code>.</p><p>The ODE solver to be employed can be  specified using the keyword argument <code>solver</code> (see below), together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and  the fixed step length <code>dt</code> (default: <code>dt = 0</code>), only used if <code>solver = &quot;symplectic&quot;</code>.  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/pstimeresp.jl#L360-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.psstepresp" href="#PeriodicSystems.psstepresp"><code>PeriodicSystems.psstepresp</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">psstepresp(sys[, tfinal]; ustep = ones(psys.nu), x0 = zeros(psys.nx), timesteps = 100, 
         state_history = false, abstol, reltol) -&gt; (y, tout, x)</code></pre><p>Compute the time response of a periodic system <code>sys = (A(t),B(t),C(t),D(t))</code> to step input signals.  The final time <code>tfinal</code>, if not specified, is set equal to the period of the periodic system <code>sys</code>. For a discrete-time system, the final time <code>tfinal</code> must be commensurate with the system sampling time <code>Ts</code> (otherwise it is adjusted to the nearest smaller commensurate value).  The keyword argument <code>ustep</code> is a vector with as many components  as the inputs of <code>sys</code> and specifies the desired amplitudes of step inputs (default: all components are set to 1).    The keyword argument <code>x0</code> is a vector, which specifies the initial state vector at time <code>0</code>,  and is set to zero when omitted.  The keyword argument <code>timesteps</code> specifies the number of desired simulation time steps  (default: <code>timesteps = 100</code>). </p><p>If <code>ns</code> is the total number of simulation values, <code>n</code> the number of state components,  <code>p</code> the number of system outputs and <code>m</code> the number of system inputs, then the resulting <code>ns×p×m</code> array <code>y</code> contains the resulting time histories of the outputs of <code>sys</code>, such  that <code>y[:,:,j]</code> is the time response for the <code>j</code>-th input set to <code>ustep[j]</code> and the rest of inputs set to zero.   The vector <code>tout</code> contains the corresponding values of the time samples. The <code>i</code>-th row <code>y[i,:,j]</code> contains the output values at time <code>tout[i]</code> of the <code>j</code>-th step response.   If the keyword parameter value <code>state_history = true</code> is used, then the resulting <code>ns×n×m</code> array<code>x</code> contains  the resulting time histories of the state vector and  the <code>i</code>-th row <code>x[i,:,j]</code> contains the state values at time <code>tout[i]</code> of the <code>j</code>-th step response.   For a discrete-time periodic system with time-varying state dimensions, <code>n</code> is the maximum value of the  dimensions of the state vector over one period. The components of <code>x[i,:,j]</code> have trailing zero values if the  corresponding state vector dimension is less than <code>n</code>.   By default, the state history is not saved and <code>x = nothing</code>.</p><p>The total number of simulation values <code>ns</code> is set as follows: for a continuous-time system <code>ns = timesteps+1</code>  and for a discrete-time system <code>ns = min(timesteps,tfinal/Ts)+1</code>. </p><p>For a continuous-time model an equivalent discretized model is determined to be used for simulation, provided the time step <code>Δ = tfinal/timesteps</code> is commensurate with the system period <code>T</code> and <code>tfinal &gt;= T</code>.  The discretization is performed by determining the monodromy matrix as a product of  state transition matrices of the extended state-space matrix <code>[A(t) B(t); 0 0]</code>  by integrating numerically the corresponding homogeneous linear ODE.   If the time step <code>Δ</code> is not commensurate with the period <code>T</code> or <code>tfinal &lt; T</code>, then numerical integrations of the underlying ODE systems are performed.  The ODE solver to be employed can be  specified using the keyword argument <code>solver</code>, together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and/or  the fixed step length <code>dt</code> (default: <code>dt = Ts/10</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>For large numbers of product terms, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/pstimeresp.jl#L159-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pseval" href="#PeriodicSystems.pseval"><code>PeriodicSystems.pseval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pseval(psys, val) -&gt; Gval</code></pre><p>Evaluate for a finite <code>λ = val</code>, the value <code>Gval</code> of the transfer function matrix <code>G(λ)</code> of the  lifted system of the discrete-time periodic system <code>psys</code>.  <code>val</code> must not be a pole of <code>psys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psanalysis.jl#L1034-L1040">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="pslifting.html">« Conversions to LTI representations</a><a class="docs-footer-nextpage" href="pslyap.html">Periodic Lyapunov equation solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 8 November 2024 14:43">Friday 8 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
