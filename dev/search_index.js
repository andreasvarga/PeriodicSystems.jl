var documenterSearchIndex = {"docs":
[{"location":"makeindex.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html","page":"Index","title":"Index","text":"Pages = [ \"pstypes.md\", \"ps.md\", \"psconnect.md\", \"psconversions.md\", \"pslifting.md\", \"psanalysis.md\", \"pslyap.md\", \"psstab.md\", \"psric.md\", \"pschur.md\", \"pstools.md\", \"psconv.md\", \"slicot.md\" ]\nModules = [PeriodicSystems]\nOrder = [:type, :function]","category":"page"},{"location":"psstab.html#Stabilization-of-periodic-systems","page":"Stabilization of periodic systems","title":"Stabilization of periodic systems","text":"","category":"section"},{"location":"psstab.html","page":"Stabilization of periodic systems","title":"Stabilization of periodic systems","text":"Periodic state feedback controller and estimator design ","category":"page"},{"location":"psstab.html","page":"Stabilization of periodic systems","title":"Stabilization of periodic systems","text":"pclqr  LQ-optimal state feedack stabilization of continuous-time periodic systems \npclqry LQ-optimal state feedack stabilization with output weighting of continuous-time periodic systems \npdlqr  LQ-optimal state feedack stabilization of discrete-time periodic systems \npdlqry LQ-optimal state feedack stabilization with output weighting of discrete-time periodic systems \npckeg  Kalman estimator gain matrix for continuous-time periodic systems \npckegw  Kalman estimator gain matrix for continuous-time periodic systems with noise inputs\npdkeg  Kalman estimator gain matrix for periodic systems \npdkegw  Kalman estimator gain matrix for periodic systems with noise inputs","category":"page"},{"location":"psstab.html","page":"Stabilization of periodic systems","title":"Stabilization of periodic systems","text":"Periodic output feedback controller design ","category":"page"},{"location":"psstab.html","page":"Stabilization of periodic systems","title":"Stabilization of periodic systems","text":"pcpofstab_sw Stabilization of continuous-time periodic systems using switching periodic output feedback.\npcpofstab_hr Stabilization of continuous-time periodic systems using harmonic output feedback.\npdpofstab_sw Stabilization of discrete-time periodic systems using switching periodic output feedback.\npdpofstab_hr Stabilization of discrete-time periodic systems using discretized harmonic periodic output feedback.\npclqofc_sw LQ-optimal stabilization of continuous-time periodic systems using switching periodic output feedback.\npclqofc_hr LQ-optimal stabilization of continuous-time periodic systems using harmonic output feedback.\npdlqofc LQ-optimal stabilization of discrete-time periodic systems using periodic output feedback.\npdlqofc_sw LQ-optimal stabilization of discrete-time periodic systems using switching periodic output feedback.","category":"page"},{"location":"psstab.html","page":"Stabilization of periodic systems","title":"Stabilization of periodic systems","text":"pclqr\npclqry\npdlqr\npdlqry\npckeg\npckegw\npdkeg\npdkegw\npcpofstab_sw\npcpofstab_hr\npdpofstab_sw\npdpofstab_hr\npclqofc_sw\npclqofc_hr\npdlqofc\npdlqofc_sw","category":"page"},{"location":"psstab.html#PeriodicSystems.pclqr","page":"Stabilization of periodic systems","title":"PeriodicSystems.pclqr","text":" pclqr(psys, Q, R, S; intpol = true, kwargs...) -> (F, EVALS)\n\nCompute the optimal periodic stabilizing gain matrix F(t), such that for a continuous-time periodic state-space model  psys of the form\n\n  .\n  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)\n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t),\n\nthe state feedback control law\n\n u(t) = F(t)x(t)\n\nminimizes the quadratic index\n\n J = Integral {x'(t)Q(t)x(t) + u(t)'R(t)u(t) + 2*x'(t)S(t)u(t)} dt.\n\nFor a system of order n with m inputs, Q(t) and R(t) are n×n and m×m symmetric matrices, respectively, and S(t) is an n×m matrix.                 The matrix S is set to zero when omitted. The dimension of u(t) is deduced from the dimension of R(t).  R, Q and S can be alternatively provided as constant real matrices. \n\nAlso returned are the closed-loop characteristic exponents EVALS of A(t)+B(t)F(t).\n\nFor intpol = true (default), the resulting periodic gain F(t) is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If intpol = false, the gain F(t) is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   \n\nThe keyword arguments contained in kwargs are those used for the function prcric (excepting intpol). \n\nNote: The pair (A(t),B(t)) must be stabilizable, R must be positive definite and [Q S;S' R] must be nonnegative definite .\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pclqry","page":"Stabilization of periodic systems","title":"PeriodicSystems.pclqry","text":" pclqry(psys, Q, R, S; intpol = true, kwargs...) -> (F, EVALS)\n\nCompute the optimal periodic stabilizing gain matrix F(t), such that for a periodic  continuous-time state-space model psys of the form        .       x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)        y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,\n\nthe state feedback control law\n\n u(t) = F(t)x(t)\n\nminimizes the quadratic index\n\n J = Integral {y'(t)Q(t)y(t) + u'(t)R(t)u(t) + 2*y'(t)S(t)u(t)} dt\n\nFor a system with m control inputs u(t) and p outputs, Q(t) and R(t) are p×p and m×m symmetric matrices, respectively, and S(t) is an p×m matrix.  The dimension of u(t) is deduced from the dimension of R(t).  R, Q and S can be alternatively provided as constant real matrices.                              The matrix S is set to zero when omitted. \n\nAlso returned are the closed-loop characteristic exponents EVALS of A(t)+B(t)F(t).\n\nFor intpol = true (default), the resulting periodic gain F(t) is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If intpol = false, the gain F(t) is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   \n\nThe keyword arguments contained in kwargs are those used for the function prcric (excepting intpol).  \n\nNote: The pair (A(t),B(t)) must be stabilizable and [Q S;S' R] must be nonnegative definite.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdlqr","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdlqr","text":" pdlqr(psys, Q, R, S; kwargs...) -> (F, EVALS)\n\nCompute the optimal periodic stabilizing gain matrix F(t), such that for a discrete-time periodic state-space model  psys of the form\n\nx(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t) \n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t)\n\nthe state feedback control law\n\n u(t) = F(t)x(t)\n\nminimizes the quadratic index\n\n J = Sum {x'(t)Q(t)x(t) + u'(t)R(t)u(t) + 2*x'(t)S(t)u(t)}\n\nFor a system of order n(t) with m control inputs in u(t), Q(t) and R(t) are n(t)×n(t) and m×m symmetric matrices, respectively, and S(t) is an n(t)×m matrix.                 The matrix S is set to zero when omitted. The dimension of u(t) is deduced from the dimension of R(t).  R, Q and S can be alternatively provided as constant real matrices. \n\nAlso returned are the closed-loop characteristic exponents EVALS of A(t)+B(t)F(t).\n\nThe keyword arguments contained in kwargs are those used for the function prdric. \n\nNote: The pair (A(t),B(t)) must be stabilizable and [Q S;S' R] must be nonnegative definite.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdlqry","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdlqry","text":" pdlqry(psys, Q, R, S; kwargs...) -> (F, EVALS)\n\nCompute the optimal periodic stabilizing gain matrix F(t), such that for a periodic discrete-time  state-space model psys of the form\n\nx(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)\n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t),\n\nthe state feedback control law\n\n u(t) = F(t)x(t)\n\nminimizes the quadratic index\n\n J = Sum {y'(t)Q(t)y(t) + u'(t)R(t)u(t) + 2*y'(t)S(t)u(t)}\n\nFor a system with m control inputs u(t) and p outputs, Q(t) and R(t) are p×p and m×m symmetric matrices, respectively, and S(t) is a p×m matrix.   The dimension of u(t) is deduced from the dimension of R(t).  R, Q and S can be alternatively provided as constant real matrices.                The matrix S is set to zero when omitted. \n\nAlso returned are the closed-loop characteristic exponents EVALS of A(t)+B(t)F(t).\n\nThe keyword arguments contained in kwargs are those used for the function prdric. \n\nNote: The pair (A(t),B(t)) must be stabilizable and [Q S;S' R] must be nonnegative definite.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pckeg","page":"Stabilization of periodic systems","title":"PeriodicSystems.pckeg","text":" pckeg(psys, Qw, Rv, Sn; intpol = true, kwargs...) -> (L, EVALS)\n\nCompute the Kalman estimator periodic gain matrix L(t) for a continuous-time periodic state-space model  psys of the form\n\n  .\n  x(t) = A(t)x(t) + B(t)u(t) + w(t)\n  y(t) = C(t)x(t) + D(t)u(t) + v(t)\n\nand the noise covariance data E{w(t)w(t)'} = Qw(t), E{v(t)v(t)'} = Rv(t), E{w(t)v(t)'} = Sn(t),  for a Kalman estimator \n\n   .\n  xe(t) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))\n\nFor a system of order n with p outputs, Qw and Rv are n×n and p×p symmetric matrices, respectively, and Sn is an n×p matrix.                 Qw, Rv and Sn can be alternatively provided as constant real matrices.  The matrix Sn is set to zero when omitted. \n\nAlso returned are the closed-loop characteristic exponents EVALS of A(t)-L(t)C(t).\n\nFor intpol = true (default), the resulting periodic gain L(t) is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If intpol = false, the gain L(t) is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   \n\nThe keyword arguments contained in kwargs are those used for the function pfcric (excepting intpol). \n\nNote: The pair (A(t),C(t)) must be detectable and [Qw Sn;Sn' Rv] must be nonnegative definite.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pckegw","page":"Stabilization of periodic systems","title":"PeriodicSystems.pckegw","text":" pckegw(psys, Qw, Rv, Sn; intpol = true, kwargs...) -> (L, EVALS)\n\nCompute the Kalman estimator periodic gain matrix L(t) for a continuous-time periodic state-space model  psys of the form\n\n  .\n  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)\n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) + v(t)\n\nand the noise covariance data E{w(t)w(t)'} = Qw(t), E{v(t)v(t)'} = Rv(t), E{w(t)v(t)'} = Sn(t),  for a Kalman estimator \n\n   .\n  xe(t) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))\n\nFor a system with mw disturbance inputs and p outputs, Qw and Rv are mw×mw and p×p symmetric matrices, respectively, and Sn is an mw×p matrix.                 Qw, Rv and Sn can be alternatively provided as constant real matrices.                The matrix Sn is set to zero when omitted. The number of disturbance inputs mw is defined by the order of matrix Qw.  Also returned are the closed-loop characteristic exponents EVALS of A(t)-L(t)C(t).\n\nFor intpol = true (default), the resulting periodic gain L(t) is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If intpol = false, the gain L(t) is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   \n\nThe keyword arguments contained in kwargs are those used for the function pfcric (excepting intpol). \n\nNote: The pair (A(t),C(t)) must be detectable,  Qw must be non-negative definite,  Rv must be positive definite and [Qw Sn; Sn' Rv] must be nonnegative definite.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdkeg","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdkeg","text":" pdkeg(psys, Qw, Rv, Sn; kwargs...) -> (L, EVALS)\n\nCompute the Kalman estimator periodic gain matrix L(t) for a discrete-time periodic state-space model  psys of the form\n\nx(t+1) = A(t)x(t) + B(t)u(t) + w(t)\n  y(t) = C(t)x(t) + D(t)u(t) + v(t)\n\nand the noise covariance data E{w(t)w(t)'} = Qw(t), E{v(t)v(t)'} = Rv(t), E{w(t)v(t)'} = Sn(t),  for a Kalman estimator \n\n  xe(t+1) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))\n\nFor a system of order n with p outputs, Qw and Rv are n×n and p×p symmetric matrices, respectively, and Sn is an n×p matrix.                 Qw, Rv and Sn can be alternatively provided as constant real matrices.                The matrix Sn is set to zero when omitted. \n\nAlso returned are the closed-loop characteristic exponents EVALS of A(t)-L(t)C(t).\n\nThe keyword arguments contained in kwargs are those used for the function pfdric. \n\nNote: The pair (A(t),C(t)) must be detectable and [Qw Sn;Sn' Rv] must be nonnegative definite.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdkegw","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdkegw","text":" pdkegw(psys, Qw, Rv, Sn; kwargs...) -> (L, EVALS)\n\nCompute the Kalman estimator periodic gain matrix L(t) for a discrete-time periodic state-space model  psys of the form\n\nx(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)\n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) + v(t)\n\nand the noise covariance data E{w(t)w(t)'} = Qw(t), E{v(t)v(t)'} = Rv(t), E{w(t)v(t)'} = Sn(t),  for a Kalman estimator \n\n  xe(t+1) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))\n\nFor a system with mw disturbance inputs and p outputs, Qw and Rv are mw×mw and p×p symmetric matrices, respectively, and Sn is an mw×p matrix.   Qw, Rv and Sn can be alternatively provided as constant real matrices.                The matrix Sn is set to zero when omitted. The number of disturbance inputs mw is defined by the order of matrix Qw. \n\nAlso returned are the closed-loop characteristic exponents EVALS of A(t)-L(t)C(t).\n\nThe keyword arguments contained in kwargs are those used for the function pfdric. \n\nNote: The pair (A(t),C(t)) must be detectable,  Qw must be non-negative definite,  Rv must be positive definite and [Qw Sn; Sn' Rv] must be nonnegative definite.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pcpofstab_sw","page":"Stabilization of periodic systems","title":"PeriodicSystems.pcpofstab_sw","text":"pcpofstab_sw(psys, ts = missing; K = 100, vinit, optimizer, maxit, vtol, Jtol, gtol, show_trace) -> (Fstab,info)\n\nFor a continuoous-time periodic system psys = (A(t), B(t), C(t), D(t)) of period T determine a periodic output feedback gain matrix  Fstab(t) of the same period and switching times ts,   such that the characteristic exponents Λ of the closed-loop state-matrix A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t) are stable.  The matrices of the system psys are of type PeriodicFunctionMatrix.  The ns switching times contained in the vector ts must satisfy 0 = ts[1] < ts[2] < ... < ts[ns] < T.  If ts = missing, then ts = [0] is used by default (i.e., constant output feedback). \n\nThe output feedback gain Fstab(t) is computed as Fstab(t) = inv(I+F(t)D(t))*F(t), with F(t)  defined as \n\n F(t) = F_i  for t ∈ [ts[i],ts[i+1]) and i ∈ {1, ..., ns-1} or \n F(t) = F_ns for t ∈ [ts[ns],T)\n\nwhere F_i is the i-th gain.   The resulting periodic matrix Fstab(t) is of type PeriodicSwitchingMatrix. The corresponding closed-loop periodic system can be obtained using the function psfeedback.\n\nFor the determination of the optimal feedback gains F_i for i = 1, ...., ns an optimization-based approach is employed using  tools available in the optimization package Optim.jl.  By default, the gradient-free Nelder-Mead local search method for unconstrained minimizations  is employed using the keyword argument setting optimizer = Optim.NelderMead().    The alternative gradient-free Simulated Annealing global search method can be selected with optimizer = Optim.SimulatedAnnealing(). \n\nFor a system with m inputs and p outputs,  an internal optimization variable v is used, formed as an m×p×ns array with v[:,:,i] := F_i, for i = 1, ..., ns.  The performance index to be minimized is J := sdeg(v),  where sdeg(v) is the stability degree defined as the largest real part of the characteristic exponents  of Af(t) := A(t)+B(t)*F(t)*C(t). The keyword argument K is the number of factors used to express the monodromy matrix of Af(t) (default: K = 100),  when evaluating the characteristic exponents.    By default, v is initialized as v = 0 (i.e., a zero array of appropriate dimensions).  The keyword argument vinit = v0 can be used to initialize v with an arbitrary m×p×ns array v0.  \n\nThe optimization process is controlled using several keyword parameters.  The keyword parameter maxit can be used to specify the maximum number of iterations to be performed (default: maxit = 1000). The keyword argument vtol can be used to specify the absolute tolerance in  the changes of the optimization variable v (default: vtol = 0). The keyword argument Jtol can be used to specify the relative tolerance in the changes of the optimization criterion J (default: Jtol = 0),  while gtol is the method specific main convergence tolerance (default: gtol = 1e-3).  With the keyword argument show_trace = true,  a trace of the optimization algorithm's state is shown on stdout (default show_trace = false).    (see the documentation of the Optim.jl package for additional information). \n\nThe returned named tuple info contains (fopt, sdeg0, sdeg, vopt, optres), where:\n\ninfo.fopt is the resulting value of the optimal performance J;\n\ninfo.sdeg0 is the initial stability degree of the closed-loop characteristic exponents;\n\ninfo.sdeg is the resulting stability degree of the closed-loop characteristic exponents;\n\ninfo.vopt is the resulting value of the optimization variable v; \n\ninfo.optres is the result returned by the Optim.optimize(...) function of the  Optim.jl package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). \n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pcpofstab_hr","page":"Stabilization of periodic systems","title":"PeriodicSystems.pcpofstab_hr","text":"pcpofstab_hr(psys,  nh = 0; K = 100, vinit, optimizer = \"local\", maxiter, vtol, Jtol, gtol, show_trace) -> (Fstab,info)\n\nFor a continuoous-time periodic system psys = (A(t), B(t), C(t), D(t)) of period T determine a periodic output feedback gain matrix  Fstab(t) of the same period,   such that the characteristic exponents Λ of the closed-loop state-matrix A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t) are stable.  The matrices of the system psys are of type HarmonicArray. \n\nThe resulting output feedback gain Fstab(t) is computed as Fstab(t) = inv(I+F(t)D(t))*F(t), with F(t) in the harmonic representation form \n\n              nh\n F(t) = F0 +  ∑ ( Fc_i*cos(i*t*2*π/T)+Fs_i*sin(i*2*π*t/T) ) ,\n             i=1\n\nwhere F0 is the constant term, Fc_i is the i-th cosinus coefficient matrix and Fs_i is the i-th sinus coefficient matrix.  By default, the number of harmonics is nh = 0 (i.e., constant output feedback is used). The resulting periodic matrix Fstab(t) is of type HarmonicArray. The corresponding closed-loop periodic system can be obtained using the function psfeedback.\n\nFor the determination of the optimal feedback gains F0, Fc_i and Fs_i for i = 1, ...., nh  an optimization-based approach is employed using using  tools available in the optimization package Optim.jl.  By default, the gradient-free Nelder-Mead local search method for unconstrained minimizations  is employed using the keyword argument setting optimizer = Optim.NelderMead().    The alternative gradient-free Simulated Annealing global search method can be selected with  optimizer = Optim.SimulatedAnnealing(). \n\nFor a system with m inputs and p outputs,  an internal optimization variable v is used, formed as an m*p*(2*nh+1) dimensional vector  v := [vec(F0); vec(Fc_1); vec(Fs_1), ... ; vec(Fc_nh); vec(Fs_nh)].  The performance index to be minimized is J := sdeg(v),  where sdeg(v) is the stability degree defined as the largest real part of the characteristic exponents  of Af(t) := A(t)+B(t)*F(t)*C(t). The keyword argument K is the number of factors used to express the monodromy matrix of Af(t) (default: K = 100),  when evaluating the characteristic exponents.    By default, v is initialized as v = 0 (i.e., a zero array of appropriate dimensions).  The keyword argument vinit = v0 can be used to initialize v with an arbitrary m*p*(2*nh+1) array v0.  \n\nThe optimization process is controlled using several keyword parameters.  The keyword parameter maxiter = maxit can be used to specify the maximum number of iterations to be performed (default: maxit = 1000). The keyword argument vtol can be used to specify the absolute tolerance in  the changes of the optimization variable v (default: vtol = 0). The keyword argument Jtol can be used to specify the relative tolerance in the changes of the optimization criterion J (default: Jtol = 0),  while gtol is the method specific main convergence tolerance (default: gtol = 1e-3).  With the keyword argument show_trace = true,  a trace of the optimization algorithm's state is shown on stdout (default show_trace = false).    (see the documentation of the Optim.jl package for additional information). \n\nThe returned named tuple info contains (fopt, sdeg0, sdeg, vopt, optres), where:\n\ninfo.fopt is the resulting value of the optimal performance J;\n\ninfo.sdeg0 is the initial stability degree of the closed-loop characteristic exponents;\n\ninfo.sdeg is the resulting stability degree of the closed-loop characteristic exponents;\n\ninfo.vopt is the resulting value of the optimization variable v; \n\ninfo.optres is the result returned by the Optim.optimize(...) function of the  Optim.jl package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). \n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdpofstab_sw","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdpofstab_sw","text":"pdpofstab_sw(psys, ns = missing; vinit, optimizer, maxit, vtol, Jtol, gtol, show_trace) -> (Fstab,info)\n\nFor a discrete-time periodic system psys = (A(t), B(t), C(t), D(t)) determine a periodic output feedback gain matrix  Fstab(t) of the same period,   such that the characteristic exponents Λ of the closed-loop state-matrix A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t) are stable.  The matrices of the system psys are of type PeriodicArray.  The switching times for the resulting switching periodic gain Fstab(t) are specified by the  N-dimensional integer vector ns.  By default, ns = [N], where N is the maximal number of samples (i.e., N = psys.period/psys.Ts), which corresponds to a constant gain.  \n\nThe output feedback gain Fstab(t) is computed as Fstab(t) = inv(I+F(t)D(t))*F(t), with F(t)  defined as \n\nF(t) = F_i for t ∈ [ns[i]Δ,ns[i+1]Δ) and i ∈ {1, ..., N-1}, or\nF(t) = F_N for t ∈ [ns[N]Δ,T),\n\nwhere T is the system period (i.e., T = psys.period), Δ is the system sampling time (i.e., Δ = psys.Ts),   and F_i is the i-th gain.  The resulting periodic matrix Fstab(t) is of type SwitchingPeriodicArray. The corresponding closed-loop periodic system can be obtained using the function psfeedback.\n\nFor the determination of the optimal feedback gains F_i for i = 1, ...., N  an optimization-based approach is employed using using  tools available in the optimization package Optim.jl.  By default, the gradient-free Nelder-Mead local search method for unconstrained minimizations  is employed using the keyword argument setting optimizer = Optim.NelderMead().    The alternative gradient-free Simulated Annealing global search method can be selected with optimizer = Optim.SimulatedAnnealing(). \n\nFor a system with m inputs and p outputs,  an internal optimization variable v is used, defined as an m×p×N array.  By default, v is initialized as v = 0 (i.e., a zero array of appropriate dimensions).  The keyword argument vinit = v0 can be used to initialize v with an arbitrary m×p×N array v0.  \n\nThe performance index to be minimized is J := sdeg(v),  where sdeg(v) is the stability degree defined as the largest modulus of the characteristic exponents  of Af(t) := A(t)+B(t)*F(t)*C(t). The optimization process is controlled using several keyword parameters.  The keyword parameter maxit can be used to specify the maximum number of iterations to be performed (default: maxit = 1000). The keyword argument vtol can be used to specify the absolute tolerance in  the changes of the optimization variable v (default: vtol = 0). The keyword argument Jtol can be used to specify the relative tolerance in the changes of the optimization criterion J (default: Jtol = 0),  while gtol is the method specific main convergence tolerance (default: gtol = 1e-3).  With the keyword argument show_trace = true,  a trace of the optimization algorithm's state is shown on stdout (default show_trace = false).    (see the documentation of the Optim.jl package for additional information). \n\nThe returned named tuple info contains (fopt, sdeg0, sdeg, vopt, optres), where:\n\ninfo.fopt is the resulting value of the optimal performance J;\n\ninfo.sdeg0 is the initial stability degree of the closed-loop characteristic exponents;\n\ninfo.sdeg is the resulting stability degree of the closed-loop characteristic exponents;\n\ninfo.vopt is the resulting value of the optimization variable v; \n\ninfo.optres is the result returned by the Optim.optimize(...) function of the  Optim.jl package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). \n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdpofstab_hr","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdpofstab_hr","text":"pdpofstab_hr(psys, nh = 0; vinit, optimizer, maxit, vtol, Jtol, gtol, show_trace) -> (Fstab,info)\n\nFor a discrete-time periodic system psys = (A(t), B(t), C(t), D(t)) of period T determine a periodic output feedback gain matrix  Fstab(t) of the same period,   such that the characteristic exponents Λ of the closed-loop state-matrix A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t) are stable.  The matrices of the system psys are of type HarmonicArray. \n\nThe resulting output feedback gain Fstab(t) is of type PeriodicMatrix and is computed as Fstab(t) = inv(I+F(t)D(t))*F(t), with F(t), of type PeriodicMatrix, built by sampling, with the sample time Δ = abs(psys.Ts), the harmonic representation form \n\n              nh\nFh(t) = F0 +  ∑ ( Fc_i*cos(i*t*2*π/T)+Fs_i*sin(i*2*π*t/T) ) ,\n             i=1\n\nwhere F0 is the constant term, Fc_i is the i-th cosinus coefficient matrix and Fs_i is the i-th sinus coefficient matrix.  F(t) is defined as  F(t) = Fh((Δ(i-1)))' for t ∈ [Δ(i-1), Δi), i = 1, ..., T/Δ.  By default, the number of harmonics is nh = 0 (i.e., constant output feedback is used).  The corresponding closed-loop periodic system can be obtained using the function psfeedback.\n\nFor the determination of the optimal feedback gains F0, Fc_i and Fs_i for i = 1, ...., nh  an optimization-based approach is employed using using  tools available in the optimization package Optim.jl.  By default, the gradient-free Nelder-Mead local search method for unconstrained minimizations  is employed using the keyword argument setting optimizer = Optim.NelderMead().    The alternative gradient-free Simulated Annealing global search method can be selected with  optimizer = Optim.SimulatedAnnealing(). \n\nFor a system with m inputs and p outputs,  an internal optimization variable v is used, formed as an m*p*(2*nh+1) dimensional vector  v := [vec(F0); vec(Fc_1); vec(Fs_1), ... ; vec(Fc_nh); vec(Fs_nh)]'.  The performance index to be minimized isJ := sdeg(v),  wheresdeg(v)is the stability degree defined as the largest modulus of the  characteristic exponents  ofAf(t) := A(t)+B(t)F(t)C(t).  By default,vis initialized asv = 0(i.e., a zero array of appropriate dimensions).  The keyword argumentvinit = v0can be used to initializevwith an arbitrarymp(2*nh+1)arrayv0`.  \n\nThe optimization process is controlled using several keyword parameters.  The keyword parameter maxiter = maxit can be used to specify the maximum number of iterations to be performed (default: maxit = 1000). The keyword argument vtol can be used to specify the absolute tolerance in  the changes of the optimization variable v (default: vtol = 0). The keyword argument Jtol can be used to specify the relative tolerance in the changes of the optimization criterion J (default: Jtol = 0),  while gtol is the method specific main convergence tolerance (default: gtol = 1e-3).  With the keyword argument show_trace = true,  a trace of the optimization algorithm's state is shown on stdout (default show_trace = false).    (see the documentation of the Optim.jl package for additional information). \n\nThe returned named tuple info contains (fopt, sdeg0, sdeg, vopt, optres), where:\n\ninfo.fopt is the resulting value of the optimal performance J;\n\ninfo.sdeg0 is the initial stability degree of the closed-loop characteristic exponents;\n\ninfo.sdeg is the resulting stability degree of the closed-loop characteristic exponents;\n\ninfo.vopt is the resulting value of the optimization variable v; \n\ninfo.optres is the result returned by the Optim.optimize(...) function of the  Optim.jl package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). \n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pclqofc_sw","page":"Stabilization of periodic systems","title":"PeriodicSystems.pclqofc_sw","text":"pclqofc_sw(psys, Q, R, ts = missing; K = 1, sdeg = 0, G = I, vinit, optimizer, stabilizer,\n           maxiter, vtol, Jtol, gtol, show_trace, solver, reltol, abstol, dt,\n           N = 128, intpolmeth = \"cubic\", quad = false ) -> (Fopt,info)\n\nCompute the optimal periodic stabilizing gain matrix Fopt(t), such that for a continuous-time periodic state-space model  psys of the form\n\n  .\n  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)  \n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,\n\nthe output feedback control law\n\nu(t) = Fopt(t)*y(t),\n\nminimizes the expectation of the quadratic index\n\n         ∞\n J = E{ Int [x(t)'*Q(t)*x(t) + u(t)'*R(t)*u(t)]dt },\n        t=0\n\nwhere Q(t) and R(t) are periodic weighting matrices.  The matrices of the system psys are of type PeriodicFunctionMatrix.  For a system of order n with m control inputs in u(t) and p measurable outputs in y(t),  Q(t) and R(t) are n×n and m×m symmetric periodic matrices of type PeriodicFunctionMatrix, respectively.                 The dimension m of u(t) is deduced from the dimension of R(t).  Q and R can be alternatively provided as constant real matrices. \n\nThe resulting m×p periodic output feedback gain Fopt(t) is of type PeriodicSwitchingMatrix,  with the switching times defined by the vector ts.  The ns switching times contained in the vector ts must satisfy 0 = ts[1] < ts[2] < ... < ts[ns] < T, where T is the system period.  If ts = missing, then ts = [0] is used by default (i.e., constant output feedback).\n\nThe output feedback gain Fopt(t) is computed as Fopt(t) = inv(I+F(t)D(t))*F(t), with F(t)  defined as \n\n F(t) = F_i  for t ∈ [ts[i],ts[i+1]) and i ∈ {1, ..., ns-1} or \n F(t) = F_ns for t ∈ [ts[ns],T)\n\nwhere F_i is the i-th gain. \n\nThe covariance matrix of the initial state x(0) can be specified via the keyword argument G (default: G = I) and a desired stability degree of the closed-loop characteristic exponents can be specified using the keyword argument sdeg (default: sdeg = 0). \n\nFor the determination of the optimal feedback gains F_i for i = 1, ...., ns an optimization-based approach is employed using  tools available in the optimization package Optim.jl.  By default, the gradient-based limited-memory quasi-Newton method (also known as L-BFGS) for unconstrained minimizations  is employed using the keyword argument setting optimizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true)), where  an initial step length for the line search algorithm is chosen using the keyword argument alphaguess  (see the LineSearches.jl package for alternative options).  The employed default line search algorithm is HagerZhang() and an alternative method can be specified using the keyword argument linesearch  (e.g., linesearch = LineSearches.MoreThuente()).   Alternative gradient-based methods can be also selected, such as, for example,  the quasi-Newton method BFGS with optimizer = Optim.BFGS(), or  for small size optimization problems, the Nelder-Mead gradient-free method with optimizer = Optim.NelderMead().  For the computation of the function J and its gradient  ∇J, the formulas developed in [1] for stable systems are used. Each evaluation involves the solution of  of a pair of periodic Lyapunov differential equations using single or multiple shooting methods proposed in [2].   If the original system psys is unstable, the computation of a stabilizing feedback is performed using the same optimization techniques applied iteratively to systems  with modified the state matrices of the form  A(t)-αI, where α ≥ 0 is chosen such that A(t)-αI is stable, and the values of α are successively decreased until the stabilization is achieved. The optimization method for stabilization can be independently selected using the keyword argument stabilizer, with the default setting   stabilizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true)). If only stabilization is desired, then use  optimizer = nothing. \n\nAn internal optimization variable v is used, formed as an m×p×ns array with v[:,:,i] := F_i, for i = 1, ..., ns.  By default, v is initialized as v = 0 (i.e., a zero array of appropriate dimensions).  The keyword argument vinit = v0 can be used to initialize v with an arbitrary m×p×ns array v0.   \n\nThe optimization process is controlled using several keyword parameters.  The keyword parameter maxiter = maxit can be used to specify the maximum number of iterations to be performed (default: maxit = 1000). The keyword argument vtol can be used to specify the absolute tolerance in  the changes of the optimization variable v (default: vtol = 0). The keyword argument Jtol can be used to specify the relative tolerance in the changes of the optimization criterion J (default: Jtol = 0),  while gtol can be used to specify the absolute tolerance in the gradient  ∇J, in infinity norm (default: gtol = 1e-5).  With the keyword argument show_trace = true,  a trace of the optimization algorithm's state is shown on stdout (default show_trace = false).    For stabilization purposes,  the values Jtol = 1.e-3, gtol = 1.e-2, maxit = 20 are used to favor faster convergence. \n\nThe returned named tuple info contains (fopt, sdeg0, sdeg, vopt, optres), where:\n\ninfo.fopt is the resulting value of the optimal performance J;\n\ninfo.sdeg0 is the initial stability degree of the closed-loop characteristic exponents;\n\ninfo.sdeg is the resulting stability degree of the closed-loop characteristic exponents;\n\ninfo.vopt is the resulting value of the optimization variable v; \n\ninfo.optres is the result returned by the Optim.optimize(...) function of the  Optim.jl package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). \n\nSeveral keyword arguments can be used to control the integration of the involved ODE's for the solution of  periodic differential Lyapunov equations for function and gradient evaluations. \n\nIf K = 1 (default), the single shooting method is employed to compute periodic generators [1].  If K > 1, the multiple-shooting method of [2] is employed, first, to convert the continuous-time periodic Lyapunov differential equations into discrete-time periodic Lyapunov equations satisfied by  the generator solution in K grid points and then to compute the solution by solving an appropriate discrete-time periodic Lyapunov  equation using the periodic Schur method of [3]. If quad = true, a quadrature-based evaluation of gradients is used, as proposed in [1], in conjunction with interpolation techniques. The interpolation method to be used can be specified using the keyword parameter intpolmeth (default: intpolmeth = \"cubic\").  Other interpolation options are \"intpolmeth = quadratic\", intpolmeth = \"linear\" and intpolmeth = \"constant\". The number of sample values to be used for interpolation can be specified with the keyword parameter N (deafult: N = 128). \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\nParallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable. \n\n[1] L. Vigano, M. Bergamasco, M. Lovera, and A. Varga. Optimal periodic output feedback control: a continuous-time approach and a case study.     Int. J. Control, Vol. 83, pp. 897–914, 2010.  \n\n[2] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[3] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pclqofc_hr","page":"Stabilization of periodic systems","title":"PeriodicSystems.pclqofc_hr","text":"pclqofc_hr(psys, Q, R, nh = 0; K = 1, sdeg = 0, G = I, vinit, optimizer, stabilizer,\n           maxiter, vtol, Jtol, gtol, show_trace, solver, reltol, abstol, dt,\n           N = 128, intpolmeth = \"cubic\", quad = false ) -> (Fopt,info)\n\nCompute the optimal periodic stabilizing gain matrix Fopt(t), such that for a continuous-time periodic state-space model  psys of the form\n\n  .\n  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)  \n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,\n\nthe output feedback control law\n\nu(t) = Fopt(t)*y(t),\n\nminimizes the expectation of the quadratic index\n\n         ∞\n J = E{ Int [x(t)'*Q(t)*x(t) + u(t)'*R(t)*u(t)]dt },\n        t=0\n\nwhere Q(t) and R(t) are periodic weighting matrices.  The matrices of the system psys are of type HarmonicArray.  For a system of order n with m control inputs in u(t) and p measurable outputs in y(t),  Q(t) and R(t) are n×n and m×m symmetric periodic matrices of type HarmonicArray, respectively.                 The dimension m of u(t) is deduced from the dimension of R(t).  Q and R can be alternatively provided as constant real matrices. \n\nThe resulting m×p periodic output feedback gain Fopt(t) is of type HarmonicArray and is computed as Fopt(t) = inv(I+F(t)D(t))*F(t), with F(t) in the harmonic representation form \n\n              nh\n F(t) = F0 +  ∑ ( Fc_i*cos(i*t*2*π/T)+Fs_i*sin(i*2*π*t/T) ) ,\n             i=1\n\nwhere T is the system period, F0 is the constant term, Fc_i is the i-th cosinus coefficient matrix and Fs_i is the i-th sinus coefficient matrix.  By default, the number of harmonics is nh = 0 (i.e., constant output feedback is used).\n\nThe covariance matrix of the initial state x(0) can be specified via the keyword argument G (default: G = I) and a desired stability degree of the closed-loop characteristic exponents can be specified using the keyword argument sdeg (default: sdeg = 0). \n\nFor the determination of the optimal feedback gains F0, Fc_i and Fs_i for i = 1, ...., nh an optimization-based approach is employed using  tools available in the optimization package Optim.jl.  By default, the gradient-based limited-memory quasi-Newton method (also known as L-BFGS) for unconstrained minimizations  is employed using the keyword argument setting optimizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true)), where  an initial step length for the line search algorithm is chosen using the keyword argument alphaguess  (see the LineSearches.jl package for alternative options).  The employed default line search algorithm is HagerZhang() and an alternative method can be specified using the keyword argument linesearch  (e.g., linesearch = LineSearches.MoreThuente()).   Alternative gradient-based methods can be also selected, such as, for example,  the quasi-Newton method BFGS with optimizer = Optim.BFGS(), or  for small size optimization problems, the Nelder-Mead gradient-free method with optimizer = Optim.NelderMead().  For the computation of the function J and its gradient  ∇J, the formulas developed in [1] for stable systems are used. Each evaluation involves the solution of  of a pair of periodic Lyapunov differential equations using single or multiple shooting methods proposed in [2].   If the original system psys is unstable, the computation of a stabilizing feedback is performed using the same optimization techniques applied iteratively to systems  with modified the state matrices of the form  A(t)-αI, where α ≥ 0 is chosen such that A(t)-αI is stable, and the values of α are successively decreased until the stabilization is achieved. The optimization method for stabilization can be independently selected using the keyword argument stabilizer, with the default setting   stabilizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true)). If only stabilization is desired, then use  optimizer = nothing. \n\nAn internal optimization variable v is used, formed as an m*p*(2*nh+1) dimensional vector v := [vec(F0); vec(Fc_1); vec(Fs_1), ... ; vec(Kc_nh); vec(Ks_nh)]'.  By default,vis initialized asv = 0(i.e., a zero vector of appropriate dimension).  The keyword argumentvinit = v0can be used to initializevwith an arbitrary vectorv0`.   \n\nThe optimization process is controlled using several keyword parameters.  The keyword parameter maxiter = maxit can be used to specify the maximum number of iterations to be performed (default: maxit = 1000). The keyword argument vtol can be used to specify the absolute tolerance in  the changes of the optimization variable v (default: vtol = 0). The keyword argument Jtol can be used to specify the relative tolerance in the changes of the optimization criterion J (default: Jtol = 0),  while gtol can be used to specify the absolute tolerance in the gradient  ∇J, in infinity norm (default: gtol = 1e-5).  With the keyword argument show_trace = true,  a trace of the optimization algorithm's state is shown on stdout (default show_trace = false).    For stabilization purposes,  the values Jtol = 1.e-3, gtol = 1.e-2, maxit = 20 are used to favor faster convergence. \n\nThe returned named tuple info contains (fopt, sdeg0, sdeg, vopt, optres), where:\n\ninfo.fopt is the resulting value of the optimal performance J;\n\ninfo.sdeg0 is the initial stability degree of the closed-loop characteristic exponents;\n\ninfo.sdeg is the resulting stability degree of the closed-loop characteristic exponents;\n\ninfo.vopt is the resulting value of the optimization variable v; \n\ninfo.optres is the result returned by the Optim.optimize(...) function of the  Optim.jl package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). \n\nSeveral keyword arguments can be used to control the integration of the involved ODE's for the solution of  periodic differential Lyapunov equations for function and gradient evaluations. \n\nIf K = 1 (default), the single shooting method is employed to compute periodic generators [1].  If K > 1, the multiple-shooting method of [2] is employed, first, to convert the continuous-time periodic Lyapunov differential equations into discrete-time periodic Lyapunov equations satisfied by  the generator solution in K grid points and then to compute the solution by solving an appropriate discrete-time periodic Lyapunov  equation using the periodic Schur method of [3]. If quad = true, a quadrature-based evaluation of gradients is used, as proposed in [1], in conjunction with interpolation techniques. The interpolation method to be used can be specified using the keyword parameter intpolmeth (default: intpolmeth = \"cubic\").  Other interpolation options are \"intpolmeth = quadratic\", intpolmeth = \"linear\" and intpolmeth = \"constant\". The number of sample values to be used for interpolation can be specified with the keyword parameter N (deafult: N = 128). \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\nParallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable. \n\n[1] L. Vigano, M. Bergamasco, M. Lovera, and A. Varga. Optimal periodic output feedback control: a continuous-time approach and a case study.     Int. J. Control, Vol. 83, pp. 897–914, 2010.  \n\n[2] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[3] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdlqofc","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdlqofc","text":"pdlqofc(psys, Q, R; S, G = I, sdeg = 1, stabilizer, optimizer, vinit, maxiter, vtol, Jtol, gtol, show_trace) -> (Fopt, info)\n\nCompute for the discrete-time periodic state-space system psys = (A(t),B(t),C(t),D(t)) of the form\n\nx(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t) \n  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,\n\nthe optimal periodic feedback gain Fopt(t) in the output feedback control law  \n\nu(t) = Fopt(t)*y(t),\n\nwhich minimizes the expectation of the quadratic index\n\n J = E{ Sum [x(t)'*Q(t)*x(t) + 2*x(t)'*S(t)*u(t) + u(t)'*R(t)*u(t)] },\n\nwhere Q(t), R(t) and S(t) are periodic weighting matrices.  For a system of order n with m control inputs in u(t) and p measurable outputs in y(t),  Q(t) and R(t) are n×n and m×m symmetric periodic matrices, respectively, and  S(t) is an n×m periodic matrix, which can be specified via the keyword argument S.  By default S = missing, in which case, S(t) = 0 is assumed.    The periodic matrices Q(t),R(t) and S(t) have the same type as the matrices of the state-space system, i.e., either of type PeriodicMatrix or PeriodicArray.   The dimension m of u(t) is deduced from the dimension of R(t).  Q, R and S can be alternatively provided as constant real matrices. \n\nThe resulting m×p periodic output feedback gain Fopt(t) has the same type as the state-space system matrices and is computed as Fopt(t) = inv(I+F(t)D(t))*F(t), with F(t)  defined as \n\n F(t) = F_i  for i ∈ {1, ..., ns}\n\nwhere ns is the number of sampling times in a period (i.e., ns = psys.period/psys.Ts) and F_i is the i-th gain. \n\nThe covariance of the initial state x(0) can be specified via the keyword argument G (default: G = I) and a desired stability degree of the closed-loop characteristic multipliers can be specified using the keyword argument sdeg (default: sdeg = 1). \n\nFor the determination of the optimal feedback gains F_i for i = 1, ...., ns an optimization-based approach is employed using  tools available in the optimization package Optim.jl.  By default, the gradient-based limited-memory quasi-Newton method (also known as L-BFGS) for unconstrained minimizations  is employed using the keyword argument setting optimizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true)), where  an initial step length for the line search algorithm is chosen using the keyword argument alphaguess  (see the LineSearches.jl package for alternative options).  The employed default line search algorithm is HagerZhang() and an alternative method can be specified using the keyword argument linesearch  (e.g., linesearch = LineSearches.MoreThuente()).   Alternative gradient-based methods can be also selected, such as, for example,  the quasi-Newton method BFGS with optimizer = Optim.BFGS(), or  for small size optimization problems, the Nelder-Mead gradient-free method with optimizer = Optim.NelderMead().  For the computation of the function J and its gradient  ∇J, the formulas developed in [1] for stable systems are used. Each evaluation involves the solution of  of a pair of periodic Lyapunov difference equations using the method proposed in [2].   If the original system psys is unstable, the computation of a stabilizing feedback is performed using the same optimization techniques applied iteratively to systems  with modified state matrices of the form  A(t)/α and control matrices B(t)/α, where α ≥ 1 is chosen such that A(t)/α is stable, and the values of α are successively decreased until the stabilization is achieved with α = 1. The optimization method for stabilization can be independently selected using the keyword argument stabilizer, with the default setting   stabilizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true)). If only stabilization is desired, then use  optimizer = nothing. \n\nAn internal optimization variable v is used, formed as an m×p×ns array with v[:,:,i] := F_i, for i = 1, ..., ns.  By default, v is initialized as v = 0 (i.e., a zero array of appropriate dimensions).  The keyword argument vinit = v0 can be used to initialize v with an arbitrary m×p×ns real array v0.   \n\nThe optimization process is controlled using several keyword parameters.  The keyword parameter maxiter = maxit can be used to specify the maximum number of iterations to be performed (default: maxit = 1000). The keyword argument vtol can be used to specify the absolute tolerance in  the changes of the optimization variable v (default: vtol = 0). The keyword argument Jtol can be used to specify the relative tolerance in the changes of the optimization criterion J (default: Jtol = 0),  while gtol can be used to specify the absolute tolerance in the gradient ∇J, in infinity norm (default: gtol = 1e-5).  With the keyword argument show_trace = true,  a trace of the optimization algorithm's state is shown on stdout (default show_trace = false).    For stabilization purposes, the values Jtol = 1.e-3, gtol = 1.e-2, maxit = 20 are used to favor faster convergence. \n\nThe returned named tuple info contains (fopt, sdeg0, sdeg, vopt, optres), where:\n\ninfo.fopt is the resulting value of the optimal performance J;\n\ninfo.sdeg0 is the initial stability degree of the closed-loop characteristic multipliers;\n\ninfo.sdeg is the resulting stability degree of the closed-loop characteristic multipliers;\n\ninfo.vopt is the resulting value of the optimization variable v; \n\ninfo.optres is the result returned by the Optim.optimize(...) function of the  Optim.jl package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). \n\nA bound-constrained optimization can be performed using the keyword argument lub = (lb, ub), where lb is the lower bound and ub is the upper bound on the feedback gains.  By default,  lub = missing in which case the bounds lb = -Inf and ub = Inf are assumed. \n\nReferences     \n\n[1] A. Varga and S. Pieters. Gradient-based approach to solve optimal periodic output feedback problems.      Automatica, vol.34, pp. 477-481, 1998.\n\n[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.                Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"psstab.html#PeriodicSystems.pdlqofc_sw","page":"Stabilization of periodic systems","title":"PeriodicSystems.pdlqofc_sw","text":"pdlqofc_sw(psys, Q, R, ns; S, vinit, kwargs...) -> (Fopt, info)\n\nCompute for the discrete-time periodic state-space system psys = (A(t),B(t),C(t),D(t)) of the form\n\nx(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)       y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,\n\nthe optimal switching periodic feedback gain Fopt(t) in the output feedback control law  \n\nu(t) = Fopt(t)*y(t),\n\nwhich minimizes the expectation of the quadratic index \n\n J = E{ Sum [x(t)'*Q(t)*x(t) + 2*x(t)'*S(t)*u(t) + u(t)'*R(t)*u(t)] },\n\nwhere Q(t), R(t) and S(t) are periodic weighting matrices.  For a system of order n with m control inputs in u(t) and p measurable outputs in y(t),  Q(t) and R(t) are n×n and m×m symmetric periodic matrices, respectively, and  S(t) is an n×m periodic matrix, which can be specified via the keyword argument S.  By default S = missing, in which case, S(t) = 0 is assumed.    The periodic matrices Q(t),R(t) and S(t) have the same type as the matrices of the state-space system, i.e., either of type PeriodicMatrix or PeriodicArray.   The dimension m of u(t) is deduced from the dimension of R(t).  Q, R and S can be alternatively provided as constant real matrices. \n\nThe switching times for the resulting switching periodic gain Fopt(t) are specified by the  N-dimensional integer vector ns.  By default, ns = 1:N, where N is the maximal number of samples (i.e., N = psys.period/psys.Ts). \n\nThe resulting m×p periodic output feedback gain Fopt(t) has the type SwitchingPeriodicArray and is computed as Fopt(t) = inv(I+F(t)D(t))*F(t), with F(t)  defined as \n\n F(t) = F_i for t ∈ [ns[i]Δ,ns[i+1]Δ) and i ∈ {1, ..., N-1}, or\n F(t) = F_N for t ∈ [ns[N]Δ,T),\n\nwhere T is the system period (i.e., T = psys.period), Δ is the system sampling time (i.e., Δ = psys.Ts)  and F_i is the i-th gain. \n\nIf an initial value for the optimization variable v is provided using the keyword argument vinit = gains, then gains must be an m×p×N array, where m and p are the numbers of system control inputs and outputs. By default, vinit = missing, in which case a zero matrix gains = 0 is assumed.  \n\nThe rest of keyword arguments contained in kwargs are the same as those used for the function pdlqofc.  See its documentation for the description of all keyword arguments. \n\nThe computation of gradient fully exploits the switching structure of the feedback gain, using formulas which generalize the case of constant feedback considered in [1].     \n\nReferences     \n\n[1] A. Varga and S. Pieters. Gradient-based approach to solve optimal periodic output feedback problems.      Automatica, vol.34, pp. 477-481, 1998.\n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#Analysis-of-periodic-systems","page":"Analysis of periodic systems","title":"Analysis of periodic systems","text":"","category":"section"},{"location":"psanalysis.html","page":"Analysis of periodic systems","title":"Analysis of periodic systems","text":"pspole  Computation of the poles of a periodic system.\npszero  Computation of the zeros of a periodic system.\nisstable  Assessment of stability of a periodic system.\npshanorm  Evaluation of the Hankel-norm of a periodic system.\npsh2norm  Evaluation of the H2-norm of a periodic system.\npslinfnorm  Evaluation of the L∞/H∞-norm of a periodic system.\npstimeresp  Time response of a periodic system.\npsstepresp  Step response of a periodic system.\npseval  Evaluation of the value of the transfer function matrix of the lifted discrete-time periodic system.","category":"page"},{"location":"psanalysis.html","page":"Analysis of periodic systems","title":"Analysis of periodic systems","text":"pspole\npszero\nisstable\npshanorm\npsh2norm\npslinfnorm\npstimeresp\npsstepresp\npseval","category":"page"},{"location":"psanalysis.html#PeriodicSystems.pspole","page":"Analysis of periodic systems","title":"PeriodicSystems.pspole","text":"pspole(psys::PeriodicStateSpace{PM}[,K]; kwargs...) -> val\n\nReturn for the periodic system psys = (A(t),B(t),C(t),D(t)) the complex vector val containing  the characteristic exponents of the periodic matrix A(t) (also called the poles of the system psys). \n\nDepending on the underlying periodic matrix type PM, the optional argument K and keyword arguments kwargs may have the following values:\n\nif PM = PeriodicFunctionMatrix, or PM = PeriodicSymbolicMatrix, or PM = PeriodicTimeSeriesMatrix, then K is the number of factors used to express the monodromy matrix of A(t) (default: K = 1)  and kwargs are the keyword arguments of  pseig(::PeriodicFunctionMatrix); \nif PM = HarmonicArray, then K is the number of harmonic components used to represent the Fourier series of A(t) (default: K = max(10,nh-1), nh is the number of harmonics terms of A(t))  and kwargs are the keyword arguments of  psceig(::HarmonicArray); \nif PM = FourierFunctionMatrix, then K is the number of harmonic components used to represent the Fourier series of A(t) (default: K = max(10,nh-1), nh is the number of harmonics terms of A(t))  and kwargs are the keyword arguments of  psceig(::FourierFunctionMatrix); \nif PM = PeriodicMatrix or PM = PeriodicArray, then K is the starting sample time (default: K = 1)  and kwargs are the keyword arguments of  psceig(::PeriodicMatrix); \n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#PeriodicSystems.pszero","page":"Analysis of periodic systems","title":"PeriodicSystems.pszero","text":"pszero(psys::PeriodicStateSpace{HarmonicArray}[, N]; P, atol, rtol, fast) -> val\npszero(psys::PeriodicStateSpace{PeriodicFunctionMatrix}[, N]; P, atol, rtol, fast) -> val\npszero(psys::PeriodicStateSpace{PeriodicSymbolicMatrix}[, N]; P, atol, rtol, fast) -> val\n\nCompute the finite and infinite zeros of a continuous-time periodic system psys = (A(t), B(t), C(t), D(t)) in val,  where the periodic system matrices A(t), B(t), C(t), and D(t) are in a Harmonic Array, or  Periodic Function Matrix, or Periodic Symbolic Matrix representation  (the last two representation are automatically converted to a Harmonic Array representation).  N is the number of selected harmonic components in the Fourier series of the system matrices (default: N = max(20,nh-1),  where nh is the maximum number of harmonics terms) and the keyword parameter P is the number of full periods  to be considered (default: P = 1) to build  a frequency-lifted LTI representation based on truncated block Toeplitz matrices (see ps2fls). \n\nThe computation of the zeros of the complex lifted system is performed by reducing the corresponding system pencil  to an appropriate Kronecker-like form which exhibits the finite and infinite eigenvalues.  The reduction is performed using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. For a system psys of period T,  the finite zeros are determined as those eigenvalues which have imaginary parts in the interval [-ω/2, ω/2], where ω = 2π/(P*T). To eliminate possible spurious finite eigenvalues, the intersection of two finite eigenvalue sets is computed  for two lifted systems obtained for N and N+2 harmonic components.     The infinite zeros are determined as the infinite zeros of the LTI system (A(ti), B(ti), C(ti), D(ti))  resulting for a random time value ti. Warning: While this evaluation of the number of infinite zeros mostly  provides the correct result, there is no theoretical assessment of this approach (counterexamples are welcome!). \n\nThe keyword arguments atol  and rtol specify the absolute and relative tolerances for the nonzero elements of the underlying lifted system pencil, respectively.  The default relative tolerance is n*ϵ, where n is the size of the smallest dimension of the pencil, and ϵ is the  working machine epsilon. \n\n\n\n\n\npszero(psys::PeriodicStateSpece{FourierFunctionMatrix}[, N]; P, atol, rtol, fast) -> val\n\nCompute the finite and infinite zeros of a continuous-time periodic system psys = (Af(t), Bf(t), Cf(t), Df(t)) in val,  where the periodic system matrices Af(t), Bf(t), Cf(t), and Df(t) are in a Fourier Function Matrix representation.  N is the number of selected harmonic components in the Fourier series of the system matrices (default: N = max(20,nh-1),  where nh is the maximum number of harmonics terms) and the keyword parameter P is the number of full periods  to be considered (default: P = 1) to build  a frequency-lifted LTI representation based on truncated block Toeplitz matrices (see ps2frls). \n\nThe computation of the zeros of the real lifted system is performed by reducing the corresponding system pencil  to an appropriate Kronecker-like form which exhibits the finite and infinite eigenvalues.  The reduction is performed using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. For a system psys of period T,  the finite zeros are determined as those eigenvalues which have imaginary parts in the interval [-ω/2, ω/2], where ω = 2π/(P*T).  To eliminate possible spurious finite eigenvalues, the intersection of two finite eigenvalue sets is computed  for two lifted systems obtained for N and N+2 harmonic components.     The infinite zeros are determined as the infinite zeros of the LTI system (Af(ti), Bf(ti), Cf(ti), Df(ti))  resulting for a random time value ti. Warning: While this evaluation of the number of infinite zeros mostly  provides the correct result, there is no theoretical assessment of this approach (counterexamples are welcome!). \n\nThe keyword arguments atol  and rtol specify the absolute and relative tolerances for the nonzero elements of the underlying lifted system pencil, respectively.  The default relative tolerance is n*ϵ, where n is the size of the smallest dimension of the pencil, and ϵ is the  working machine epsilon. \n\n\n\n\n\n pszero(psys::PeriodicStateSpace{PeriodicMatrix}[, K]; atol, rtol, fast) -> val\n pszero(psys::PeriodicStateSpace{PeriodicArray}[, K]; atol, rtol, fast) -> val\n\nCompute the finite and infinite zeros of a discrete-time periodic system psys = (A(t), B(t), C(t), D(t)) in val,  where the periodic system matrices A(t), B(t), C(t), and D(t) are in either Periodic Matrix or Periodic Array representation.  The optional argument K specifies a desired time to start the sequence of periodic matrices (default: K = 1).\n\nThe computation of zeros relies on the fast structure exploiting reduction of singular periodic pencils as described in [1],  which separates a matrix pencil M-λN which contains the infinite and finite zeros  and the left and right Kronecker indices. The reduction is performed using orthonal similarity transformations and involves rank decisions based  on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguments atol and rtol specify the absolute and relative tolerances for the nonzero elements of the periodic system matrices, respectively.  The default relative tolerance is n*ϵ, where n is proportional with the largest dimension of the periodic matrices,  and ϵ is the working machine epsilon. \n\nReferences\n\n[1] A. Varga and P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems & Control Letters 50:371–381, 2003.\n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#DescriptorSystems.isstable","page":"Analysis of periodic systems","title":"DescriptorSystems.isstable","text":" isstable(psys[, K = 1]; smarg = 1, fast = false, offset = sqrt(ϵ), kwargs...) -> Bool\n\nReturn true if the continuous-time periodic system psys has only stable characteristic multipliers and false otherwise. \n\nTo assess the stability, the absolute values of the characteristic multipliers (i.e., the eigenvalues of the monodromy matrix) must be less than smarg-β, where smarg is the discrete-time stability margin (default: smarg = 1)  and  β is an offset specified via the keyword parameter offset = β to be used to numerically assess the stability of eigenvalues. The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe monodromy matrix is determined as a product K state transition matrices (default: K = 1)  computed by integrating numerically a homogeneous linear ODE with periodic coefficients  (see function monodromy for options which can be specified via the keyword arguments kwargs). If fast = false (default) then the characteristic multipliers are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed.  This later option may occasionally lead to inaccurate results for large number of matrices. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\nisstable(psys; smarg = 1, fast = false, offset = sqrt(ϵ)) -> Bool\n\nReturn true if the discrete-time periodic system psys has only stable characteristic multipliers and false otherwise. \n\nTo assess the stability, the absolute values of the characteristic multipliers (i.e., the eigenvalues of the monodromy matrix) must be less than smarg-β, where smarg is the discrete-time stability margin (default: smarg = 1)  and  β is an offset specified via the keyword parameter offset = β to be used to numerically assess the stability of eigenvalues. The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf fast = false (default) then the characteristic multipliers are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed.  This later option may occasionally lead to inaccurate results for large number of matrices. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#PeriodicSystems.pshanorm","page":"Analysis of periodic systems","title":"PeriodicSystems.pshanorm","text":"pshanorm(psys; smarg = 1, lifting = false, offset = sqrt(ϵ)) -> nrm\n\nCompute the Hankel-norm of a stable discrete-time periodic system psys = (A(t),B(t),C(t),D(t)).   For the computation of the norm, the formulas given in [1] are employed.  The Hankel norm is computed as\n\n nrm = maximum(sqrt(Λ(P(t)Q(t))),\n\nwhere P(t) is the controllability Gramian satisfying the periodic Lyapunov equation\n\n P(t+1) = A(t)P(t)A(t)' + B(t)B(t)',\n\nand Q(t) is the observability Gramian satisfying the periodic Lyapunov equation\n\nQ(t) = A(t)'Q(t+1)A(t) + C(t)'C(t) .\n\nTo assess the stability, the absolute values of the characteristic multipliers of A(t)  must be less than smarg-β, where smarg is the discrete-time stability margin (default: smarg = 1)  and  β is an offset specified via the keyword parameter offset = β to be used to numerically assess the stability of eigenvalues. The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf lifting = false (default), then the norm is evaluated using an approach based on the periodic Schur decomposition of A(t),  while if lifting = true the norm of the lifted cyclic system is evaluated.   This later option may lead to excessive computational times for large matrices or large periods. \n\nReferences\n\n[1] S. Bittanti and P. Colaneri. Periodic Systems : Filtering and Control.     Springer-Verlag London, 2009. \n\n\n\n\n\npshanorm(psys, K; smarg = 1, offset = sqrt(ϵ), solver = \"\", reltol = 1.e-4, abstol = 1.e-7) -> nrm\n\nCompute the Hankel-norm of a stable continuous-time periodic system psys = (A(t),B(t),C(t),D(t)).   For the computation of the norm, the approach suggested in [1] is employed,  in conjunction with the multiple-shooting approach using K discretization points.   For a periodic system of period  T, the Hankel-norm is defined as\n\n nrm = sqrt(max(Λ(P(t)Q(t)))), for t ∈ [0,T]\n\nwhere P(t) is the controllability Gramian satisfying the periodic differential Lyapunov equation\n\n .\n P(t) = A(t)P(t)A(t)' + B(t)B(t)',\n\nand Q(t) is the observability Gramian satisfying the periodic differential Lyapunov equation\n\n .\n-Q(t) = A(t)'Q(t)A(t) + C(t)'C(t) .\n\nThe norm is evaluated from the K time values of P(t) and Q(t) in the interval [0,T] and  the precision is (usually) better for larger values of K.\n\nTo assess the stability, the absolute values of the characteristic multipliers of A(t)  must be less than smarg-β, where smarg is the discrete-time stability margin (default: smarg = 1)  and  β is an offset specified via the keyword parameter offset = β to be used to numerically assess the stability of eigenvalues. The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and  stepsize dt (default: dt = 0). The value stepsize is relevant only if solver = \"symplectic\", in which case an adaptive stepsize strategy is used ifdt = 0and a fixed stepsize is used ifdt > 0. (see also [tvstm`](@ref)). \n\nReferences\n\n[1] A. Varga, On solving periodic differential matrix equations with applications to periodic system norms computation.     Proc. CDC/ECC, Seville, p.6545-6550, 2005.  \n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#PeriodicSystems.psh2norm","page":"Analysis of periodic systems","title":"PeriodicSystems.psh2norm","text":"psh2norm(psys; adj = false, smarg = 1, fast = false, offset = sqrt(ϵ)) -> nrm\n\nCompute the H2-norm of a discrete-time periodic system psys = (A(t),B(t),C(t),D(t)).   For the computation of the norm, the formulas given in [1] are employed.  For adj = false the norm is computed as\n\n nrm = sqrt(sum(tr(C(t)P(t)C(t)'+D(t)*D(t)'))),\n\nwhere P(t) is the controllability Gramian satisfying the periodic Lyapunov equation\n\n P(t+1) = A(t)P(t)A(t)' + B(t)B(t)',\n\nwhile for adj = true the norm is computed as\n\nnrm = sqrt(sum(tr(B(t)'Q(t+1)B(t)+D(t)'*D(t)))),\n\nwhere Q(t) is the observability Gramian satisfying the periodic Lyapunov equation\n\nQ(t) = A(t)'Q(t+1)A(t) + C(t)'C(t) .\n\nThe norm is set to infinity for an unstable system.\n\nTo assess the stability, the absolute values of the characteristic multipliers of A(t)  must be less than smarg-β, where smarg is the discrete-time stability margin (default: smarg = 1)  and  β is an offset specified via the keyword parameter offset = β to be used to numerically assess the stability of eigenvalues. The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf fast = false (default) then the norm is evaluated using an approach based on the periodic Schur decomposition of A(t),  while if fast = true the norm of the lifted standard system is evaluated.   This later option may occasionally lead to inaccurate results for large number of matrices. \n\nReferences\n\n[1] S. Bittanti and P. Colaneri. Periodic Systems : Filtering and Control.     Springer-Verlag London, 2009. \n\n\n\n\n\npsh2norm(psys, K; adj = false, smarg = 1, fast = false, offset = sqrt(ϵ), solver = \"\", reltol = 1.e-4, abstol = 1.e-7, quad = false) -> nrm\n\nCompute the H2-norm of a continuous-time periodic system psys = (A(t),B(t),C(t),D(t)).   For the computation of the norm, the formulas given in [1] are employed,  in conjunction with the multiple-shooting approach of [2] using K discretization points.   For a periodic system of period  T, for adj = false the norm is computed as\n\n nrm = sqrt(Integral(tr(C(t)P(t)C(t)')))dt/T),\n\nwhere P(t) is the controllability Gramian satisfying the periodic differential Lyapunov equation\n\n .\n P(t) = A(t)P(t)A(t)' + B(t)B(t)',\n\nwhile for adj = true the norm is computed as\n\nnrm = sqrt(Integral(tr(B(t)'Q(t)B(t)))dt/T),\n\nwhere Q(t) is the observability Gramian satisfying the periodic differential Lyapunov equation\n\n .\n-Q(t) = A(t)'Q(t)A(t) + C(t)'C(t) .\n\nIf quad = true, a simple quadrature formula based on the sum of time values is employed (see [2]). This option ensures a faster evaluation, but is potentially less accurate then the exact evaluation employed if quad = false (default). \n\nThe norm is set to infinity for an unstable system or for a non-zero D(t).\n\nTo assess the stability, the absolute values of the characteristic multipliers of A(t)  must be less than smarg-β, where smarg is the discrete-time stability margin (default: smarg = 1)  and  β is an offset specified via the keyword parameter offset = β to be used to numerically assess the stability of eigenvalues. The default value used for β is sqrt(ϵ), where ϵ is the working machine precision.  If fast = false (default) then the stability is checked using an approach based on the periodic Schur decomposition of A(t),  while if fast = true the stability is checked using a lifting-based approach.  \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and  stepsize dt (default: dt = 0). The value stepsize is relevant only if solver = \"symplectic\", in which case an adaptive stepsize strategy is used ifdt = 0and a fixed stepsize is used ifdt > 0. (see also [tvstm`](@ref)). \n\nReferences\n\n[1] P. Colaneri. Continuous-time periodic systems in H2 and H∞: Part I: Theoretical Aspects.     Kybernetika, 36:211-242, 2000. \n\n[2] A. Varga, On solving periodic differential matrix equations with applications to periodic system norms computation.     Proc. CDC/ECC, Seville, p.6545-6550, 2005.  \n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#PeriodicSystems.pslinfnorm","page":"Analysis of periodic systems","title":"PeriodicSystems.pslinfnorm","text":"pslinfnorm(psys, hinfnorm = false, rtolinf = 0.001, fast = true, offset = sqrt(ϵ)) -> (linfnorm, fpeak)\npshinfnorm(psys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ)) -> (hinfnorm, fpeak)\n\nCompute for a discrete-time periodic system psys = (A(t),B(t),C(t),D(t) with the lifted transfer function  matrix G(λ)  the L∞ norm linfnorm with pslinfnorm or the H∞ norm hinfnorm with pshinfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved. If hinfnorm = true, the H∞ norm is computed with pslinfnorm.\n\nThe L∞ norm is infinite if psys has poles on the stability domain boundary,  i.e., on the unit circle. The H∞ norm is infinite if psys has unstable poles. \n\nTo check the lack of poles on the stability domain boundary, the poles of psys  must not have moduli within the interval [1-β,1+β], where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nThe computation of the L∞ norm is based on the algorithm proposed in [1].  The involved computations of characteristic multipliers are performed either with the fast reduction method of [2],  if fast = true or if time-varying dimensions are present,  or the generalized periodic Schur decomposition based method of [3], if fast = false.  \n\nReferences\n\n[1] A. Varga. \"Computation of L∞-norm of linear discrete-time periodic systems.\" Proc. MTNS, Kyoto, 2007.\n\n[2] A. Varga and P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems & Control Letters 50:371–381, 2003.\n\n[3] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\npslinfnorm(psys, K = 100; hinfnorm = false, rtolinf = 0.001, offset = sqrt(ϵ), reltol, abstol, dt) -> (linfnorm, fpeak)\npshinfnorm(psys, K = 100; rtolinf = 0.001, offset = sqrt(ϵ), reltol, abstol, dt) -> (linfnorm, fpeak)\n\nCompute for a continuous-time periodic system psys = (A(t),B(t),C(t),D(t) the L∞ norm linfnorm with pslinfnorm or the  H∞ norm hinfnorm with pshinfnorm as defined in [1].  If hinfnorm = true, the H∞ norm is computed with pslinfnorm. The corresponding peak frequency fpeak, where the peak gain is achieved, is usually not determined, excepting in some limiting cases.    The L∞ norm is infinite if psys has poles on the imaginary axis. \n\nTo check the lack of poles on the imaginary axis, the characteristic exponents of A(t)  must not have real parts in the interval [-β,β], where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nA bisection based algorith, as described in [2], is employed to approximate the L∞ norm, and the keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nIf hinfnorm = true, the H∞ norm is computed.  In this case, the stability of the system is additionally checked and  the H∞ norm is infinite for an unstable system. To check the stability, the characteristic exponents of A(t) must have real parts less than -β.\n\nThe ODE solver to be employed to compute the characteristic multipliers of the system Hamiltonian can be specified using the keyword argument solver (default: solver = \"symplectic\")  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and  stepsize dt (default: dt = 0). The value stepsize is relevant only if solver = \"symplectic\", in which case an adaptive stepsize strategy is used ifdt = 0and a fixed stepsize is used ifdt > 0. (see also [tvstm`](@ref)). \n\nReferences:    \n\n[1] P. Colaneri. Continuous-time periodic systems in H2 and H∞: Part I: Theoretical Aspects.     Kybernetika, 36:211-242, 2000. \n\n[2] A. Varga, On solving periodic differential matrix equations with applications to periodic system norms computation.     Proc. CDC/ECC, Seville, p.6545-6550, 2005.  \n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#PeriodicSystems.pstimeresp","page":"Analysis of periodic systems","title":"PeriodicSystems.pstimeresp","text":"pstimeresp(sys, u, t, x0 = zeros(sys.nx); state_history = false, solver, reltol, abstol) -> (y, tout, x)\n\nCompute the time response of a periodic system sys = (A(t),B(t),C(t),D(t)) to the input signals  described by u and t. The time vector t consists of regularly spaced time samples.  The input u can be specified as a matrix with as many columns as the number of inputs of sys,  in which case its i-th row specifies the input values at time t[i].  For a discrete-time system, u should be sampled at the same sampling rate Ts as sys and t must have all time steps equal to Ts or can be set to an empty vector.  For continuous-time models, the input values are interpolated between samples using   zero-order hold based interpolation.  The vector x0 specifies the initial state vector at time t[1] and is set to zero when omitted. \n\nThe matrix y contains the resulting time history of the outputs of sys and  the vector tout contains the corresponding values of the time samples. The i-th row of y contains the output values at time tout[i].   If the keyword parameter value state_history = true is used, then the matrix x contains  the resulting time history of the state vector and its i-th row x[i,:] contains  the state values at time tout[i].  The column dimension of the matrix x is n, the dimension of the state vector.  For a discrete-time periodic system with time-varying state dimensions, n is the maximum value of the  dimensions of the state vector over one period. The components of x[i,:] have trailing zero values if the  corresponding state vector dimension is less than n.   By default, the state history is not saved and x = nothing.\n\nFor a continuous-time model an equivalent discretized model is determined to be used for simulation. The discretization is performed by determining the monodromy matrix as a product of  state transition matrices of the extended state-space matrix [A(t) B(t); 0 0]  by integrating numerically the corresponding homogeneous linear ODE.   The ODE solver to be employed can be  specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-4),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt = Ts/10) (see tvstm).  For large numbers of product terms, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable. \n\n\n\n\n\npstimeresp(sys, u, t, x0 = zeros(sys.nx); state_history = false, solver, reltol, abstol) -> (y, tout, x)\n\nCompute the time response of a continuous-time periodic system sys = (A(t),B(t),C(t),D(t)) to the input signals  described by u and t. The time vector t consists of regularly spaced time samples.  The input u is specified as a vector of time dependent signals  with as many components as the number of inputs of sys.  The vector x0 specifies the initial state vector at time t[1] and is set to zero when omitted. \n\nThe matrix y contains the resulting time history of the outputs of sys and  the vector tout contains the corresponding values of the time samples. The i-th row of y contains the output values at time tout[i].   If the keyword parameter value state_history = true is used, then the matrix x contains  the resulting time history of the state vector and its i-th row contains  the state values at time tout[i]. By default, the state history is not computed and x = nothing.\n\nThe ODE solver to be employed can be  specified using the keyword argument solver (see below), together with the required relative accuracy reltol (default: reltol = 1.e-4),  absolute accuracy abstol (default: abstol = 1.e-7) and  the fixed step length dt (default: dt = 0), only used if solver = \"symplectic\".  Depending on the desired relative accuracy reltol,  lower order solvers are employed for reltol >= 1.e-4,  which are generally very efficient, but less accurate. If reltol < 1.e-4, higher order solvers are employed able to cope with high accuracy demands. \n\nThe following solvers from the OrdinaryDiffEq.jl package can be selected:\n\nsolver = \"non-stiff\" - use a solver for non-stiff problems (Tsit5() or Vern9());\n\nsolver = \"stiff\" - use a solver for stiff problems (Rodas4() or KenCarp58());\n\nsolver = \"symplectic\" - use a symplectic Hamiltonian structure preserving solver (IRKGL16());\n\nsolver = \"\" - use the default solver, which automatically detects stiff problems (AutoTsit5(Rosenbrock23()) or AutoVern9(Rodas5())). \n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#PeriodicSystems.psstepresp","page":"Analysis of periodic systems","title":"PeriodicSystems.psstepresp","text":"psstepresp(sys[, tfinal]; ustep = ones(psys.nu), x0 = zeros(psys.nx), timesteps = 100, \n         state_history = false, abstol, reltol) -> (y, tout, x)\n\nCompute the time response of a periodic system sys = (A(t),B(t),C(t),D(t)) to step input signals.  The final time tfinal, if not specified, is set equal to the period of the periodic system sys. For a discrete-time system, the final time tfinal must be commensurate with the system sampling time Ts (otherwise it is adjusted to the nearest smaller commensurate value).  The keyword argument ustep is a vector with as many components  as the inputs of sys and specifies the desired amplitudes of step inputs (default: all components are set to 1).    The keyword argument x0 is a vector, which specifies the initial state vector at time 0,  and is set to zero when omitted.  The keyword argument timesteps specifies the number of desired simulation time steps  (default: timesteps = 100). \n\nIf ns is the total number of simulation values, n the number of state components,  p the number of system outputs and m the number of system inputs, then the resulting ns×p×m array y contains the resulting time histories of the outputs of sys, such  that y[:,:,j] is the time response for the j-th input set to ustep[j] and the rest of inputs set to zero.   The vector tout contains the corresponding values of the time samples. The i-th row y[i,:,j] contains the output values at time tout[i] of the j-th step response.   If the keyword parameter value state_history = true is used, then the resulting ns×n×m arrayx contains  the resulting time histories of the state vector and  the i-th row x[i,:,j] contains the state values at time tout[i] of the j-th step response.   For a discrete-time periodic system with time-varying state dimensions, n is the maximum value of the  dimensions of the state vector over one period. The components of x[i,:,j] have trailing zero values if the  corresponding state vector dimension is less than n.   By default, the state history is not saved and x = nothing.\n\nThe total number of simulation values ns is set as follows: for a continuous-time system ns = timesteps+1  and for a discrete-time system ns = min(timesteps,tfinal/Ts)+1. \n\nFor a continuous-time model an equivalent discretized model is determined to be used for simulation, provided the time step Δ = tfinal/timesteps is commensurate with the system period T and tfinal >= T.  The discretization is performed by determining the monodromy matrix as a product of  state transition matrices of the extended state-space matrix [A(t) B(t); 0 0]  by integrating numerically the corresponding homogeneous linear ODE.   If the time step Δ is not commensurate with the period T or tfinal < T, then numerical integrations of the underlying ODE systems are performed.  The ODE solver to be employed can be  specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-4),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt = Ts/10) (see tvstm).  For large numbers of product terms, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable. \n\n\n\n\n\n","category":"function"},{"location":"psanalysis.html#PeriodicSystems.pseval","page":"Analysis of periodic systems","title":"PeriodicSystems.pseval","text":"pseval(psys, val) -> Gval\n\nEvaluate for a finite λ = val, the value Gval of the transfer function matrix G(λ) of the  lifted system of the discrete-time periodic system psys.  val must not be a pole of psys.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#Periodic-Schur-decompositions","page":"Periodic Schur decompositions","title":"Periodic Schur decompositions","text":"","category":"section"},{"location":"pschur.html","page":"Periodic Schur decompositions","title":"Periodic Schur decompositions","text":"phess  Periodic Hessenberg decomposition of a product of matrices.\nphess!  Periodic Hessenberg decomposition of a product of matrices (in place computation).\npschur  Periodic Schur decompositions of products or quotient products of matrices. \npschur!  Periodic Schur decompositions of products of matrices (in place computation). \npsordschur!  Reordering of periodic Schur decompositions of products or quotient products of matrices.\npsordschur1!  Reordering of periodic Schur decompositions of products or quotient products of square matrices.\npgschur  Generalized real periodic Schur decomposition of a formal product of matrices.\npgschur!  Generalized real periodic Schur decompositions of formal products of matrices (in place computation).\npgordschur!  Reordering of generalized real periodic Schur decompositions a formal products of matrices.","category":"page"},{"location":"pschur.html","page":"Periodic Schur decompositions","title":"Periodic Schur decompositions","text":"phess\nphess!\npschur\npschur!\npsordschur!\npsordschur1!\npgschur\npgschur!\npgordschur!","category":"page"},{"location":"pschur.html#PeriodicSystems.phess","page":"Periodic Schur decompositions","title":"PeriodicSystems.phess","text":" phess(A::Array{Float64,3}; hind = 1, rev = true, withZ = true) -> (H, Z, ihess)\n phess1(A::Array{Float64,3}; hind = 1, rev = true, withZ = true) -> (H, Z, ihess)\n\nCompute the Hessenberg decomposition of a product of square matrices  A(p)*...*A(2)*A(1), if rev = true (default) or A(1)*A(2)*...*A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix A(i) is contained in A[:,:,i]. The resulting n×n×p arrays H and Z contain the matrices H(1), ..., H(p) and the orthogonal matrices Z(1), ..., Z(p), respectively,  such that for rev = true\n\n       Z(2)' * A(1) * Z(1) = H(1),\n       Z(3)' * A(2) * Z(2) = H(2),\n              ...\n       Z(1)' * A(p) * Z(p) = H(p),\n\nand for rev = false\n\n       Z(1)' * A(1) * Z(2) = H(1),\n       Z(2)' * A(2) * Z(3) = H(2),\n              ...\n       Z(p)' * A(p) * Z(1) = H(p).\n\nIf hind = ihess, with 1 ≤ ihess ≤ p (default ihess = 1), then  H(i), i = 1, ..., p are in a periodic Hessenberg form,  with H(ihess) in upper Hessenberg form and H(i)  upper triangular for i neq ihess.  H(i) and Z(i) are contained in H[:,:,i] and Z[:,:,i], respectively.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe function phess is based on a wrapper for the SLICOT subroutine MB03VW    (see PeriodicSystems.SLICOTtools.mb03vw!).\n\nThe function phess1 is based on wrappers for the SLICOT subroutines MB03VD   (see PeriodicSystems.SLICOTtools.mb03vd!) and MB03VY  (see PeriodicSystems.SLICOTtools.mb03vy!).\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.phess!","page":"Periodic Schur decompositions","title":"PeriodicSystems.phess!","text":" phess!(A::Array{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); kwargs...) -> (H, Z, ihess)\n\nSame as phess(A; kwargs...) but uses the input matrix A as workspace and specifies a range ilh = (ilo, ihi), such that all matrices A(j), j = 1, ..., p, are already in periodic Hessenberg forms in rows and columns 1:ilo-1 and ihi+1:n, where n is the first dimension of A.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.pschur","page":"Periodic Schur decompositions","title":"PeriodicSystems.pschur","text":" pschur(A::Array{Float64,3}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n pschur1(A::Array{Float64,3}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n pschur2(A::Array{Float64,3}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the Schur decomposition of a product of square matrices  A(p)*...*A(2)*A(1), if rev = true (default) or A(1)*A(2)*...*A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix A(i) is contained in A[:,:,i]. The resulting n×n×p arrays S and Z contain the matrices S(1), ..., S(p) and the orthogonal matrices Z(1), ..., Z(p), respectively,  such that for rev = true\n\n       Z(2)' * A(1) * Z(1) = S(1),\n       Z(3)' * A(2) * Z(2) = S(2),\n              ...\n       Z(1)' * A(p) * Z(p) = S(p),\n\nand for rev = false\n\n       Z(1)' * A(1) * Z(2) = S(1),\n       Z(2)' * A(2) * Z(3) = S(2),\n              ...\n       Z(p)' * A(p) * Z(1) = S(p).\n\nIf sind = ischur, with 1 ≤ ischur ≤ p (default ischur = 1), then  S(i), for i = 1, ..., p are in a periodic Schur form,  with S(ischur) in quasi-upper triangular (or Schur) form and S(i)  upper triangular for i neq ischur.  S(i) and Z(i) are contained in S[:,:,i] and Z[:,:,i], respectively.  The vector ev contains the eigenvalues of the appropriate matrix product.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW   (see PeriodicSystems.SLICOTtools.mb03vw!) and MB03BD  (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nThe function pschur1 is based on wrappers for the SLICOT subroutines MB03VD  (see PeriodicSystems.SLICOTtools.mb03vd!),  MB03VY  (see PeriodicSystems.SLICOTtools.mb03vy!)  and MB03BD  (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nThe function pschur2 is based on wrappers for the SLICOT subroutines MB03VD  (see PeriodicSystems.SLICOTtools.mb03vd!),  MB03VY  (see PeriodicSystems.SLICOTtools.mb03vy!) and MB03VW  (see PeriodicSystems.SLICOTtools.mb03vw!),  based on the algorithm proposed in [1]. Known issue: MB03VW may fails for larger periods. \n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pschur(A::Vector{Matrix{T}}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n pschur1(A::Vector{Matrix{T}}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the extended periodic Schur decomposition of a square product of matrices  A(p)*...*A(2)*A(1), if rev = true (default) or A(1)*A(2)*...*A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the p-vector of matrices A  such that the i-th matrix  A(i), of dimensions m(i)×n(i), is contained in A[i]. The resulting p-vectors S and Z contain the matrices S(1), ..., S(p) and the orthogonal matrices Z(1), ..., Z(p), respectively,  such that for rev = true\n\n       Z(2)' * A(1) * Z(1) = S(1),\n       Z(3)' * A(2) * Z(2) = S(2),\n              ...\n       Z(1)' * A(p) * Z(p) = S(p),\n\nand for rev = false\n\n       Z(1)' * A(1) * Z(2) = S(1),\n       Z(2)' * A(2) * Z(3) = S(2),\n              ...\n       Z(p)' * A(p) * Z(1) = S(p).\n\nThe resulting index ischur is determined such that m(ischur) ≤ m(i), ∀i. The resulting S(i), for i = 1, ..., p are in an extended  periodic Schur form,  with S(ischur) in a quasi-upper trapezoidal form and S(i)  upper trapezoidal for i neq ischur.  S(i) and Z(i) are contained in S[i] and Z[i], respectively.  The first nmin components of ev := α .* γ contain the core eigenvalues of the appropriate matrix product, where nmin = m(ischur), while the last nmax-nmin components of ev are zero,  where nmax is the largest row or column dimension of A(i), for i = 1, ..., p.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW (see PeriodicSystems.SLICOTtools.mb03vw!)  and MB03BD (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nThe function pschur1 is based on wrappers for the SLICOT subroutines MB03VD (see PeriodicSystems.SLICOTtools.mb03vd!),  MB03VY (see PeriodicSystems.SLICOTtools.mb03vy!),  and MB03BD (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pschur(A::AbstractArray{T,3}, E::AbstractArray{T,3}; rev = true, withZ = true) -> (S, T, Q, Z, ev, ischur, α, γ)\n\nCompute the periodic Schur decomposition of a square formal quotient product of matrices  inv(E(p))*A(p)*...*inv(E(2))*A(2)*inv(E(1))*A(1), if rev = true (default) or  A(1)*inv(E(1))*A(2)*inv(E(2))*...*A(p)*inv(E(p)) if rev = false, without evaluating the product and the inverses.  The matrices A(1), ..., A(p) are contained in the n×n×p-array A  such that the i-th matrix  A(i) is contained in A[:,:,i]. The square matrices E(1), ..., E(p) are contained in the n×n×p-array E  such that the i-th matrix  E(i) is contained in E[:,:,i].\n\nThe resulting n×n×p-arrays S, T, Q and Z contain, respectively,  the matrices S(1), ..., S(p) with S(ischur) in a quasi-upper trapezoidal form and  S(i) upper trapezoidal for i neq ischur, the upper triangular matrices T(1), ..., T(p),  the orthogonal matrices Q(1), ..., Q(p), and Z(1), ..., Z(p),  such that for rev = true\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(1)' * E(1) * Z(2) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(2)' * E(2) * Z(3) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(p)' * E(p) * Z(1) = T(p),\n\nand for rev = false\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(2)' * E(1) * Z(1) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(3)' * E(2) * Z(2) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(1)' * E(p) * Z(p) = T(p),\n\nThe complex vector ev contains the eigenvalues of the appropriate matrix product, and can be alternatively expressed as ev := α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case  Q = nothing and Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW (see PeriodicSystems.SLICOTtools.mb03vw!)  and MB03BD (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pschur(A::Vector{Matrix{T}}, E::Vector{Matrix{T}}; rev = true, withZ = true) -> (S, T, Q, Z, ev, ischur, α, γ)\n\nCompute the extended periodic Schur decomposition of a square formal product of matrices  inv(E(p))*A(p)*...*inv(E(2))*A(2)*inv(E(1))*A(1), if rev = true (default) or  A(1)*inv(E(1))*A(2)*inv(E(2))*...*A(p)*inv(E(p)) if rev = false, without evaluating the product and the inverses.  The matrices A(1), ..., A(p) are contained in the p-vector of matrices A  such that the i-th matrix  A(i), of dimensions m(i)×n(i), is contained in A[i]. The square matrices E(1), ..., E(p) are contained in the p-vector of matrices E  such that the i-th matrix  E(i), of dimensions m(i)×m(i) if rev = true or n(i)×n(i) if rev = false,  is contained in E[i].\n\nThe resulting index ischur is determined such that m(ischur) ≤ m(i), ∀i. The resulting p-vectors S, T, Q and Z contain, respectively,  the matrices S(1), ..., S(p) with S(ischur) in a quasi-upper trapezoidal form and  S(i) upper trapezoidal for i neq ischur, the upper triangular matrices T(1), ..., T(p),  the orthogonal matrices Q(1), ..., Q(p), and Z(1), ..., Z(p),  such that for rev = true\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(1)' * E(1) * Z(2) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(2)' * E(2) * Z(3) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(p)' * E(p) * Z(1) = T(p),\n\nand for rev = false\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(2)' * E(1) * Z(1) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(3)' * E(2) * Z(2) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(1)' * E(p) * Z(p) = T(p),\n\nThe first nmin components of ev := α .* γ contain the core eigenvalues of the appropriate matrix product, where nmin = m(ischur), while the last nmax-nmin components of ev are zero,  where nmax is the largest row or column dimension of A(i), for i = 1, ..., p.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case  Q = nothing and Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW (see PeriodicSystems.SLICOTtools.mb03vw!)  and MB03BD (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.pschur!","page":"Periodic Schur decompositions","title":"PeriodicSystems.pschur!","text":" pschur!(A::Array{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); kwargs...) -> (S, Z, ihess)\n\nSame as pschur(A; kwargs...) but uses the input matrix A as workspace and specifies a range ilh = (ilo, ihi), such that all matrices A(j), j = 1, ..., p, are already in periodic Schur forms in rows and columns 1:ilo-1 and ihi+1:n, where n is the first dimension of A.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.psordschur!","page":"Periodic Schur decompositions","title":"PeriodicSystems.psordschur!","text":" psordschur!(S::Vector{Matrix{Float64}}, Z::Vector{Matrix{Float64}}, select; rev, schurindex)\n\nReorder the core eigenvalues of the product Π = S[p]*...*S[2]*S[1], if rev = true (default) or Π = S[1]*S[2]*...*S[p] if rev = false, where Π is in real Schur form, such that the selected eigenvalues in the logical array select are moved into the leading positions.  The p-vectors S and Z contain the matrices S[1], ..., S[p] in an extended periodic Schur form, with the leading square block of  S[schurindex] in real Schur form, and the corresponding orthogonal transformation matrices Z[1], ..., Z[p], respectively.  S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.  The dimension of select must be equal to the number of core eigenvalues (i.e., the minimum dimension of matrices in the vector S).  \n\n\n\n\n\n psordschur!(S::Array{Float64,3}, Z::Array{Float64,3}, select::Union{Vector{Bool},BitVector}; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[:,:,p]*...*S[:,:,2]*S[:,:,1], if rev = true (default) or Π = S[:,:,1]*S[:,:,2]*...*S[:,:,p] if rev = false, where Π is in real Schur form, such that the selected eigenvalues in the logical array select are moved into the leading positions.  The 3-dimensional arrays S and Z contain the matrices S[:,:,1], ..., S[:,:,p] in a periodic Schur form, with S[:,:,schurindex] in real Schur form,  and the corresponding orthogonal transformation matrices Z[:,:,1], ..., Z[:,:,p], respectively.  S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.psordschur1!","page":"Periodic Schur decompositions","title":"PeriodicSystems.psordschur1!","text":" psordschur1!(S::Vector{Matrix{Float64}}, Z::Vector{Matrix{Float64}}, select; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[p]*...*S[2]*S[1], if rev = true (default) or Π = S[1]*S[2]*...*S[p] if rev = false, where Π is in real Schur form, such that the selected eigenvalues in the logical array select are moved into the leading positions.  The p-vectors S and Z contain, respectively, the square matrices S[1], ..., S[p] in a periodic Schur form, with S[schurindex in real Schur form,  and the corresponding orthogonal transformation matrices Z[1], ..., Z[p], respectively.  S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.pgschur","page":"Periodic Schur decompositions","title":"PeriodicSystems.pgschur","text":" pgschur(A::Vector{Matrix}, s::Union{Vector{Bool},BitVector}; rev = true, withQ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the generalized real periodic Schur decomposition of a formal product of square matrices  A(p)^s(p)*...A(2)^s(2)*A(1)^s(1), if rev = true (default), or  A(1)^s(1)*A(2)^s(2)*...*A(p)^s(p), if rev = false, where 's(j) = ±1'.  The matrices A(1), A(2), ..., A(p) are contained in the p-dimensional array A  such that the i-th matrix  A(i) is contained in A[i]. \n\nThe resulting p-dimensional array S contains the matrices S(1), ..., S(p)  such that the i-th matrix S(i) is contained in S[i].  The component matrix S[ischur] is in a quasi-upper triangular form, while S[i] is upper triangular for i neq ischur.  If withZ = true (default), the resulting p-dimensional array Z contains the orthogonal transformation  matrices Z(1), ..., Z(p) such that the i-th matrix Z(i) is contained in Z[i].  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe resulting matrices satisfy for rev = true\n\n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = true, \n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = false,\n\nand for rev = false\n\n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = true, \n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = false.\n\nThe vector ev contains the eigenvalues of the appropriate matrix product.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues. \n\nThe function pgschur is based on wrappers for the SLICOT subroutines MB03VW   (see PeriodicSystems.SLICOTtools.mb03vw!) and MB03BD  (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pgschur(A::Array{Float64,3}, s::Union{Vector{Bool},BitVector}; rev = true, withQ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the generalized real periodic Schur decomposition of a formal product of square matrices  A(p)^s(p)*...A(2)^s(2)*A(1)^s(1), if rev = true (default), or  A(1)^s(1)*A(2)^s(2)*...*A(p)^s(p), if rev = false, where 's(j) = ±1'.  The matrices A(1), A(2), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix  A(i) is contained in A[:,:,i]. \n\nThe resulting n×n×p array S contains the matrices S(1), ..., S(p)  such that S(ischur) is in a quasi-upper triangular form,  S(i) is upper triangular for i neq ischur.  If withZ = true (default), the resulting n×n×p array Z contains the orthogonal transformation  matrices Z(1), ..., Z(p). The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe resulting matrices satisfy for rev = true\n\n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = true, \n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = false,\n\nand for rev = false\n\n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = true, \n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = false.\n\nS(i) and Z(i) are contained in S[:,:,i] and Z[:,:,i], respectively.  The vector ev contains the eigenvalues of the appropriate matrix product.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues. \n\nThe function pgschur is based on wrappers for the SLICOT subroutines MB03VW   (see PeriodicSystems.SLICOTtools.mb03vw!) and MB03BD  (see PeriodicSystems.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.pgschur!","page":"Periodic Schur decompositions","title":"PeriodicSystems.pgschur!","text":"pgschur!(A::Array{Float64,3}, S::Union{Vector{Bool},BitVector}; kwargs...)\n\nSame as pgschur but uses the input matrix A as workspace.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicSystems.pgordschur!","page":"Periodic Schur decompositions","title":"PeriodicSystems.pgordschur!","text":" pgordschur!(S::Array{Float64,3}, s::Union{Vector{Bool},BitVector}, Z::Array{Float64,3}, select::Union{Vector{Bool},BitVector}; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[:,:,p]^s[p]*...*S[:,:,2]^s[2]*S[:,:,1]^s[1], if rev = true (default) or  Π = S[:,:,1]^s[1]*S[:,:,2]^s[2]*...*S[:,:,p]^s[p] if rev = false, with 's[j] = ±1', where Π is in a real Schur form,  such that the selected eigenvalues in the logical array select are moved into the leading positions.  The 3-dimensional arrays S and Z contain the matrices S[:,:,1], ..., S[:,:,p] in a generalized periodic Schur form,  with S[:,:,schurindex] in a quasi-upper triangular (real Schur) form,  and the corresponding orthogonal transformation matrices Z[:,:,1], ..., Z[:,:,p], respectively.   S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n pgordschur!(S::Vector{Matrix{Float64}}, s::Union{Vector{Bool},BitVector}, Z::Vector{Matrix{Float64}}, select::Union{Vector{Bool},BitVector}; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[p]^s[p]*...*S[2]^s[2]*S[1]^s[1], if rev = true (default) or  Π = S[1]^s[1]*S[2]^s[2]*...*S[p]^s[p] if rev = false, with 's[j] = ±1', where Π is in a real Schur form,  such that the selected eigenvalues in the logical array select are moved into the leading positions.  The p-vectors S and Z contain the matrices S[1], ..., S[p] in a generalized periodic Schur form,  with S[schurindex] in a quasi-upper triangular (real Schur) form,  and the corresponding orthogonal transformation matrices Z[1], ..., Z[p], respectively.   S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n","category":"function"},{"location":"psric.html#Periodic-Riccati-equation-solvers","page":"Periodic Riccati equation solvers","title":"Periodic Riccati equation solvers","text":"","category":"section"},{"location":"psric.html","page":"Periodic Riccati equation solvers","title":"Periodic Riccati equation solvers","text":"pcric Solution of periodic Riccati differential equations. \npgcric Computation of periodic generators for periodic Riccati differential equations.\ntvcric_eval Evaluation of time value of solution from the computed periodic generator.\nprcric Solution of control-related reverse-time periodic Riccati differential equation. \npfcric  Solution of filtering-related forward-time periodic Riccati differential equation.\nprdric Solution of control-related reverse-time periodic Riccati difference equation. \npfdric Solution of filtering-related forward-time periodic Riccati difference equation. ","category":"page"},{"location":"psric.html","page":"Periodic Riccati equation solvers","title":"Periodic Riccati equation solvers","text":"pcric\npgcric\ntvcric_eval\nprcric\npfcric\nprdric\npfdric","category":"page"},{"location":"psric.html#PeriodicSystems.pcric","page":"Periodic Riccati equation solvers","title":"PeriodicSystems.pcric","text":"pcric(A, R, Q; K = 10, adj = false, solver, reltol, abstol, fast, intpol, intpolmeth) -> (X, EVALS)\n\nSolve the periodic Riccati differential equation\n\n.                                                 \nX(t) = A(t)X(t) + X(t)A(t)' + Q(t) - X(t)R(t)X(t) ,  if adj = false,\n\nor \n\n .                                                \n-X(t) = A(t)'X(t) + X(t)A(t) + Q(t) - X(t)R(t)X(t) , if adj = true\n\nand compute the stable closed-loop characteristic multipliers in EVALS (see pgcric for details).\n\nThe periodic matrices A, R and Q must have the same type, the same dimensions and commensurate periods,  and additionally R and Q must be symmetric. The resulting symmetric periodic solution X has the type PeriodicFunctionMatrix and  X(t) can be used to evaluate the value of X at time t.  X has the period set to the least common commensurate period of A, R and Q and  the number of subperiods is adjusted accordingly.  Note: Presently the PeriodicSwitchingMatrix type is not supported. \n\nIf fast = true (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in t = 0 and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If fast = false, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). \n\nThe keyword argument K specifies the number of grid points to be used for the resulting multiple point periodic generator (default: K = 10).  The obtained periodic generator is finally converted into a periodic function matrix which determines for a given t  the function value X(t) by integrating the appropriate ODE from the nearest grid point value. \n\nTo speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument intpol = true (default: intpol = true if solver = \"symplectic\", otherwise intpol = false).  In this case the interpolation method to be used can be specified via the keyword argument intpolmeth = meth. The allowable values for meth are: \"constant\", \"linear\", \"quadratic\" and \"cubic\" (default) (see also ts2pfm).\n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-4) and  absolute accuracy abstol (default: abstol = 1.e-7) (see tvstm).  For large values of K, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    \n\n\n\n\n\n","category":"function"},{"location":"psric.html#PeriodicSystems.pgcric","page":"Periodic Riccati equation solvers","title":"PeriodicSystems.pgcric","text":"pgcric(A, R, Q[, K = 1]; adj = false, solver, reltol, abstol, fast, PSD_SLICOT) -> (X, EVALS)\n\nCompute periodic generators for the periodic Riccati differential equation in the filtering form\n\n.                                                  \nX(t) = A(t)X(t) + X(t)A(t)' + Q(t) - X(t)R(t)X(t), if adj = false,\n\nor in the control form\n\n .                                              \n-X(t) = A(t)'X(t) + X(t)A(t) + Q(t) - X(t)R(t)X(t) , if adj = true,\n\nwhere A(t), R(t) and Q(t) are periodic matrices of commensurate periods,  with A(t) square, R(t) symmetric and positive definite, and Q(t) symmetric and positive semidefinite.  The resulting X is a collection of periodic generator matrices determined  as a periodic time-series matrix with N components, where N = 1 if A(t), R(t) and Q(t) are constant matrices and N = K otherwise.  EVALS contains the stable characteristic multipliers of the monodromy matrix of  the corresponding Hamiltonian matrix (also called closed-loop characteristic multipliers). The period of X is set to the least common commensurate period of A(t), R(t) and Q(t) and the number of subperiods is adjusted accordingly.  Any component matrix of X is a valid initial value to be used to generate the   solution over a full period by integrating the appropriate differential equation. \n\nIf fast = true (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in t = 0 and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If fast = false, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-4) and  absolute accuracy abstol (default: abstol = 1.e-7) (see tvstm).  For large values of K, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    \n\n\n\n\n\n","category":"function"},{"location":"psric.html#PeriodicSystems.tvcric_eval","page":"Periodic Riccati equation solvers","title":"PeriodicSystems.tvcric_eval","text":"tvcric_eval(t, W, A, R, Q; adj, solver, reltol, abstol, dt) -> Xval\n\nCompute the time value Xval := X(t) of the solution of the periodic Riccati differential equation\n\n  .                                                \n  X(t) = A(t)X(t) + X(t)A(t)' + Q(t) - X(t)R(t)X(t) ,  X(t0) = W(t0), t0 < t, if adj = false (default),\n\nor \n\n  .                                                \n -X(t) = A(t)'X(t) + X(t)A(t) + Q(t) - X(t)R(t)X(t) ,  X(t0) = W(t0), t0 > t, if adj = true,\n\nusing the periodic generator W determined with the function pgcric for the same periodic matrices A, R and Q and the same value of the keyword argument adj.  The initial time t0 is the nearest time grid value to t, from below, if adj = false, or from above, if adj = true.  The resulting Xval is a symmetric matrix. \n\nThe ODE solver to be employed can be specified using the keyword argument solver (see tvstm),  (default: solver = \"symplectic\") together with the required relative accuracy reltol (default: reltol = 1.e-4),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt =  min(A.period/A.nperiod/100,tf-t0)).  Depending on the desired relative accuracy reltol,  lower order solvers are employed for reltol >= 1.e-4,  which are generally very efficient, but less accurate. If reltol < 1.e-4, higher order solvers are employed able to cope with high accuracy demands. \n\n\n\n\n\n","category":"function"},{"location":"psric.html#PeriodicSystems.prcric","page":"Periodic Riccati equation solvers","title":"PeriodicSystems.prcric","text":"prcric(A, B, R, Q; K = 10, solver, intpol, intpolmeth, reltol, abstol, fast) -> (X, EVALS, F)\n\nCompute the symmetric stabilizing solution X(t) of the periodic control related Riccati differential equation\n\n .                                                -1 \n-X(t) = A(t)'X(t) + X(t)A(t) + Q(t) - X(t)B(t)R(t)  B(t)'X(t) ,\n\nthe periodic stabilizing state-feedback gain \n\n           -1\nF(t) = R(t)  B(t)'X(t)\n\nand the corresponding stable characteristic multipliers EVALS of A(t)-B(t)F(t). \n\nThe periodic matrices A, B, R and Q must have the same type and commensurate periods,  and additionally R must be symmetric positive definite and Q must be symmetric positive semidefinite.  The resulting symmetric periodic solution X has the period  set to the least common commensurate period of A, B, R and Q and the number of subperiods is adjusted accordingly. \n\nIf fast = true (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in t = 0 and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If fast = false, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). \n\nThe keyword argument K specifies the number of grid points to be used for the resulting multiple point periodic generator (default: K = 10).  The obtained periodic generator is finally converted into a periodic function matrix which determines for a given t  the function value X(t) by integrating the appropriate ODE from the nearest grid point value. \n\nTo speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument intpol = true (default: intpol = true if solver = \"symplectic\", otherwise intpol = false).  In this case the interpolation method to be used can be specified via the keyword argument intpolmeth = meth. The allowable values for meth are: \"constant\", \"linear\", \"quadratic\" and \"cubic\" (default) (see also ts2pfm).\n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-4) and  absolute accuracy abstol (default: abstol = 1.e-7) (see tvstm).  For large values of K, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    \n\n\n\n\n\n","category":"function"},{"location":"psric.html#PeriodicSystems.pfcric","page":"Periodic Riccati equation solvers","title":"PeriodicSystems.pfcric","text":"pfcric(A, C, R, Q; K = 10, solver, intpol, intpolmeth, reltol, abstol, fast) -> (X, EVALS, F)\n\nCompute the symmetric stabilizing solution X(t) of the periodic filtering related Riccati differential equation\n\n.                                                 -1 \nX(t) = A(t)X(t) + X(t)A(t)' + Q(t) - X(t)C(t)'R(t)  C(t)X(t) ,\n\nthe periodic stabilizing Kalman gain \n\n                    -1\nF(t) = X(t)C(t)'R(t)\n\nand the corresponding stable characteristic multipliers EVALS of A(t)-F(t)C(t). \n\nThe periodic matrices A, C, R and Q must have the same type and commensurate periods,  and additionally R must be symmetric positive definite and Q must be symmetric positive semidefinite.  The resulting symmetric periodic solution X has the period  set to the least common commensurate period of A, C, R and Q and the number of subperiods is adjusted accordingly. \n\nIf fast = true (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in t = 0 and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If fast = false, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). \n\nThe keyword argument K specifies the number of grid points to be used for the resulting multiple point periodic generator (default: K = 10).  The obtained periodic generator is finally converted into a periodic function matrix which determines for a given t  the function value X(t) by integrating the appropriate ODE from the nearest grid point value. \n\nTo speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument intpol = true (default: intpol = true if solver = \"symplectic\", otherwise intpol = false).  In this case the interpolation method to be used can be specified via the keyword argument intpolmeth = meth. The allowable values for meth are: \"constant\", \"linear\", \"quadratic\" and \"cubic\" (default) (see also ts2pfm).\n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-4) and  absolute accuracy abstol (default: abstol = 1.e-7) (see tvstm).  For large values of K, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    \n\n\n\n\n\n","category":"function"},{"location":"psric.html#PeriodicSystems.prdric","page":"Periodic Riccati equation solvers","title":"PeriodicSystems.prdric","text":" prdric(A, B, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -> (X, EVALS, F)\n\nSolve the periodic Riccati difference equation\n\n  X(i) = Q(i) + A(i)'X(i+1)A(i) - (A(i)'X(i+1)B(i) + S(i))*\n                                 -1\n         (B(i)'X(i+1)B(i) + R(i))  (A(i)'X(i+1)B(i) + S(i))'\n\nand compute the stabilizing periodic state feedback\n\n                                  -1\n  F(i) = -(B(i)'X(i+1)B(i) + R(i))  (B(i)'X(i+1)A(i) + S(i)')\n\nand the corresponding stable closed-loop characteristic multipliers of A(i)-B(i)F(i) in EVALS. \n\nThe n×n and n×m periodic matrices A(i) and B(i) are contained in the  PeriodicArray objects A and B, and must have the same sampling time.  R(i), Q(i) and S(i) are m×m, n×n and n×m periodic matrices of same sampling times  as  A and B, and such that R(i) and Q(i) are symmetric. R(i), Q(i) and S(i) are contained in the  PeriodicArray objects R, Q and S.  R, Q and S can be alternatively provided as constant real matrices.  The resulting symmetric periodic solution X and periodic state feedback gain F have the period  set to the least common commensurate period of A, B, R and Q and the number of subperiods is adjusted accordingly. \n\nIf fast = true, the fast structure exploiting pencil reduction based method of [1] is used to determine a periodic generator in X(1), which allows to generate iteratively the solution  over the whole period.   If fast = false (default), the periodic Schur decomposition based approach of [1] is employed, applied to a  symplectic pair of periodic matrices. If nodeflate = false (default), the underlying periodic pencil  is preprocessed to eliminate (deflate) the infinite characteristic multipliers originating  from the problem structure. If nodeflate = true, no preliminary deflation is performed.\n\nAn iterative refining of the accuracy of the computed solution  can be performed by using itmax = k, with k > 0 (default: k = 0). \n\nTo detect singularities of involved matrices, the keyword parameter rtol = tol can be used to   specify the lower bound for the 1-norm reciprocal condition number.  The default value of  tol is n*ϵ, where ϵ is the working machine epsilon.\n\nReferences\n\n[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.\n\n\n\n\n\n prdric(A, B, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -> (X, EVALS, F)\n\nSolve the periodic Riccati difference equation\n\n  X(i) = Q(i) + A(i)'X(i+1)A(i) - (A(i)'X(i+1)B(i) + S(i))*\n                                 -1\n         (B(i)'X(i+1)B(i) + R(i))  (A(i)'X(i+1)B(i) + S(i))'\n\nand compute the stabilizing periodic state feedback\n\n                                  -1\n  F(i) = -(B(i)'X(i+1)B(i) + R(i))  (B(i)'X(i+1)A(i) + S(i)')\n\nand the corresponding stable closed-loop core characteristic multipliers of A(i)-B(i)F(i) in EVALS. \n\nThe n(i+1)×n(i) and n(i+1)×m periodic matrices A(i) and B(i) are contained in the  PeriodicMatrix objects A and B, and must have the same sampling time.  R(i), Q(i) and S(i) are m×m, n(i)×n(i) and n(i)×m periodic matrices of same sampling times  as  A and B, and such that R(i) and Q(i) are symmetric. R(i), Q(i) and S(i) are contained in the  PeriodicMatrix objects R, Q and S.  R, Q and S can be alternatively provided as constant real matrices.  The resulting n(i)×n(i) symmetric periodic solution X(i) and m×n(i) periodic state feedback gain F(i) have the period  set to the least common commensurate period of A, B, R and Q and the number of subperiods is adjusted accordingly. \n\nIf fast = true, the fast structure exploiting pencil reduction based method of [1] is used to determine a periodic generator in X(j), which allows to generate iteratively the solution  over the whole period. The value of j corresponds to the least dimension nc of n(i)  (which is also the number of core characteristic multipliers).  If fast = false (default), the periodic Schur decomposition based approach of [1] is employed, applied to a  symplectic pair of periodic matrices. If nodeflate = false (default), the underlying periodic pencil  is preprocessed to eliminate (deflate) the infinite characteristic multipliers originating  from the problem structure. If nodeflate = true, no preliminary deflation is performed.\n\nAn iterative refining of the accuracy of the computed solution  can be performed by using itmax = k, with k > 0 (default: k = 0). \n\nTo detect singularities of involved matrices, the keyword parameter rtol = tol can be used to   specify the lower bound for the 1-norm reciprocal condition number.  The default value of  tol is n*ϵ, where ϵ is the working machine epsilon and n is the maximum of n(i).\n\nReferences\n\n[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.   \n\n\n\n\n\n","category":"function"},{"location":"psric.html#PeriodicSystems.pfdric","page":"Periodic Riccati equation solvers","title":"PeriodicSystems.pfdric","text":" pfdric(A, C, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -> (X, EVALS, F)\n\nSolve the periodic Riccati difference equation\n\n  X(i+1) = Q(i) + A(i)X(i)A(i)' - (A(i)X(i)C(i)' + S(i))*\n                                 -1\n           (C(i)X(i)C(i)' + R(i))  (A(i)X(i)C(i)' + S(i))'\n\nand compute the stabilizing periodic Kalman gain\n\n                                                       -1\n  F(i) = -(C(i)X(i)A(i)' + S(i)')(C(i)X(i)C(i)' + R(i))\n\nand the corresponding stable Kalman filter characteristic multipliers of A(i)-F(i)C(i) in EVALS. \n\nThe n×n and m×n periodic matrices A(i) and C(i) are contained in the  PeriodicArray objects A and C, and must have the same sampling time.  R(i), Q(i) and S(i) are m×m, n×n and m×n periodic matrices of same sampling times  as  A and C, and such that R(i) and Q(i) are symmetric.  R, Q and S can be alternatively provided as constant real matrices.  The resulting symmetric periodic solution X and Kalman filter gain F have the period  set to the least common commensurate period of A, C, R and Q and the number of subperiods is adjusted accordingly. \n\nThe dual method of [1] is employed (see prdric for the description of keyword parameters).\n\nReferences\n\n[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.\n\n\n\n\n\n pfdric(A, C, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -> (X, EVALS, F)\n\nSolve the periodic Riccati difference equation\n\n  X(i+1) = Q(i) + A(i)X(i)A(i)' - (A(i)X(i)C(i)' + S(i))*\n                                 -1\n           (C(i)X(i)C(i)' + R(i))  (A(i)X(i)C(i)' + S(i))'\n\nand compute the stabilizing periodic Kalman gain\n\n                                                       -1\n  F(i) = -(C(i)X(i)A(i)' + S(i)')(C(i)X(i)C(i)' + R(i))\n\nand the corresponding stable Kalman filter core characteristic multipliers of A(i)-F(i)C(i) in EVALS. \n\nThe n(i+1)×n(i) and m×n(i) periodic matrices A(i) and C(i) are contained in the  PeriodicMatrix objects A and C, and must have the same sampling time.  R(i), Q(i) and S(i) are m×m, n(i)×n(i) and m×n(i) periodic matrices of same sampling times  as  A and C, and such that R(i) and Q(i) are symmetric.  R, Q and S can be alternatively provided as constant real matrices.  The resulting symmetric periodic solution X and Kalman filter gain F have the period  set to the least common commensurate period of A, C, R and Q and the number of subperiods is adjusted accordingly. \n\nThe dual method of [1] is employed (see prdric for the description of keyword parameters).\n\nReferences\n\n[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.   \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#Periodic-system-utilities","page":"Periodic system utilities","title":"Periodic system utilities","text":"","category":"section"},{"location":"pstools.html","page":"Periodic system utilities","title":"Periodic system utilities","text":"pseig   Characteristic multipliers of a periodic matrix.\npsceig   Characteristic exponents of a periodic matrix.\npsceighr   Characteristic exponents of a periodic matrix in Harmonic Array representation.\npsceigfr   Characteristic exponents of a periodic matrix in Fourier Function Matrix representation.\nmonodromy  Monodromy matrix of a linear periodic time-varying system of ODE.\ntvstm  State transition matrix of a linear time-varying system of ODE.\npsreduc_reg  Fast reduction of a lifted regular pencil corresponding to a product of matrices. \ntvmeval  Time response evaluation of a continuous-time periodic matrix. \nhreval  Evaluation of a harmonic array for a numerical or symbolic time value. \nhrchop  Removal of the negligible trailing terms of a harmonic representation. \nhrtrunc  Truncation of a harmonic representation.  \npmaverage  Evaluation of the time averaged matrix of a continuous-time periodic matrix. \npslyapd  Solution of periodic discrete-time Lyapunov equations using periodic Schur decomposition. \npslyapd2  Solution of a pair periodic discrete-time Lyapunov equations using a single periodic Schur decomposition. \npslyapdkr  Solution of periodic discrete-time Lyapunov equations using Kronecker product expansions. \npsplyapd Solution of positve periodic discrete-time Lyapunov equations. ","category":"page"},{"location":"pstools.html","page":"Periodic system utilities","title":"Periodic system utilities","text":"pseig\npsceig\npsceighr\npsceigfr\nmonodromy\ntvstm\npsreduc_reg\ntvmeval\nhreval\nhrchop\nhrtrunc\npmaverage\npslyapd\npslyapd2\npslyapdkr\npsplyapd","category":"page"},{"location":"pstools.html#PeriodicSystems.pseig","page":"Periodic system utilities","title":"PeriodicSystems.pseig","text":" pseig(A, K = 1; lifting = false, solver, reltol, abstol, dt) -> ev\n\nCompute the characteristic multipliers of a continuous-time periodic matrix. \n\nFor the given square periodic matrix A(t) of period T,  the characteristic multipliers ev are the eigenvalues of  the monodromy matrix Ψ = Φ(T,0), where Φ(t,τ) is the state transition matrix satisfying the homogeneous linear ODE \n\ndΦ(t,τ)/dt = A(t)Φ(t,τ),  Φ(τ,τ) = I.\n\nIf lifting = false, Ψ is computed as a product of K state transition matrices  Ψ = Ψ_K*...*Ψ_1 (see monodromy with the associated keyword arguments).  The eigenvalues are computed using the periodic Schur decomposition method of [1].\n\nIf lifting = true, Ψ is (implicitly) expressed as Ψ = inv(N)*M, where M-λN is a regular pencil with N invertible and   the eigenvalues of M-λN are the same as those of the matrix product Ψ := Ψ_K*...*Ψ_1.  An efficient version of the structure exploiting fast reduction method of [2] is employed,  which embeds the determination of transition matrices into the reduction algorithm.  This option may occasionally lead to inaccurate results for large values of K.  A may be a PeriodicFunctionMatrix, or a PeriodicSymbolicMatrix, or a  HarmonicArray or a PeriodicTimeSeriesMatrix.\n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n ev = pseig(A::PeriodicArray; rev = true, fast = false)\n\nCompute the eigenvalues of a product of p square matrices  A(p)...*A(2)*A(1), if rev = true (default) (also called characteristic multipliers) or  of A(1)*A(2)...A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix A(i) is contained in A[:,:,i]. If fast = false (default) then the eigenvalues are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed. This later option may occasionally lead to inaccurate results for large number of matrices. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n ev = pseig(A::PeriodicMatrix[, k = 1]; rev = true, fast = false)\n\nCompute the eigenvalues of a square cyclic product of p matrices  A(k-1)...*A(2)*A(1)*A(p)...*A(k), if rev = true (default) or  A(k)*A(k+1)*...A(p)*A(1)...A(k-1) if rev = false, without evaluating the product.  The argument k specifies the starting index (default: k = 1).  The matrices A(1), ..., A(p) are contained in the p-vector of matrices A  such that the i-th matrix  A(i), of dimensions m(i)×n(i), is contained in A[i]. If fast = false (default) then the eigenvalues are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed.  This later option may occasionally lead to inaccurate results for large number of matrices. \n\nNote: The first nmin components of ev contains the core eigenvalues of the appropriate matrix product, where nmin is the minimum row dimensions of matrices A[i], for i = 1, ..., p,  while the last ncur-nmin components of ev are zero,  where ncur is the column dimension of A[k] if rev = true or  the row dimension of A[k] if rev = false. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.psceig","page":"Periodic system utilities","title":"PeriodicSystems.psceig","text":" psceig(A::PeriodicFunctionMatrix[, K = 1]; lifting = false, solver, reltol, abstol, dt) -> ce\n\nCompute the characteristic exponents of a periodic matrix.\n\nFor a given square continuous-time periodic function matrix A(t) of period T,  the characteristic exponents ce are computed as log.(ev)/T,  where  ev are the characteristic multipliers (i.e., the eigenvalues of the monodromy matrix of A(t)).   For available options see pseig(::PeriodicFunctionMatrix).  For a given square discrete-time periodic matrix A(t) of discrete period N,   the characteristic exponents ce are computed as ev.^-N. \n\n\n\n\n\npsceig(A::AbstractPeriodicArray[, k]; kwargs...) -> ce\n\nCompute the characteristic exponents of a cyclic matrix product of p matrices.\n\nThe characteristic exponents of a product of p matrices are computed as the pth roots of the  characteristic multipliers. These are computed as the eigenvalues of the square  cyclic product of p matrices A(k-1)...*A(2)*A(1)*A(p)...*A(k), if rev = true (default) or  A(k)*A(k+1)*...A(p)*A(1)...A(k-1) if rev = false, without evaluating the product.  The argument k specifies the starting index (default: k = 1).  The matrices A(1), ..., A(p) are contained in the p-vector of matrices A  such that the i-th matrix  A(i), of dimensions m(i)×n(i), is contained in A[i]. The keyword arguments kwargs are those of  pseig(::PeriodicMatrix).  \n\nNote: The first nmin components of ce contains the core characteristic exponents of the appropriate matrix product, where nmin is the minimum row dimensions of matrices A[i], for i = 1, ..., p,  while the last components of ce are zero. \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.psceighr","page":"Periodic system utilities","title":"PeriodicSystems.psceighr","text":"psceighr(Ahr::HarmonicArray[, N]; P, nperiod, shift, atol) -> ce\n\nCompute the characteristic exponents of a continuous-time periodic matrix in Harmonic Array representation. \n\nFor a given square continuous-time periodic function matrix Ahr(t) of period T  in a  Harmonic Array representation,  the characteristic exponents ce are computed as the eigenvalues of a truncated harmonic state operator A(N)-E(N) lying in the  fundamental strip -ω/2 <  Im(λ) ≤ ω/2, where ω = 2π/T. If Ahr(t) has the harmonic components A_0, A_1, ..., A_p, then  for N ≥ p, P = 1 and nperiod = 1, the matrices A(N) and E(N) are built as\n\n       ( A_0  A_{-1} …  A_{-p}        0    )           ( -im*ϕ_{-N}I                                 0        )\n       ( A_1   A_0             ⋱           )           (     ⋮       ⋱                                        )\n       (  ⋮         ⋱            ⋱         )           (               -im*ϕ_{-1}*I                           )\nA(N) = ( A_p             ⋱          A_{-p} ) , E(N) =  (                           -im*ϕ_{0}*I                )\n       (        ⋱           ⋱         ⋮    )           (     ⋮                                  ⋱              )\n       (  0        A_p      …         A_0  )           (     0                                   -im*ϕ_{N}I   )\n\nwith ϕ_{i} := shift+i*ω. If N < p, then a truncated full block Toeplitz matrix A(N) is built using the first N harmonic components.  The default value used for N is N = max(10,p-1). \n\nGenerally, for given P ≥ 1 and  nperiod ≥ 1, the block Toeplitz matrix A(N) (and also E(N)) is constructed with (2N*np+1)×(2N*np+1) blocks, with np = P*nperiod, such that each A_i is preceeded in its column by np-1 zero blocks,  each A_{-i} is preceeded in its row by np-1 zero blocks and all diagonal blocks are equal toA_0.  \n\nThe keyword argument atol (default: atol = 1.e-10) is a tolerance on the magnitude of the trailing components of the  associated eigenvectors used to validate their asymptotic (exponential) decay.  Only eigenvalues satisfying this check are returned in ce. \n\nReferences\n\n[1] J. Zhou, T. Hagiwara, and M. Araki.      Spectral characteristics and eigenvalues computation of the harmonic state operators in continuous-time periodic systems.      Systems and Control Letters, 53:141–155, 2004.\n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.psceigfr","page":"Periodic system utilities","title":"PeriodicSystems.psceigfr","text":"psceigfr(A::FourierFunctionMatrix[, N]; P, atol) -> ce\n\nCompute the characteristic exponents of a continuous-time periodic matrix in Fourier Function Matrix representation. \n\nFor a given square continuous-time periodic function matrix A(t) of period T  in a  Fourier Function Matrix representation,  the characteristic exponents ce are computed as the eigenvalues of the state operator A(t)-D*I lying in the  fundamental strip -ω/2 <  Im(λ) ≤ ω/2, where ω = 2π/T. A finite dimensional truncated matrix of order n*(2*N*P+1)  is built to approximate A(t)-D*I, where n is the order of A(t),  N is the number of selected harmonic components in the Fourier representation and P is the period multiplication number (default: P = 1). The default value used for N is N = max(10,p-1), where p the number of harmonics terms of A(t) (see FourierFunctionMatrix). \n\nThe keyword argument atol (default: atol = 1.e-10) is a tolerance on the magnitude of the trailing components of the  associated eigenvectors used to validate their asymptotic (exponential) decay. Only eigenvalues satisfying this check are returned in ce. \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.monodromy","page":"Periodic system utilities","title":"PeriodicSystems.monodromy","text":" monodromy(A[, K = 1]; solver, reltol, abstol, dt) -> Ψ::PeriodicArray\n\nCompute the monodromy matrix for a linear ODE with periodic time-varying coefficients. \n\nFor the given square periodic matrix A(t) of period T and subperiod T′ = T/k, where  k is the number of subperiods,   the monodromy matrix Ψ = Φ(T′,0) is computed, where Φ(t,τ) is the state transition matrix satisfying the homogeneous linear ODE \n\ndΦ(t,τ)/dt = A(t)Φ(t,τ),  Φ(τ,τ) = I.\n\nA(t) can be specified as a PeriodicFunctionMatrix, HarmonicArray or FourierFunctionMatrix. \n\nIf K > 1, then Ψ = Φ(T′,0) is determined as a product of K matrices  Ψ = Ψ_K*...*Ψ_1, where for Δ := T′/K, Ψ_i = Φ(iΔ,(i-1)Δ) is the  state transition matrix on the time interval [(i-1)Δ,iΔ]. \n\nThe state transition matrices Φ(iΔ,(i-1)Δ) are computed by integrating numerically the above homogeneous linear ODE.   The ODE solver to be employed can be  specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-3),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt = min(Δ, Δ*K′/100)) (see tvstm).  For large values of K, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.tvstm","page":"Periodic system utilities","title":"PeriodicSystems.tvstm","text":" tvstm(A, tf, t0; solver, reltol, abstol, dt) -> Φ\n\nCompute the state transition matrix for a linear ODE with periodic time-varying coefficients.  For the given periodic square matrix A(t), initial time t0 and  final time tf, the state transition matrix Φ(tf,t0) is computed by integrating numerically the homogeneous linear ODE \n\n  dΦ(t,t0)/dt = A(t)Φ(t,t0),  Φ(t0,t0) = I\n\non the time interval [t0,tf]. A(t) can be specified as a PeriodicFunctionMatrix, HarmonicArray or FourierFunctionMatrix. \n\nThe ODE solver to be employed can be  specified using the keyword argument solver (see below), together with the required relative accuracy reltol (default: reltol = 1.e-3),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt = tf-t0).  Depending on the desired relative accuracy reltol,  lower order solvers are employed for reltol >= 1.e-4,  which are generally very efficient, but less accurate. If reltol < 1.e-4, higher order solvers are employed able to cope with high accuracy demands. \n\nThe following solvers from the OrdinaryDiffEq.jl package can be selected:\n\nsolver = \"non-stiff\" - use a solver for non-stiff problems (Tsit5() or Vern9());\n\nsolver = \"stiff\" - use a solver for stiff problems (Rodas4() or KenCarp58());\n\nsolver = \"linear\" - use a special solver for linear ODEs (MagnusGL6()) with fixed time step dt;\n\nsolver = \"symplectic\" - use a symplectic Hamiltonian structure preserving solver (IRKGL16());\n\nsolver = \"\" - use the default solver, which automatically detects stiff problems (AutoTsit5(Rosenbrock23()) or AutoVern9(Rodas5())). \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.psreduc_reg","page":"Periodic system utilities","title":"PeriodicSystems.psreduc_reg","text":"psreduc_reg(A) -> (M, N)\n\nDetermine for a n×n×p array A, the matrix pair (M, N)  with N invertible and M-λN regular, such that  the eigenvalues of M-λN are the same as those of the matrix product A(p)*A(p-1)*...*A(1), where A(i) is contained in A[:,:,i].  The structure exploiting fast reduction method of [1] is employed to determine M and N.\n\n[1] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\npsreduc_reg(A,E) -> (M, N)\n\nDetermine for a pair of n×n×p arrays (A,E), the matrix pair (M, N)  with M-λN regular, such that  the eigenvalues of M-λN are the same as those of the quotient matrix product inv(E(p))*(A(p)*inv(E(p-1))*A(p-1)*...*inv(E(1))*A(1), where A(i) is contained in A[:,:,i] and E(i) is contained in E[:,:,i].  The structure exploiting fast reduction method of [1] is employed to determine M and N.\n\n[1] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\npsreduc_reg(A) -> (M, N)\n\nDetermine for a p-dimensional vector of rectangular matrices A,  the matrix pair (M, N) with N invertible and M-λN regular, such that  the eigenvalues of M-λN are the same as those of the square  matrix product A(p)*A(p-1)*...*A(1), where A(i) is contained in A[i].  The structure exploiting fast reduction method of [1] is employed to determine M and N.\n\n[1] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.tvmeval","page":"Periodic system utilities","title":"PeriodicSystems.tvmeval","text":" tvmeval(At::PeriodicTimeSeriesMatrix, t; method = \"linear\") -> A::Vector{Matrix}\n\nEvaluate the time response of a periodic time series matrix.\n\nFor the periodic time series matrix At and the vector of time values t,  an interpolation/extrapolation based approximation   A[i] is evaluated for each time value t[i]. The keyword parameter method specifies the interpolation/extrapolation method to be used for periodic data.  The following interpolation methods from the Interpolations.jl  package can be selected: \n\nmethod = \"constant\" - use periodic B-splines of degree 0; \n\nmethod = \"linear\" - use periodic B-splines of degree 1 (periodic linear interpolation) (default);\n\nmethod = \"quadratic\" - use periodic B-splines of degree 2 (periodic quadratic interpolation); \n\nmethod = \"cubic\" - use periodic B-splines of degree 3 (periodic cubic interpolation).\n\n\n\n\n\n tvmeval(Ahr::HarmonicArray, t; ntrunc, exact = true) -> A::Vector{Matrix}\n\nEvaluate the time response of a harmonic array.\n\nFor the harmonic array Ahr representing representing a continuous-time  time periodic matrix A(t) and the vector of time values t,  A[i] = A(t[i]) is computed for each time value t[i].  If exact = true (default) an exact evaluation is computed, while for exact = false,  a linear interpolation based approximation is computed  (potentially more accurate in intersample points). The keyword argument ntrunc specifies the number of harmonics to be used for evaluation  (default: maximum possible number of harmonics). \n\n\n\n\n\n tvmeval(Asym::PeriodicSymbolicMatrix, t) -> A::Vector{Matrix}\n\nEvaluate the time response of a periodic symbolic matrix.\n\nFor the periodic symbolic matrix Asym representing a time periodic matrix A(t) and the vector of time values t,  A[i] = A(t[i]) is evaluated for each time value t[i]. \n\n\n\n\n\n tvmeval(Af::PeriodicFunctionMatrix, t) -> A::Vector{Matrix}\n\nEvaluate the time response of a periodic function matrix.\n\nFor the periodic function matrix Af representing a time periodic matrix A(t) and the vector of time values t,  A[i] = A(t[i]) is evaluated for each time value t[i]. \n\n\n\n\n\n tvmeval(A::FourierFunctionMatrix, t) -> Aval::Vector{Matrix}\n\nEvaluate the time response of a periodic function matrix.\n\nFor the periodic matrix A(t), in a Fourier Function Matrix representation, and the vector of time values t,  Aval[i] = A(t[i]) is evaluated for each time value t[i]. \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.hreval","page":"Periodic system utilities","title":"PeriodicSystems.hreval","text":" hreval(Ahr::HarmonicArray, t; ntrunc, exact = true) -> A::Matrix\n\nEvaluate the harmonic array Ahr representing a continuous-time  time periodic matrix A(t) for a numerical or symbolic time value t.  For a real value t, if exact = true (default) an exact evaluation is computed, while for exact = false,  a linear interpolation based approximation is computed (potentially more accurate in intersample points). The keyword argument ntrunc specifies the number of harmonics to be used for the evaluation  (default: maximum possible number).  If t is a symbolic variable, a symbolic evaluation of A(t) is performed (see also hr2psm)\n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.hrchop","page":"Periodic system utilities","title":"PeriodicSystems.hrchop","text":" hrchop(Ahr::HarmonicArray; tol) -> Ahrtrunc::HarmonicArray\n\nRemove the trailing terms of a harmonic representation by deleting those whose norms are below a certain tolerance. \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.hrtrunc","page":"Periodic system utilities","title":"PeriodicSystems.hrtrunc","text":" hrtrunc(Ahr::HarmonicArray, n) -> Ahrtrunc::HarmonicArray\n\nTruncate a harmonic representation by deleting the trailing terms whose indices exceed certain number n of harmonics. \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.pmaverage","page":"Periodic system utilities","title":"PeriodicSystems.pmaverage","text":"pmaverage(A) -> Am\n\nCompute for the continuous-time periodic matrix A(t)  the corresponding time averaged matrix Am over one period.  \n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.pslyapd","page":"Periodic system utilities","title":"PeriodicSystems.pslyapd","text":"pslyapd(A, C; adj = true, stability_check = false) -> X\n\nSolve the periodic discrete-time Lyapunov equation.\n\nFor the square n-th order periodic matrices A(i), i = 1, ..., pa and  C(i), i = 1, ..., pc  of periods pa and pc, respectively,  the periodic solution X(i), i = 1, ..., p of period p = lcm(pa,pc) of the  periodic Lyapunov equation is computed:  \n\nA(i)'*X(i+1)*A(i) + C(i) = X(i), i = 1, ..., p     for `adj = true`; \n\nA(i)*X(i)*A(i)' + C(i) = X(i+1), i = 1, ..., p     for `adj = false`.\n\nThe periodic matrices A and C are stored in the n×n×pa and n×n×pc 3-dimensional  arrays A and C, respectively, and X results as a n×n×p 3-dimensional array.  \n\nAlternatively, the periodic matrices A and C can be stored in the  pa- and pc-dimensional vectors of matrices A and C, respectively, and X results as a p-dimensional vector of matrices.\n\nIf stability_check = true, the stability of characteristic multipliers of A is checked and an error is issued if any characteristic multiplier has modulus equal to or larger than one. \n\nThe periodic discrete analog of the Bartels-Stewart method based on the periodic Schur form of the periodic matrix A is employed [1].\n\nReference:\n\n[1] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.                Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.pslyapd2","page":"Periodic system utilities","title":"PeriodicSystems.pslyapd2","text":"pslyapd2(A, C, E; stability_check = false) -> (X, Y)\n\nSolve a pair of periodic discrete-time Lyapunov equations.\n\nFor the square n-th order periodic matrices A(i), i = 1, ..., pa,  C(i), i = 1, ..., pc, and E(i), i = 1, ..., pe of periods pa, pc and pe, respectively,  the periodic solutions X(i), i = 1, ..., p and Y(i), i = 1, ..., p  of period p = lcm(pa,pc,pe) of the periodic Lyapunov equations are computed:  \n\nA(i)*X(i)*A(i)' + C(i) = X(i+1), i = 1, ..., p ,  \n \nA(i)'*Y(i+1)*A(i) + E(i) = Y(i), i = 1, ..., p .\n\nThe periodic matrices A, C and E are stored in the n×n×pa, n×n×pc and n×n×pe 3-dimensional  arrays A, C and E, respectively, and X and Y result as n×n×p 3-dimensional arrays.  \n\nAlternatively, the periodic matrices A, C and E can be stored in the  pa-, pc- and pe-dimensional vectors of matrices A, C and E, respectively, and X and Y result as p-dimensional vectors of matrices.\n\nIf stability_check = true, the stability of characteristic multipliers of A is checked and an error is issued if any characteristic multiplier has modulus equal to or larger than one. \n\nThe periodic discrete analog of the Bartels-Stewart method based on the periodic Schur form of the periodic matrix A is employed [1].\n\nReference:\n\n[1] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.                Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.pslyapdkr","page":"Periodic system utilities","title":"PeriodicSystems.pslyapdkr","text":" pslyapdkr(A, C; adj = true) -> X\n\nSolve the periodic discrete-time Lyapunov matrix equation\n\n  A'σXA + C = X, if adj = true,\n\nor \n\n  A*X*A' + C =  σX, if adj = false,\n\nwhere σ is the forward shift operator σX(i) = X(i+1).   The periodic matrix A must not have characteristic multipliers on the unit circle.                The periodic matrices A and C are either stored as 3-dimensional arrays or as as vectors of matrices. \n\nThe Kronecker product expansion of equations is employed and therefore  this function is not recommended for large order matrices or large periods.\n\n\n\n\n\n","category":"function"},{"location":"pstools.html#PeriodicSystems.psplyapd","page":"Periodic system utilities","title":"PeriodicSystems.psplyapd","text":" psplyapd(A, C; adj = true, rtol = ϵ^(3/4)) -> U\n\nCompute the upper triangular factor U of the solution X = U'U of the  periodic discrete-time Lyapunov matrix equation\n\n  A'σXA + C'C = X, if adj = true,\n\nor of the solution X = UU' of the periodic discrete-time Lyapunov matrix equation\n\n  AXA' + CC' =  σX, if adj = false,\n\nwhere σ is the forward shift operator σX(i) = X(i+1).  The periodic matrix A must be stable, i.e., have all characteristic multipliers  with moduli less than one. \n\nThe periodic matrices A and C are either stored as 3-dimensional arrays or as as vectors of matrices. \n\nThe iterative method (Algorithm 5) of [1] and its dual version are employed.  \n\nReference:\n\n[1] A. Varga, \"Periodic Lyapunov equations: some applications and new algorithms\",      Int. J. Control, vol. 67, pp. 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#SLICOT-periodic-system-utilities","page":"SLICOT periodic system utilities","title":"SLICOT periodic system utilities","text":"","category":"section"},{"location":"slicot.html","page":"SLICOT periodic system utilities","title":"SLICOT periodic system utilities","text":"PeriodicSystems.SLICOTtools.mb03vd!\nPeriodicSystems.SLICOTtools.mb03vy!\nPeriodicSystems.SLICOTtools.mb03wd!\nPeriodicSystems.SLICOTtools.mb03vw!\nPeriodicSystems.SLICOTtools.mb03bd!\nPeriodicSystems.SLICOTtools.mb03kd!","category":"page"},{"location":"slicot.html#PeriodicSystems.SLICOTtools.mb03vd!","page":"SLICOT periodic system utilities","title":"PeriodicSystems.SLICOTtools.mb03vd!","text":"mb03vd!(n::Integer, p::Integer, ilo::Integer, ihi::Integer, A::Array{Float64, 3}, tau::AbstractMatrix{Float64}) -> info::Int64\n\nReduce a product of p real general matrices A = A_1*A_2*...*A_p to upper Hessenberg form, H = H_1*H_2*...*H_p, where H_1 is upper Hessenberg, and H_2, ..., H_p are upper triangular, by using orthogonal similarity transformations on A,\n\n    Q_1' * A_1 * Q_2 = H_1,\n    Q_2' * A_2 * Q_3 = H_2,\n           ...\n    Q_p' * A_p * Q_1 = H_p.\n\nThe matrices A_1, A_2, ..., A_p are contained in the 3-dimensional array A.  The resulting H_1, H_2, ..., H_p and Q_1, Q_2, ..., Q_p overwrite  A_1, A_2, ..., A_p in A and the array tau.   \n\nSee the SLICOT documentation of MB03VD for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicSystems.SLICOTtools.mb03vy!","page":"SLICOT periodic system utilities","title":"PeriodicSystems.SLICOTtools.mb03vy!","text":" mb03vy!(n::Integer, p::Integer, ilo::Integer, ihi::Integer, A::Array{Float64, 3}, tau::AbstractMatrix{Float64}) -> info::Int64\n\nGenerate the real orthogonal matrices Q_1, Q_2, ..., Q_p, which are defined as the product of ihi-ilo elementary reflectors of order n, as returned in A_1, A_2, ..., A_p by mb03vd!:\n\n Q_j = H_j(ilo) H_j(ilo+1) . . . H_j(ihi-1).\n\nThe 3-dimensional arrays A and tau contains the information on the employed elementary reflectors. The resulting Q_1, Q_2, ..., Q_p overwrite A_1, A_2, ..., A_p. \n\nSee the SLICOT documentation of MB03VY for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicSystems.SLICOTtools.mb03wd!","page":"SLICOT periodic system utilities","title":"PeriodicSystems.SLICOTtools.mb03wd!","text":"mb03wd!(job::AbstractChar, compz::AbstractChar, n::Integer, p::Integer, \n        ilo::Integer, ihi::Integer, iloz::Integer, ihiz::Integer,  h::Array{Float64, 3}, z::Array{Float64, 3}, \n        wr::AbstractVector{Float64}, wi::AbstractVector{Float64}, ldwork::Integer) -> info::Int64\n\nCompute the Schur decomposition and the eigenvalues of a product of matrices, H = H_1H_2...*H_p, with H_1 an upper Hessenberg matrix and H_2, ..., H_p upper triangular matrices, without evaluating the product. Specifically, the matrices Z_i are computed, such that\n\n    `Z_1' * H_1 * Z_2 = T_1,`\n    `Z_2' * H_2 * Z_3 = T_2,`\n           `...`\n    `Z_p' * H_p * Z_1 = T_p,`\n\nwhere T_1 is in real Schur form, and T_2, ..., T_p are upper triangular.\n\nThe routine works primarily with the Hessenberg and triangular submatrices in rows and columns ILO to IHI, but optionally applies the transformations to all the rows and columns of the matrices H_i, i = 1,...,p. The transformations can be optionally accumulated.\n\nSee the SLICOT documentation of MB03WD for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicSystems.SLICOTtools.mb03vw!","page":"SLICOT periodic system utilities","title":"PeriodicSystems.SLICOTtools.mb03vw!","text":"mb03vw!(compq::AbstractChar, triu::AbstractChar, qind::AbstractVector{Int64}, k::Integer, n::Integer, h::Integer, \n        ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{Float64, 3}, q::Array{Float64, 3}, \n        liwork::Integer, ldwork::Integer) -> info::Int64\n\nReduce the generalized matrix product\n\n          s[1]           s[2]                 s[k]\n  A[:,:,1]     * A[:,:,2]     * ... * A[:,:,k]\n\nto upper Hessenberg-triangular form, where A is N-by-N-by-K and S is the signature array with values 1 or -1. The H-th matrix of A is reduced to upper Hessenberg form while the other matrices are triangularized. \n\nIf compq = 'U' or compq = 'I', then the orthogonal factors are computed and stored in the array Q so that for s[i] = 1,\n\n                T\n    Q[:,:,i](in)   A[:,:,i](in)   Q[:,:,mod(i,k)+1](in)\n                                                        T \n=   Q[:,:,i](out)  A[:,:,i](out)  Q[:,:,mod(i,k)+1](out),\n\nand for s[i] = -1,\n\n                         T\n    Q[:,:,mod(i,k)+1](in)   A[:,:,i](in)   Q[:,:,i](in)\n                                                        T \n=   Q[:,:,mod(i,k)+1](out)  A[:,:,i](out)  Q[:,:,i](out).\n\nA partial generation of the orthogonal factors can be realized via the array qind.\n\nIf triu = 'N' only matrices with negative signature are reduced to upper triangular form in the first stage of the algorithm.  If triu = 'A' all possible n-1 matrices with negative signature are reduced. \n\nSee the SLICOT documentation of MB03VW for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicSystems.SLICOTtools.mb03bd!","page":"SLICOT periodic system utilities","title":"PeriodicSystems.SLICOTtools.mb03bd!","text":"mb03bd!(job::AbstractChar, defl::AbstractChar, compq::AbstractChar, qind::AbstractVector{Int64}, k::Integer, n::Integer, h::Integer, \n        ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{Float64, 3}, q::Array{Float64, 3}, alphar::AbstractVector{Float64}, \n        alphai::AbstractVector{Float64}, beta::AbstractVector{Float64}, scal::AbstractVector{Int64}, liwork::Integer, ldwork::Integer) -> (info::Int64, iwarn::Int64)\n\nFind the eigenvalues of the generalized matrix product\n\n          s[1]           s[2]                 s[k]\n  A[:,:,1]     * A[:,:,2]     * ... * A[:,:,k]\n\nwhere A[:,:,h] is upper Hessenberg and A[:,:,i], i <> h, is upper triangular, using a double-shift version of the periodic QZ method. In addition, A may be reduced to periodic Schur form: A[:,:,h] is upper quasi-triangular and all the other factors A[:,:,i] are upper triangular. Optionally, the 2-by-2 triangular matrices corresponding to 2-by-2 diagonal blocks in A[:,:,h] are so reduced that their product is a 2-by-2 diagonal matrix.\n\nIf compq = 'U' or compq = 'I', then the orthogonal factors are computed and stored in the array Q so that for s[i] = 1,\n\n                T\n    Q[:,:,i](in)   A[:,:,i](in)   Q[:,:,mod(i,k)+1](in)\n                                                        T \n=   Q[:,:,i](out)  A[:,:,i](out)  Q[:,:,mod(i,k)+1](out),\n\nand for s[i] = -1,\n\n                         T\n    Q[:,:,mod(i,k)+1](in)   A[:,:,i](in)   Q[:,:,i](in)\n                                                        T \n=   Q[:,:,mod(i,k)+1](out)  A[:,:,i](out)  Q[:,:,i](out).\n\nA partial generation of the orthogonal factors can be realized via the array qind.\n\nSee the SLICOT documentation of MB03BD for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicSystems.SLICOTtools.mb03kd!","page":"SLICOT periodic system utilities","title":"PeriodicSystems.SLICOTtools.mb03kd!","text":"mb03kd!(compq::AbstractChar, strong::AbstractChar, k::Integer, nc::Integer, kschur::Integer, n::AbstractVector{Int64}, ni::AbstractVector{Int64}, \n        s::AbstractVector{Int64}, select::AbstractVector{BlasInt}, t::AbstractVector{Float64}, ldt::AbstractVector{Int64}, ixt::AbstractVector{Int64}, \n        q::AbstractVector{Float64}, ldq::AbstractVector{Int64}, ixq::AbstractVector{Int64}, tol::Float64, ldwork::Integer) -> (m::Int64, info::Int64)\n\nReorder the diagonal blocks of the formal matrix product\n\n T22_k^s[k] * T22_k-1^s[k-1] * ... * T22_1^s[1],                (1)\n\nof length k, in the generalized periodic Schur form,\n\n          [  T11_i  T12_i  T13_i  ]\n    T_i = [    0    T22_i  T23_i  ],    i = 1, ..., k,          (2)\n          [    0      0    T33_i  ]\n\nwhere\n\nthe submatrices T11_i are ni(i+1)-by-ni(i), if s[i] = 1, or ni(i)-by-ni(i+1), if s[i] = -1, and contain dimension-induced infinite eigenvalues,\nthe submatrices T22_i are nc-by-nc and contain core eigenvalues, which are generically neither zero nor infinite,\nthe submatrices T33_i contain dimension-induced zero eigenvalues,\n\nsuch that the m selected eigenvalues pointed to by the integer vector select end up in the leading part of the matrix sequence T22_i.\n\nGiven that n[i] = n[i+1] for all i where s[i] = -1, the T11_i are void and the first m columns of the updated orthogonal transformation matrix sequence Q_1, ..., Q_k span a periodic deflating subspace corresponding to the same eigenvalues.\n\nIf compq = 'U' or compq = 'I', then the orthogonal factors are computed and stored in the array Q so that for s[i] = 1,\n\n           T\n    Q_i(in)  T_i(in) Q_(mod(i,k)+1)(in)\n                                          T \n=   Q_i(out) T_i(out)  Q_(mod(i,k)+1)(out),\n\nand for s[i] = -1,\n\n                      T\n    Q_(mod(i,k)+1)(in)   T_i(in)   Q_i(in)\n                                           T \n=   Q_(mod(i,k)+1)(out)  T_i(out)  Q_i(out).\n\nSee the SLICOT documentation of MB03KD for details.\n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#Basic-periodic-system-connectios-and-operations","page":"Basic connections and operations","title":"Basic periodic system connectios and operations","text":"","category":"section"},{"location":"psconnect.html","page":"Basic connections and operations","title":"Basic connections and operations","text":"psparallel Parallel connection of periodic systems.\npsseries   Series connection of periodic systems.\npsappend   Appending of periodic systems.\npshorzcat  Horizontal concatenation of periodic systems.\npsvertcat  Vertical concatenation of periodic systems.\npsinv  Inversion of periodic systems.\npsfeedback  Periodic output feedback connections.\npssfeedback  Periodic state feedback connection.\npssofeedback  Periodic state feedback with state estimator connection.","category":"page"},{"location":"psconnect.html","page":"Basic connections and operations","title":"Basic connections and operations","text":"psparallel\npsseries\npsappend\npshorzcat\npsvertcat\npsinv\npsfeedback\npssfeedback\npssofeedback","category":"page"},{"location":"psconnect.html#PeriodicSystems.psparallel","page":"Basic connections and operations","title":"PeriodicSystems.psparallel","text":"psys = psparallel(psys1, psys2)\npsys = psys1 + psys2\n\nBuild the parallel connection psys of periodic systems psys1 and psys2. This coupling formally corresponds to the addition of their transfer maps as psys = psys1 + psys2.\n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.psseries","page":"Basic connections and operations","title":"PeriodicSystems.psseries","text":"psys = psseries(psys1, psys2)\npsys = psys2*psys1\n\nBuild the series connection psys of periodic systems psys1 and psys2. This coupling formally corresponds to the product of their transfer maps as psys = psys2*psys1.\n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.psappend","page":"Basic connections and operations","title":"PeriodicSystems.psappend","text":"psys = psappend(psys1, psys2)\n\nAppend the periodic systems psys1 and psys2 by concatenating their input and output vectors.  This corresponds to build psys as the block diagonal concatenation of their transfer maps. \n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.pshorzcat","page":"Basic connections and operations","title":"PeriodicSystems.pshorzcat","text":"psys = pshorzcat(psys1,psys2)\npsys = [psys1 psys2]\n\nConcatenate horizontally the two periodic systems psys1 and psys2  by concatenating their input vectors. This formally corresponds to the horizontal  concatenation of their transfer maps. \n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.psvertcat","page":"Basic connections and operations","title":"PeriodicSystems.psvertcat","text":"psys = psvertcat(psys1,psys2)\npsys = [psys1; psys2]\n\nConcatenate vertically the two periodic systems psys1 and psys2  by concatenating their output vectors. This formally corresponds to the vertical  concatenation of their transfer maps. \n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.psinv","page":"Basic connections and operations","title":"PeriodicSystems.psinv","text":"psysi = psinv(psys)\n\nCompute the inverse psysi of the square periodic system psys.   This operation formally corresponds to the inversion of the transfer map of psys such that psysi*psys is the identity mapping.\n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.psfeedback","page":"Basic connections and operations","title":"PeriodicSystems.psfeedback","text":" psyscl = psfeedback(psys, K, (inp, out); negative = false)\n\nBuild for a given periodic system psys with input vector u and output vector y and  a periodic output feedback gain K(t) the closed-loop periodic system psyscl corresponding to the memoryless output feedback u[inp] = K(t)*y[out] + v, where inp and out  are indices, vectors of indices, index ranges, : or any combinations of them. Only distinct indices  can be specified. If negative = true, a negative psfeedback u[inp] = -K(t)*y[out] + v is used.\n\n\n\n\n\n psyscl = psfeedback(sys, K, (inp, out); negative = false)\n\nBuild for a given standard  state-space system sys with input vector u and output vector y and  a periodic output feedback gain K(t) the closed-loop periodic system psyscl corresponding to the memoryless output feedback u[inp] = K(t)*y[out] + v, where inp and out are  are indices, vectors of indices, index ranges, : or any combinations of them. Only distinct indices  can be specified. If negative = true, a negative feedback u[inp] = -K(t)*y[out] + v is used. For a continuous-time system sys, K must be a periodic switching matrix or a discrete-time periodic matrix,  while for a discrete-time system sys, K must be a discrete-time periodic matrix with the same sample time. \n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.pssfeedback","page":"Basic connections and operations","title":"PeriodicSystems.pssfeedback","text":" psyscl = pssfeedback(psys, F, inp; negative = false)\n\nBuild for a given periodic system psys with input vector u and output vector y and  a periodic state feedback gain F(t) the closed-loop periodic system psyscl corresponding to the memoryless state feedback u[inp] = F(t)*x + v, where inp   are indices, a vector of indices, an index range, : or any combinations of them. Only distinct indices  can be specified. If negative = true, a negative state feedback u[inp] = -F(t)*x + v is used.\n\n\n\n\n\n","category":"function"},{"location":"psconnect.html#PeriodicSystems.pssofeedback","page":"Basic connections and operations","title":"PeriodicSystems.pssofeedback","text":" psyscl = pssofeedback(psys, F, K, (inp, out); negative = false)\n\nBuild for a given periodic system psys, with input vector u and output vector y,  a periodic state feedback gain F(t) and a periodic Kalman gain K(t) the closed-loop periodic system psyscl corresponding to the memoryless state feedback u[inp] = F(t)*xe + v and  a full state estimator with state xe and inputs [u[inp]; y[out]], where inp and out  are indices, vectors of indices, index ranges, : or any combinations of them. Only distinct indices  can be specified. If negative = true, a negative state feedback u[inp] = -F(t)*xe + v is used.\n\n\n\n\n\n","category":"function"},{"location":"psconversions.html#Discretization-of-continuous-time-periodic-systems","page":"Discretization of continuous-time periodic systems","title":"Discretization of continuous-time periodic systems","text":"","category":"section"},{"location":"psconversions.html","page":"Discretization of continuous-time periodic systems","title":"Discretization of continuous-time periodic systems","text":"psc2d  Discretization of a continuous-time periodic system. ","category":"page"},{"location":"psconversions.html","page":"Discretization of continuous-time periodic systems","title":"Discretization of continuous-time periodic systems","text":"psc2d","category":"page"},{"location":"psconversions.html#PeriodicSystems.psc2d","page":"Discretization of continuous-time periodic systems","title":"PeriodicSystems.psc2d","text":" psc2d([PMT,] psysc, Ts; solver, reltol, abstol, dt) -> psys::PeriodicStateSpace{PMT}\n\nCompute for the continuous-time periodic system psysc = (A(t),B(t),C(t),D(t)) of period T and  for a sampling time Ts, the corresponding discretized periodic system psys = (Ad,Bd,Cd,Dd) using a zero-order hold based discretization method.  The resulting discretized system psys has the matrices of type PeriodicArray by default, or of type PMT, where PMT is one of the types PeriodicMatrix, PeriodicArray, SwitchingPeriodicMatrix or SwitchingPeriodicArray.    \n\nThe discretization is performed by determining the monodromy matrix as a product of  K = T/Ts state transition matrices of the extended state-space matrix [A(t) B(t); 0 0]  by integrating numerically the corresponding homogeneous linear ODE.   The ODE solver to be employed can be  specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-3),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt = Ts/10) (see tvstm).  For large values of K, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#Periodic-Lyapunov-equation-solvers","page":"Periodic Lyapunov equation solvers","title":"Periodic Lyapunov equation solvers","text":"","category":"section"},{"location":"pslyap.html","page":"Periodic Lyapunov equation solvers","title":"Periodic Lyapunov equation solvers","text":"pclyap Solution of periodic Lyapunov differential equations. \nprclyap Solution of reverse-time periodic Lyapunov differential equation equations. \npfclyap  Solution of forward-time periodic Lyapunov differential equation equations.\npgclyap Computation of periodic generators for periodic Lyapunov differential equations.\npgclyap2 Computation of periodic generators for a pair of periodic Lyapunov difference/differential and differential equations.\ntvclyap_eval Evaluation of time value of solution from the computed periodic generator.\npdlyap Solution of periodic discrete-time Lyapunov equations. \npdlyap2 Solution of a pair of periodic discrete-time Lyapunov equations. \nprdlyap Solution of reverse-time periodic discrete-time Lyapunov equations. \npfdlyap  Solution of forward-time periodic discrete-time Lyapunov equations.\npcplyap Solution of positve periodic Lyapunov differential equations. \nprcplyap Solution of positve reverse-time periodic Lyapunov differential equations.\npfcplyap  Solution of positve forward-time periodic Lyapunov differential equations.\npgcplyap Computation of periodic generators for positive periodic Lyapunov differential equations.\ntvcplyap_eval Evaluation of time value of the upper triangular factor of solution from the computed periodic generator.\npdplyap Solution of positve periodic discrete-time Lyapunov equations. \nprdplyap Solution of positve reverse-time periodic discrete-time Lyapunov equations. \npfdplyap  Solution of positve forward-time periodic discrete-time Lyapunov equations.","category":"page"},{"location":"pslyap.html","page":"Periodic Lyapunov equation solvers","title":"Periodic Lyapunov equation solvers","text":"pclyap\nprclyap\npfclyap\npgclyap\npgclyap2\ntvclyap_eval\npdlyap\npdlyap2\nprdlyap\npfdlyap\npcplyap\nprcplyap\npfcplyap\npgcplyap\ntvcplyap_eval\npdplyap\nprdplyap\npfdplyap","category":"page"},{"location":"pslyap.html#PeriodicSystems.pclyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pclyap","text":"pclyap(A, C; K = 10, adj = false, solver, reltol, abstol, intpol, intpolmeth) -> X\npclyap(A, C; K = 10, adj = false, solver, reltol, abstol) -> X\n\nSolve the periodic Lyapunov differential equation\n\n.\nX(t) = A(t)X(t) + X(t)A(t)' + C(t) , if adj = false,\n\nor \n\n .\n-X(t) = A(t)'X(t) + X(t)A(t) + C(t) , if adj = true.\n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods.  Additionally C must be symmetric.  The resulting symmetric periodic solution X has the type PeriodicFunctionMatrix and  X(t) can be used to evaluate the value of X at time t.  X has the period set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. \n\nThe multiple-shooting method of [1] is employed to convert the (continuous-time) periodic differential Lyapunov equation  into a discrete-time periodic Lyapunov equation satisfied by a multiple point generator of the solution.  The keyword argument K specifies the number of grid points to be used for the discretization of the continuous-time problem (default: K = 10).  If  A and C are of types PeriodicTimeSeriesMatrix or PeriodicSwitchingMatrix, then K specifies the number of grid points used between two consecutive switching time values (default: K = 1).   The multiple point periodic generator is computed  by solving the appropriate discrete-time periodic Lyapunov  equation using the periodic Schur method of [2].  The resulting periodic generator is finally converted into a periodic function matrix which determines for a given t  the function value X(t) by integrating the appropriate ODE from the nearest grid point value. \n\nTo speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument intpol = true (default: intpol = false).  In this case the interpolation method to be used can be specified via the keyword argument intpolmeth = meth. The allowable values for meth are: \"constant\", \"linear\", \"quadratic\" and \"cubic\" (default) (see also ts2pfm). Interpolation is not possible if A and C are of type PeriodicSwitchingMatrix. \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-4) and  absolute accuracy abstol (default: abstol = 1.e-7) (see tvstm).  Parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.prclyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.prclyap","text":"prclyap(A, C; K = 10, solver, reltol, abstol, intpol, intpolmeth) -> X\nprclyap(A, C; K = 10, solver, reltol, abstol) -> X\n\nSolve the periodic reverse-time Lyapunov differential equation\n\n .\n-X(t) = A(t)'X(t) + X(t)A(t) + C(t).\n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods,  and additionally C must be symmetric. The resulting symmetric periodic solution X has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. \n\nThis function is merely an interface to pclyap (see this function for the description of keyword parameters). \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pfclyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pfclyap","text":"pfclyap(A, C; K = 10, solver, reltol, abstol, intpol, intpolmeth) -> X\npfclyap(A, C; K = 10, solver, reltol, abstol) -> X\n\nSolve the periodic forward-time Lyapunov differential equation\n\n.\nX(t) = A(t)X(t) + X(t)A(t)' + C(t) .\n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods,  and additionally C must be symmetric. The resulting symmetric periodic solution X has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. \n\nThis function is merely an interface to pclyap (see this function for the description of keyword parameters). \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pgclyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pgclyap","text":"pgclyap(A, C[, K = 1]; adj = false, solver, reltol, abstol, dt) -> X\n\nCompute periodic generators for the periodic Lyapunov differential equation\n\n.\nX(t) = A(t)X(t) + X(t)A(t)' + C(t) , if adj = false,\n\nor \n\n .\n-X(t) = A(t)'X(t) + X(t)A(t) + C(t) , if adj = true.\n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods,  and additionally C must be symmetric.  If A and C have the types PeriodicFunctionMatrix, HarmonicArray, FourierFunctionMatrix or PeriodicTimeSeriesMatrix,  then the resulting X is a collection of periodic generator matrices determined  as a periodic time-series matrix with N components, where N = 1 if A and C are constant matrices and N = K otherwise.  If A and C have the type PeriodicSwitchingMatrix, then X is a collection of periodic generator matrices  determined as a periodic switching matrix, whose switching times are the unique switching times contained in the union of the switching times of A and C.  If K > 1, a refined grid of K equidistant values is used for each two consecutive  switching times in the union.       The period of X is set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. Any component matrix of X is a valid initial value to be used to generate the   solution over a full period by integrating the appropriate differential equation.  The multiple-shooting method of [1] is employed, first, to convert the continuous-time periodic Lyapunov differential equation  into a discrete-time periodic Lyapunov equation satisfied by  the generator solution in the grid points and then to compute the solution by solving an appropriate discrete-time periodic Lyapunov  equation using the periodic Schur method of [2]. \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\nParallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pgclyap2","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pgclyap2","text":"pgclyap2(A, C, E, [, K = 1]; solver, reltol, abstol, dt) -> (X,Y)\n\nCompute the solutions of the periodic differential Lyapunov equations\n\n -\n X(t) = A(t)*X(t) + X(t)*A'(t) + C(t)\n\nand \n\n .\n-Y(t) = A(t)'Y(t) + Y(t)A(t) + E(t).\n\nThe periodic matrices A, C and E must have the same dimensions, the same type and  commensurate periods. Additionally C and E must be symmetric.   If A, C and E have the types PeriodicFunctionMatrix, HarmonicArray, FourierFunctionMatrix or PeriodicTimeSeriesMatrix,  then the resulting X and Y are collections of periodic generator matrices determined  as periodic time-series matrices with N components, where N = 1 if A, C and E are constant matrices and N = K otherwise.      The period T of X and Y is set to the least common commensurate period of A, C and E and the number of subperiods is adjusted accordingly. Any component matrix of X or Y is a valid initial value to be used to generate the   solution over a full period by integrating the appropriate differential equation.  The multiple-shooting method of [1] is employed, first, to convert the continuous-time periodic Lyapunov equations  into discrete-time periodic Lyapunov equations satisfied by  the generator solutions in the grid points and then to compute the solutions by solving appropriate discrete-time periodic Lyapunov  equations using the periodic Schur method of [2]. \n\nThe ODE solver to be employed to convert the continuous-time problems into discrete-time problems can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\nParallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.  \n\n\n\n\n\npgclyap2(A, C, E, [, K = 1]; solver, reltol, abstol, dt) -> (X,Y)\n\nCompute the solution of the discrete-time periodic Lyapunov equation\n\nX(i+1) = Φ(i)*X(i)*Φ'(i) + W(i), i = 1, ..., K, X(K+1) := X(1)\n\nand a periodic generator for the periodic Lyapunov differential equations\n\n .\n-Y(t) = A(t)'Y(t) + Y(t)A(t) + E(t).\n\nThe periodic matrices A and E and the constant matrix C must have the same dimensions, and A and E  must have the same type and commensurate periods. Additionally C and E must be symmetric.   Φ(i) denotes the transition matrix on the time interval [Δ*(i-1), Δ*i] corresponding to A,  where Δ = T/K with T the common period of A and E. W(i) = 0 for i = 1, ..., K-1 and W(K) = C.   If A and E have the types PeriodicFunctionMatrix, HarmonicArray, FourierFunctionMatrix or PeriodicTimeSeriesMatrix,  then the resulting Y is a collection of periodic generator matrices determined  as a periodic time-series matrix with N components, where N = 1 if A and E are constant matrices and N = K otherwise.      The period T of Y is set to the least common commensurate period of A and E and the number of subperiods is adjusted accordingly. Any component matrix of Y is a valid initial value to be used to generate the   solution over a full period by integrating the appropriate differential equation.  The multiple-shooting method of [1] is employed, first, to convert the continuous-time periodic Lyapunov into a discrete-time periodic Lyapunov equation satisfied by  the generator solution in the grid points and then to compute the solution by solving an appropriate discrete-time periodic Lyapunov  equation using the periodic Schur method of [2]. \n\nThe ODE solver to be employed to convert the continuous-time problems into discrete-time problems can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\nParallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.  \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.tvclyap_eval","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.tvclyap_eval","text":"  tvclyap_eval(t, W, A, C; adj = false, solver, reltol, abstol, dt) -> Xval\n\nCompute the time value Xval := X(t) of the solution of the periodic Lyapunov differential equation\n\n   .\n   X(t) = A(t)X(t) + X(t)A(t)' + C(t) ,  X(t0) = W(t0), t > t0, if adj = false\n\nor \n\n   .\n  -X(t) = A(t)'X(t) + X(t)A(t) + C(t) ,  X(t0) = W(t0), t < t0, if adj = true,\n\nusing the periodic generator W determined with the function pgclyap for the same periodic matrices A and C and the same value of the keyword argument adj.  The initial time t0 is the nearest time grid value to t, from below, if adj = false, or from above, if adj = true. \n\nThe above ODE is solved by employing the integration method specified via the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pdlyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pdlyap","text":"pdlyap(A, C; adj = true, stability_check = false) -> X\n\nSolve the periodic discrete-time Lyapunov equation\n\nA'σXA + C = X  for adj = true\n\nor \n\nAXA' + C = σX  for adj = false,\n\nwhere σ is the forward shift operator σX(i) = X(i+1). \n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods,  and additionally C must be symmetric. The resulting symmetric periodic solution X has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. \n\nIf stability_check = true, the stability of characteristic multipliers of A is checked and an error is issued if any characteristic multiplier has modulus equal to or larger than one. \n\nThe periodic discrete analog of the Bartels-Stewart method based on the periodic Schur form of the periodic matrix A is employed [1].\n\nReference:\n\n[1] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.                Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pdlyap2","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pdlyap2","text":"pdlyap2(A, C, E; stability_check = false) -> (X, Y)\n\nSolve the pair of periodic discrete-time Lyapunov equations\n\nAXA' + C  = σX, \nA'σYA + E = Y,\n\nwhere σ is the forward shift operator σX(i) = X(i+1) and σY(i) = Y(i+1). \n\nThe periodic matrices A, C and E must have the same type, the same dimensions and commensurate periods,  and additionally C and E must be symmetric. The resulting symmetric periodic solutions X and Y have the period  set to the least common commensurate period of A, C and E and the number of subperiods is adjusted accordingly. \n\nIf stability_check = true, the stability of characteristic multipliers of A is checked and an error is issued if any characteristic multiplier has modulus equal to or larger than one. \n\nThe periodic discrete analog of the Bartels-Stewart method based on the periodic Schur form of the periodic matrix A is employed [1].\n\nReference:\n\n[1] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.                Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.prdlyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.prdlyap","text":"prdlyap(A, C; stability_check = false) -> X\n\nSolve the reverse-time periodic discrete-time Lyapunov equation\n\nA'σXA + C = X\n\nwhere σ is the forward shift operator σX(i) = X(i+1).                 \n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods,  and additionally C must be symmetric. The resulting symmetric periodic solution X has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. \n\nIf stability_check = true, the stability of characteristic multipliers of A is checked and an error is issued if any characteristic multiplier has modulus equal to or larger than one. \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pfdlyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pfdlyap","text":"pfdlyap(A, C; stability_check = false) -> X\n\nSolve the forward-time periodic discrete-time Lyapunov equation\n\nAXA' + C = σX\n\nwhere σ is the forward shift operator σX(i) = X(i+1).                 \n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods,  and additionally C must be symmetric. The resulting symmetric periodic solution X has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly.  \n\nIf stability_check = true, the stability of characteristic multipliers of A is checked and an error is issued if any characteristic multiplier has modulus equal to or larger than one. \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pcplyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pcplyap","text":"pcplyap(A, C; K = 10, adj = false, solver, reltol, abstol) -> U\n\nCompute the upper triangular periodic factor U(t) of the solution X(t) = U(t)U(t)' of the  periodic Lyapunov differential equation\n\n.\nX(t) = A(t)X(t) + X(t)A(t)' + C(t)C(t)' , if adj = false,\n\nor of the solution X(t) = U(t)'U(t) of the periodic Lyapunov differential equation\n\n .\n-X(t) = A(t)'X(t) + X(t)A(t) + C(t)'C(t) , if adj = true.\n\nThe periodic matrices A and C must have the same type, commensurate periods and A must be stable. The resulting upper triangular periodic factor U has the type PeriodicFunctionMatrix and  U(t) can be used to evaluate the value of U at time t.  U has the period set to the least common commensurate period of A and C and  the number of subperiods is adjusted accordingly. \n\nAn extension of the multiple-shooting method of [1] is employed to convert the (continuous-time) periodic differential Lyapunov equation  into a discrete-time periodic Lyapunov equation satisfied by a multiple point generator of the solution.  The keyword argument K specifies the number of grid points to be used for the discretization of the continuous-time problem (default: K = 10).  If  A and C are of types PeriodicTimeSeriesMatrix or PeriodicSwitchingMatrix,  then K specifies the number of grid points used between two consecutive switching time values (default: K = 1).   The upper triangular factor of the multiple point generator is computed  by solving the appropriate discrete-time periodic Lyapunov  equation using the iterative method (Algorithm 5) of [2].  The resulting periodic generator is finally converted into  a periodic function matrix which determines for a given t  the function value U(t) by integrating the appropriate ODE from the nearest grid point value.    \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4) and   absolute accuracy abstol (default: abstol = 1.e-7) (see tvstm). \n\nTo speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument intpol = true (default: intpol = false).  In this case the interpolation method to be used can be specified via the keyword argument intpolmeth = meth. The allowable values for meth are: \"constant\", \"linear\", \"quadratic\" and \"cubic\" (default) (see also ts2pfm). Interpolation is not possible if A and C are of type PeriodicSwitchingMatrix. \n\nParallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.prcplyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.prcplyap","text":"prcplyap(A, C; K = 10, solver, reltol, abstol) -> U\n\nCompute the upper triangular periodic factor U(t) of the solution X(t) = U(t)'U(t)\n\n .\n-X(t) = A(t)'X(t) + X(t)A(t) + C(t)'C(t).\n\nThe periodic matrices A and C must have the same type, the same column dimensions and commensurate periods.  The resulting periodic factor U has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. \n\nThis function is merely an interface to pcplyap (see this function for the description of keyword parameters). \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pfcplyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pfcplyap","text":"pfcplyap(A, B; K = 10, solver, reltol, abstol) -> U\n\nCompute the upper triangular periodic factor U(t) of the solution X(t) = U(t)U(t)'\n\n.\nX(t) = A(t)X(t) + X(t)A(t)' + B(t)B(t)' .\n\nThe periodic matrices A and B must have the same type, the same row dimensions and commensurate periods.  The resulting periodic factor U has the period  set to the least common commensurate period of A and B and the number of subperiods is adjusted accordingly. \n\nThis function is merely an interface to pcplyap (see this function for the description of keyword parameters). \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pgcplyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pgcplyap","text":"pgcplyap(A, C[, K = 1]; adj = false, solver, reltol, abstol, dt) -> U\n\nCompute upper triangular periodic generators U(t) of the solution X(t) = U(t)U(t)' of the  periodic Lyapunov differential equation\n\n.\nX(t) = A(t)X(t) + X(t)A(t)' + C(t)C(t)' , if adj = false,\n\nor of the solution X(t) = U(t)'U(t) of the periodic Lyapunov differential equation\n\n .\n-X(t) = A(t)'X(t) + X(t)A(t) + C(t)'C(t) , if adj = true.\n\nThe periodic matrices A and C must have the same type, commensurate periods and A must be stable. The resulting U is a collection of periodic generator matrices determined  as a periodic time-series matrix with N components, where N = 1 if A and C are constant matrices and N = K otherwise.  The period of U is set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. Any component matrix of U is a valid initial value to be used to generate the   solution over a full period by integrating the appropriate differential equation.  An extension of the multiple-shooting method of [1] is employed, first, to convert the continuous-time periodic Lyapunov  into a discrete-time periodic Lyapunov equation satisfied by  the generator solution in K time grid points and then to compute the solution by solving an appropriate discrete-time periodic Lyapunov  equation using the iterative method (Algorithm 5) of [2]. \n\nThe ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\nFor large values of K, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\nReferences\n\n[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. \n\n[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.tvcplyap_eval","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.tvcplyap_eval","text":" tvcplyap_eval(t, U, A, C; adj = false, solver, reltol, abstol, dt) -> Uval\n\nCompute the time value Uval := U(t) of the upper triangular periodic generators  U(t) of the solution X(t) = U(t)U(t)' of the periodic Lyapunov differential equation\n\n  .\n  X(t) = A(t)X(t) + X(t)A(t)' + C(t)C(t)' , X(t0) = U(t0)U(t0)', t > t0, if adj = false,\n\nor of the solution X(t) = U(t)'U(t) of the periodic Lyapunov differential equation\n\n  .\n -X(t) = A(t)'X(t) + X(t)A(t) + C(t)'C(t) , X(t0) = U(t0)'U(t0), t < t0, if adj = true,\n\nusing the periodic generator U determined with the function pgcplyap for the same periodic matrices A and C and the same value of the keyword argument adj.  The initial time t0 is the nearest time grid value to t, from below, if adj = false, or from above, if adj = true. \n\nThe above ODE is solved by employing the integration method specified via the keyword argument solver,  together with the required relative accuracy reltol (default: reltol = 1.e-4),   absolute accuracy abstol (default: abstol = 1.e-7) and stepsize dt (default: dt = 0, only used if solver = \"symplectic\") (see tvstm). \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pdplyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pdplyap","text":"pdplyap(A, C; adj = true) -> U\n\nCompute the upper triangular factor U of the solution X = U'U of the  periodic discrete-time Lyapunov matrix equation\n\n  A'σXA + C'C = X, if adj = true,\n\nor of the solution X = UU' of the periodic discrete-time Lyapunov matrix equation\n\n  AXA' + CC' =  σX, if adj = false,\n\nwhere σ is the forward shift operator σX(i) = X(i+1).  The periodic matrix A must be stable, i.e., have all characteristic multipliers  with moduli less than one. \n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods.  The resulting upper triangular periodic matrix U has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly. \n\nThe iterative method (Algorithm 5) of [1] and its dual version are employed.  \n\nReference:\n\n[1] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.                Int. J. Control, vol, 67, pp, 69-87, 1997.\n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.prdplyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.prdplyap","text":"prdplyap(A, C) -> U\n\nCompute the upper triangular factor U of the solution X = U'*U of the  reverse time periodic discrete-time Lyapunov matrix equation\n\nA'σXA + C'C = X\n\nwhere σ is the forward shift operator σX(i) = X(i+1).  The periodic matrix A must be stable, i.e., have all characteristic multipliers  with moduli less than one. \n\nThe periodic matrices A and C must have the same type, the same dimensions and commensurate periods.  The resulting upper triangular periodic matrix U has the period  set to the least common commensurate period of A and C and the number of subperiods is adjusted accordingly.  \n\nNote: X is the observability Gramian of the periodic pair (A,C).              \n\n\n\n\n\n","category":"function"},{"location":"pslyap.html#PeriodicSystems.pfdplyap","page":"Periodic Lyapunov equation solvers","title":"PeriodicSystems.pfdplyap","text":"pfdplyap(A, B) -> U\n\nCompute the upper triangular factor U of the solution X = U*U' of the  forward-time periodic discrete-time Lyapunov equation\n\nAXA' + BB' = σX\n\nwhere σ is the forward shift operator σX(i) = X(i+1).   The periodic matrix A must be stable, i.e., have all characteristic multipliers  with moduli less than one. \n\nThe periodic matrices A and B must have the same type, the same dimensions and commensurate periods.  The resulting upper triangular periodic matrix U has the period  set to the least common commensurate period of A and B and the number of subperiods is adjusted accordingly.  \n\nNote: X is the reachability Gramian of the periodic pair (A,B).              \n\n\n\n\n\n","category":"function"},{"location":"pslifting.html#Conversions-to-LTI-representations","page":"Conversions to LTI representations","title":"Conversions to LTI representations","text":"","category":"section"},{"location":"pslifting.html","page":"Conversions to LTI representations","title":"Conversions to LTI representations","text":"psaverage  Computation of the averaged LTI system of a continuous-time periodic system.\npsteval  Computation of the time evaluated LTI system of a continuous-time periodic system.\nps2fls  Computation of a complex frequency-lifted LTI representation of a continuous-time periodic system. \nps2frls  Computation of a real frequency-lifted LTI representation of a continuous-time periodic system. \nps2ls  Computation of a time-lifted LTI representation of a discrete-time periodic system. \nps2spls  Computation of a sparse time-lifted LTI representation of a discrete-time periodic system. ","category":"page"},{"location":"pslifting.html","page":"Conversions to LTI representations","title":"Conversions to LTI representations","text":"psaverage\npsteval\nps2fls\nps2frls\nps2ls\nps2spls","category":"page"},{"location":"pslifting.html#PeriodicSystems.psaverage","page":"Conversions to LTI representations","title":"PeriodicSystems.psaverage","text":"psaverage(psysc) -> sys::DescriptorStateSpace\n\nCompute for the continuous-time periodic system psysc = (A(t),B(t),C(t),D(t))  the corresponding time averaged LTI system sys = (Am,Bm,Cm,Dm) over one period.  \n\n\n\n\n\n","category":"function"},{"location":"pslifting.html#PeriodicSystems.psteval","page":"Conversions to LTI representations","title":"PeriodicSystems.psteval","text":"psteval(psys,tval) -> sys::DescriptorStateSpace\n\nCompute for the periodic system psys = (A(t),B(t),C(t),D(t)) and a time value tval,  the LTI system sys = (A(tval),B(tval),C(tval),D(tval)). If A(tval) is not square, then  A(tval) is padded with zeros to form a square matrix and appropriate numbers of zero rows and zero columns are added to  B(tval) and C(tval), respectively. \n\n\n\n\n\n","category":"function"},{"location":"pslifting.html#PeriodicSystems.ps2fls","page":"Conversions to LTI representations","title":"PeriodicSystems.ps2fls","text":" ps2fls(psysc::PeriodicStateSpace, N; P) -> sys::DescriptorStateSpace\n\nBuild the frequency-lifted representation of a continuous-time periodic system.\n\nFor a continuos-time periodic system psysc = (A(t),B(t),C(t),D(t)), the (complex)  LTI state-space representation sys = (At-Nt,Bt,Ct,Dt) is built, where At, Bt, Ct and Dt  are truncated block Toeplitz matrices and Nt is a block diagonal matrix (see [1] or [2]).  N is the number of selected harmonic components in the Fourier series of system matrices  and the keyword parameter P is the number of full periods to be considered (default: P = 1). \n\nReferences\n\n[1] N. M. Wereley. Analysis and control of linear periodically time varying systems.      Ph.D. thesis, Department of Aeronautics and Astronautics, MIT, 1990.\n\n[2] S. Bittanti and P. Colaneri. Periodic Systems : Filtering and Control.     Springer-Verlag London, 2009. \n\n\n\n\n\n","category":"function"},{"location":"pslifting.html#PeriodicSystems.ps2frls","page":"Conversions to LTI representations","title":"PeriodicSystems.ps2frls","text":" ps2frls(psysc::PeriodicStateSpace, N) -> sys::DescriptorStateSpace\n\nBuild the real frequency-lifted representation of a continuous-time periodic system.\n\nFor a continuos-time periodic system psysc = (A(t),B(t),C(t),D(t)), the real  LTI state-space representation sys = (At-Nt,Bt,Ct,Dt) is built, where At, Bt, Ct and Dt  are truncated block Toeplitz matrices and Nt is a block diagonal matrix.  N is the number of selected harmonic components in the Fourier series of system matrices. \n\nNote: This is an experimental implementation based on the operator representation of periodic matrices in the ApproxFun.jl package. \n\n\n\n\n\n","category":"function"},{"location":"pslifting.html#PeriodicSystems.ps2ls","page":"Conversions to LTI representations","title":"PeriodicSystems.ps2ls","text":" ps2ls(psys::PeriodicStateSpace[, kstart]; ss = false, cyclic = false) -> sys::DescriptorStateSpace\n\nBuild the discrete-time lifted LTI system equivalent to a discrete-time periodic system. \n\nFor a discrete-time periodic system psys = (A(t),B(t),C(t),D(t)) with period T and sample time Ts,  the equivalent stacked (see [1]) LTI descriptor state-space representation  sys = (A-λE,B,C,D) is built, with the input, state and output vectors defined over time intervals of length T (instead Ts).   The optional argument kstart specifies a desired time to start the sequence of periodic matrices (default: kstart = 1).\n\nIf ss = true (default: ss = false), then all non-dynamic modes are elliminated and  a standard state-space realization (with E = I) is determined, which corresponds to the lifting techniques of [2], where only the input and output vectors are defined over time intervals of length T.  The determination of the standard lifted representation involves forming matrix products  (e.g., by explicitly forming the monodromy matrix) and therefore is potentially less suited for numerical computations.  \n\nIf cyclic = true, the cyclic reformulation of [3] is used to build a lifted standard system with  the input, state and output vectors defined over time intervals of length T.\n\nReferences\n\n[1] O. M. Grasselli and S. Longhi. Finite zero structure of linear periodic discrete-time systems.      Int. J. Systems Sci., 22:1785–1806,  1991.\n\n[2] R. A. Meyer and C. S. Burrus. A unified analysis of multirate and periodically time-varying     digital filters”, IEEE Transactions on Circuits and Systems, 22:162–167, 1975.\n\n[3] D. S. Flamm. A new shift-invariant representation for periodic systems,      Systems and Control Letters, 17:9–14, 1991.\n\n\n\n\n\n","category":"function"},{"location":"pslifting.html#PeriodicSystems.ps2spls","page":"Conversions to LTI representations","title":"PeriodicSystems.ps2spls","text":" ps2spls(psys::PeriodicStateSpace[, kstart]; cyclic = false) -> sys::DescriptorStateSpace\n\nBuild the discrete-time lifted LTI system equivalent to a discrete-time periodic system. \n\nFor a discrete-time periodic system psys = (A(t),B(t),C(t),D(t)) with period T and sample time Ts,  the equivalent stacked (see [1]) LTI descriptor state-space representation  sys = (As-λEs,Bs,Cs,Ds) is built, with the input, state and output vectors defined over time intervals of length T (instead Ts).   The optional argument kstart specifies a desired time to start the sequence of periodic matrices (default: kstart = 1). The matrices As, Es, Bs, Cs and Ds are sparce matrices as defined within the  SparseArrays.jl package. \n\nIf cyclic = true, the cyclic reformulation of [2] is used to build a lifted standard system with  the input, state and output vectors defined over time intervals of length T.\n\nReferences\n\n[1] O. M. Grasselli and S. Longhi. Finite zero structure of linear periodic discrete-time systems.      Int. J. Systems Sci., 22:1785–1806,  1991.\n\n[2] D. S. Flamm. A new shift-invariant representation for periodic systems,      Systems and Control Letters, 17:9–14, 1991.\n\n\n\n\n\n","category":"function"},{"location":"ps.html#Building-periodic-systems","page":"Building periodic systems","title":"Building periodic systems","text":"","category":"section"},{"location":"ps.html","page":"Building periodic systems","title":"Building periodic systems","text":"PeriodicStateSpace   Periodic state space system representation.\nps  Construction of periodic state-space models.\npsmrc2d  Discretization/resampling of a multirate LTI system. ","category":"page"},{"location":"ps.html","page":"Building periodic systems","title":"Building periodic systems","text":"PeriodicStateSpace\nps\npsmrc2d","category":"page"},{"location":"ps.html#PeriodicSystems.PeriodicStateSpace","page":"Building periodic systems","title":"PeriodicSystems.PeriodicStateSpace","text":"PeriodicStateSpace(A::PM, B::PM, C::PM, D::PM) -> psys::PeriodicStateSpace{PM}\n\nConstruct a PeriodicStateSpace object from a quadruple of periodic matrix objects. \n\nThe periodic matrix objects A, B, C, D specifies the periodic matrices A(t), B(t), C(t) and D(t) of a linear periodic time-varying state space model in the continuous-time form\n\n dx(t)/dt = A(t)x(t) + B(t)u(t) ,\n y(t)     = C(t)x(t) + D(t)u(t) ,\n\nor in the discrete-time form\n\n x(t+1)  = A(t)x(t) + B(t)u(t) ,\n y(t)    = C(t)x(t) + D(t)u(t) ,\n\nwhere x(t), u(t) and y(t) are the system state vector,  system input vector and system output vector, respectively,  and t is the continuous or discrete time variable.  The system matrices satisfy A(t) = A(t+T₁), B(t) = B(t+T₂), C(t) = C(t+T₃), D(t) = D(t+T₄),   i.e., are periodic with periods T₁, T₂, T₃ and T₄, respectively.  The different periods must be commensurate (i.e., their ratios must be rational numbers with numerators and denominators up to at most 4 decimal digits).  All periodic matrix objects must have the same type PM, where PM stays for one of the supported periodic matrix types, i.e.,  PeriodicMatrix, PeriodicArray, PeriodicFunctionMatrix, PeriodicSymbolicMatrix, HarmonicArray, FourierFunctionMatrix or PeriodicTimeSeriesMatrix. \n\n\n\n\n\n","category":"type"},{"location":"ps.html#PeriodicSystems.ps","page":"Building periodic systems","title":"PeriodicSystems.ps","text":"ps([PMT::Type,] A::PM1, B::PM2, C::PM3, D::PM4) -> psys::PeriodicStateSpace\n\nConstruct a PeriodicStateSpace object from a quadruple of periodic matrix objects. \n\nThe periodic matrix objects A, B, C, D specifies the periodic matrices A(t), B(t), C(t) and D(t) of a linear periodic time-varying state space model in the continuous-time form\n\n dx(t)/dt = A(t)x(t) + B(t)u(t) ,\n y(t)     = C(t)x(t) + D(t)u(t) ,\n\nor in the discrete-time form\n\n x(t+1)  = A(t)x(t) + B(t)u(t) ,\n y(t)    = C(t)x(t) + D(t)u(t) ,\n\nwhere x(t), u(t) and y(t) are the system state vector,  system input vector and system output vector, respectively,  and t is the continuous or discrete time variable.  The system matrices satisfy A(t) = A(t+T₁), B(t) = B(t+T₂), C(t) = C(t+T₃), D(t) = D(t+T₄),   i.e., are periodic with periods T₁, T₂, T₃ and T₄, respectively.  The different periods must be commensurate (i.e., their ratios must be rational numbers with numerators and denominators up to at most 4 decimal digits).  The periodic matrix objects A, B, C, D can have different types PM1, PM2, PM3, PM4, respectively, where for a contiuous-time system  PM1, PM2, PM3, PM4 must be one of the supported continuous-time periodic matrix types, i.e.,  PeriodicFunctionMatrix, PeriodicSymbolicMatrix, HarmonicArray, FourierFunctionMatrix or PeriodicTimeSeriesMatrix, while for a discrete-time system  PM1, PM2, PM3, PM4 must be one of the supported discrete-time periodic matrix types, i.e.,  PeriodicMatrix or PeriodicArray.   Any of the objects A, B, C, D can be also specified as a real matrix or vector of appropriate size. \n\nIf PMT is not specified, the resulting psys has periodic matrices of the same type PT, such that PT is either the common type of all matrix objects or PT = PeriodicFunctionMatrix for a continuous-time system or  PT = PeriodicMatrix for a discrete-time system.  If PMT is specified, the resulting psys has periodic matrices of the same type PMT. \n\nOther convenience constructors are implemented as follows: \n\nps([PMT::Type,] A, B, C) -> psys::PeriodicStateSpace\n\nto construct a PeriodicStateSpace object for a quadruple of the form (A,B,C,0);\n\nps(D) -> psys::PeriodicStateSpace\n\nto construct a PeriodicStateSpace object for a quadruple of the form ([],[],[],D);\n\nps([PMT::Type,] A, B, C, D, period) -> psys::PeriodicStateSpace\n\nto construct a PeriodicStateSpace object with a desired period for a quadruple (A,B,C,D); all objects A, B, C, D can be also specified as real matrices or vectors of appropriate sizes. \n\nps([PMT::Type,] A, B, C, period) -> psys::PeriodicStateSpace\n\nto construct a PeriodicStateSpace object with a desired period for a quadruple (A,B,C,0); all objects A, B, C can be also specified as real matrices or vectors of appropriate sizes. \n\nps(sys::DescriptorStateSpace, period) -> psys::PeriodicStateSpace\n\nto construct a PeriodicStateSpace object with a desired period for a quadruple (sys.A,sys.B,sys.C,sys.D) (sys.E = I is assumed).\n\n\n\n\n\n","category":"function"},{"location":"ps.html#PeriodicSystems.psmrc2d","page":"Building periodic systems","title":"PeriodicSystems.psmrc2d","text":" psmrc2d(sys, Ts; ki, ko) -> psys::PeriodicStateSpace{PeriodicMatrix}\n\nPerform the multirate discretization of a linear time-invariant system.\n\nFor a continuous-time state-space system sys = (A,B,C,D), a basic sampling time Ts,  and the integer vectors ki and ko containing, respectively, the numbers of  input and output sampling subperiods, the corresponding discretized  periodic system psys = (Ap,Bp,Cp,Dp) of period T = n*Ts is determined,  where n is the least common multiple of the integers contained in ki and ko. For a continuous-time system sys  a zero-order hold based discretization method is used, such that the i-th input  is constant during intervals of length ki[i]*Ts.  An output hold device is used to provide constant intersample outputs, such that the i-th output is constant during intervals of length ko[i]*Ts.  For a discrete-time system with a defined sample time Δ,  an input and output resampling is performed using Δ as basic   sample time and the value of Ts is ignored.  If the system sample time is not defined, then the value of Ts is used as the basic sample time. \n\n\n\n\n\n","category":"function"},{"location":"pstypes.html#Constructors-for-periodic-matrices","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"","category":"section"},{"location":"pstypes.html","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"PeriodicMatrix   Discrete-time periodic matrix representation.\nPeriodicArray    Discrete-time periodic array representation.\nSwitchingPeriodicMatrix Discrete-time switching periodic matrix representation.\nSwitchingPeriodicArray Discrete-time switching periodic array representation.\nPeriodicFunctionMatrix  Continuous-time periodic function matrix representation.\nPeriodicSymbolicMatrix   Continuous-time periodic symbolic matrix representation.\nPeriodicTimeSeriesMatrix   Continuous-time periodic time series matrix representation.\nHarmonicArray   Continuous-time harmonic array representation.\nFourierFunctionMatrix   Continuous-time Fourier functin matrix representation.\nPeriodicSwitchingMatrix Continuous-time switching periodic matrix representation.","category":"page"},{"location":"pstypes.html","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"PeriodicMatrix\nPeriodicArray\nSwitchingPeriodicMatrix\nSwitchingPeriodicArray\nPeriodicFunctionMatrix\nPeriodicSymbolicMatrix\nPeriodicTimeSeriesMatrix\nHarmonicArray\nHarmonicArray(A0::MT, Acos::Union{Nothing, Vector{MT}}, Asin::Union{Nothing, Vector{MT}}, period::Real) where {T<:Real, MT<:VecOrMat{T}} \nFourierFunctionMatrix\nPeriodicSwitchingMatrix","category":"page"},{"location":"pstypes.html#PeriodicSystems.PeriodicMatrix","page":"Constructors for periodic matrices","title":"PeriodicSystems.PeriodicMatrix","text":"PeriodicMatrix(M, T) -> A::PeriodicMatrix\n\nDiscrete-time periodic matrix representation. \n\nThe discrete-time periodic matrix object A is built from a  p-vector M of real matrices, the associated time period T and  the number of subperiods specified via the keyword argument nperiod = k. \n\nM contains the cyclic component matrices M[i], i = 1,..., p,  where M[i] represents the value M(Δ(i-1)) of a time periodic matrix M(t) of period T/k, with Δ := T/(kp), the associated sample time.  It is assumed that M[i] := M[mod(i-1,p)+1] for arbitrary i.  All component matrices are allowed to have arbitrary (time-varying) dimensions. The component matrices M, the period T, the number of subperiods k, the discrete period p  and the sample time Δ can be accessed via A.M, A.period, A.nperiod, A.dperiod and A.Ts, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.PeriodicArray","page":"Constructors for periodic matrices","title":"PeriodicSystems.PeriodicArray","text":"PeriodicArray(M, T; nperiod = k) -> A::PeriodicArray\n\nDiscrete-time periodic array representation.\n\nThe discrete-time periodic array object A is built from a m×n×p real array M, the associated time period T and the number of subperiods specified via  the keyword argument nperiod = k.  M contains the cyclic component matrices M[:,:,i], i = 1,..., p,  where M[:,:,i] represents the value M(Δ(i-1)) of a time periodic matrix M(t) of period T/k, with Δ := T/(kp), the associated sample time.  It is assumed that  M[:,:,k] := M[:,:,mod(k-1,p)+1] for arbitrary k.  The component matrices M, the period T, the number of subperiods k, the discrete period p  and the sample time Δ can be accessed via A.M, A.period, A.nperiod, A.dperiod and A.Ts, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.SwitchingPeriodicMatrix","page":"Constructors for periodic matrices","title":"PeriodicSystems.SwitchingPeriodicMatrix","text":"SwitchingPeriodicMatrix(M, ns, T; nperiod = k) -> A::SwitchingPeriodicMatrix\n\nDiscrete-time switching periodic matrix representation.\n\nThe discrete-time switching periodic matrix object A is built from a  p-vector M of real matrices, a p-vector ns of increasing positive integers representing the discrete switching moments,  the associated time period T and  the number of subperiods specified via the keyword argument nperiod = k. \n\nM contains the component matrices M[i], i = 1,..., p, which defines  a sequence of N := ns[p] of matrices S[1], ..., S[N],  such that S[j] = M[i] for j ∈ [ns[i-1]+1, ..., ns[i]] with ns[0] := 0. S[j] is the j-th value A(Δ(j-1)) of a time periodic matrix A(t) of subperiod T′ := T/k, with Δ := T′/N, the associated sample time.  All component matrices are allowed to have arbitrary (time-varying) dimensions. The component matrices M, the integer vector ns, the period T,  the number of subperiods k, the discrete period N  and the sample time Δ can be accessed via A.M, A.ns, A.period, A.nperiod, A.dperiod and A.Ts, respectively. \n\nThe j-th time value A(Δ(j-1)) can be determined as A[j].  It is assumed that A[j] := A[mod(j-1,N)+1] for arbitrary j. \n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.SwitchingPeriodicArray","page":"Constructors for periodic matrices","title":"PeriodicSystems.SwitchingPeriodicArray","text":"SwitchingPeriodicArray(M, ns, T; nperiod = k) -> A::SwitchingPeriodicArray\n\nDiscrete-time switching periodic array representation.\n\nThe discrete-time switching periodic array object A is built from a m×n×p real array M, a p-vector ns of increasing positive integers representing the discrete switching moments, the associated time period T and  the number of subperiods specified via the keyword argument nperiod = k. \n\nM contains the cyclic component matrices M[:,:,i], i = 1,..., p, which defines  a sequence of N := ns[p] of matrices S[1], ..., S[N],  such that S[j] =M[:,:,i]forj ∈ [ns[i-1]+1, ..., ns[i]]withns[0] := 0.S[j]is thej-th valueA(Δ(j-1))of a time periodic matrixA(t)of subperiodT′ := T/k, withΔ := T′/N, the associated sample time.  The component matricesM, the integer vectorns, the periodT,  the number of subperiodsk, the discrete periodNand the sample timeΔcan be accessed viaA.M,A.ns,A.period,A.nperiod,A.dperiodandA.Ts`, respectively. \n\nThe j-th time value A(Δ(j-1)) can be determined as A[j].  It is assumed that A[j] := A[mod(j-1,N)+1] for arbitrary j. \n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.PeriodicFunctionMatrix","page":"Constructors for periodic matrices","title":"PeriodicSystems.PeriodicFunctionMatrix","text":"PeriodicFunctionMatrix(f, T; nperiod = k) -> A::PeriodicFunctionMatrix\n\nContinuous-time periodic function matrix representation.\n\nThe continuous-time periodic function matrix object A is built from a  time periodic real matrix function f(t) of real time variable t,  the associated time period T and the associated number of subperiods specified via the keyword argument nperiod = k.  It is assumed that  f(t) = f(t+T/k) for any real time value t. The function f(t), the period T, the row and column dimensions  of f(t), the number of subperiods k can be accessed via A.f, A.period,  the tuple A.dims and A.nperiod, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.PeriodicSymbolicMatrix","page":"Constructors for periodic matrices","title":"PeriodicSystems.PeriodicSymbolicMatrix","text":"PeriodicSymbolicMatrix(F, T; nperiod = k) -> A::PeriodicSymbolicMatrix\n\nContinuous-time periodic symbolic matrix representation.\n\nThe continuous-time periodic symbolic matrix object A is built from F, a  symbolic periodic real matrix or vector of symbolic variable t,  the associated time period T and the associated number of subperiods specified via the keyword argument nperiod = k.  It is assumed that  F(t) = F(t+T/k) for any real time value t. The symbolic matrix F, the period T and the number of subperiods k  can be accessed via A.F, A.period and A.nperiod, respectively.\n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.PeriodicTimeSeriesMatrix","page":"Constructors for periodic matrices","title":"PeriodicSystems.PeriodicTimeSeriesMatrix","text":"PeriodicTimeSeriesMatrix(At, T; nperiod = k) -> A::PeriodicTimeSeriesMatrix\n\nContinuous-time periodic time series matrix representation.\n\nThe continuous-time periodic time series matrix object A of period T is built from a  p-vector At of real matrices and the associated subperiod T′ = T/k, where k ≥ 1 is the number of subperiods (default: k = 1).  At contains the cyclic component matrices At[i], i = 1,..., p,  where At[i] represents the value A(Δ*(i-1)) of a time periodic matrix A(t) of period T′, with Δ := T′/p, the associated sampling time. It is assumed that At[i] := At[mod(i-1,p)+1] for arbitrary i.  All component matrices must have the same dimensions. The component matrices At, the period T and the number of subperiods k can be accessed via A.values, A.period, and A.nperiod, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.HarmonicArray","page":"Constructors for periodic matrices","title":"PeriodicSystems.HarmonicArray","text":" HarmonicArray(Ahr, T; nperiod = k) -> A::HarmonicArray\n\nContinuous-time harmonic array representation.\n\nThe harmonic array object A of period T is built using the harmonic representation of a periodic matrix Ahr(t) of subperiod T′ = T/k in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T′)+As_i*sin(i*2*π*t/T′) ) ,\n                i=1\n\nwhere k ≥ 1 is the number of subperiods (default: k = 1).                    The m×n×(p+1) complex array Ahr contains the harmonic components as follows: Ahr[:,:,1] contains the constant term A_0 (the mean value) and the real and imaginary parts of Ahr[:,:,i+1]   for i = 1, ..., p contain the coefficient matrices Ac_i and As_i, respectively.  The complex matrix Ahr containing the harmonic components, the period T and the  number of subperiods k can be accessed via A.values, A.period and A.nperiod, respectively.\n\n\n\n\n\n HarmonicArray(A0, Ac, As, T) -> A::HarmonicArray\n\nConstruct a harmonic array representation from the harmonic components.\n\nThe harmonic array object A is built for  the harmonic representation Ahr(t) of a periodic matrix of period T in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T)+As_i*sin(i*2*π*t/T) ) ,\n                i=1\n\nwhere the constant term A_0 is contained in the real matrix A0, and Ac and As are vectors of real matrices such that the i-th (cosinus) coefficient matrix  Ac_i is contained in Ac[i] and the i-th (sinus) coefficient matrix  As_i is contained in As[i]. p is the maximum of length of the vectors of matrices Ac and As.  If the length of Ac or As is less than p, then zero trailing matrices are assumed in the respective matrix.  All component matrices must have the same dimensions. The complex matrix containing the harmonic components and the period T  can be accessed via A.values and A.period, respectively.\n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.HarmonicArray-Union{Tuple{MT}, Tuple{T}, Tuple{MT, Union{Nothing, Vector{MT}}, Union{Nothing, Vector{MT}}, Real}} where {T<:Real, MT<:VecOrMat{T}}","page":"Constructors for periodic matrices","title":"PeriodicSystems.HarmonicArray","text":" HarmonicArray(A0, Ac, As, T) -> A::HarmonicArray\n\nConstruct a harmonic array representation from the harmonic components.\n\nThe harmonic array object A is built for  the harmonic representation Ahr(t) of a periodic matrix of period T in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T)+As_i*sin(i*2*π*t/T) ) ,\n                i=1\n\nwhere the constant term A_0 is contained in the real matrix A0, and Ac and As are vectors of real matrices such that the i-th (cosinus) coefficient matrix  Ac_i is contained in Ac[i] and the i-th (sinus) coefficient matrix  As_i is contained in As[i]. p is the maximum of length of the vectors of matrices Ac and As.  If the length of Ac or As is less than p, then zero trailing matrices are assumed in the respective matrix.  All component matrices must have the same dimensions. The complex matrix containing the harmonic components and the period T  can be accessed via A.values and A.period, respectively.\n\n\n\n\n\n","category":"method"},{"location":"pstypes.html#PeriodicSystems.FourierFunctionMatrix","page":"Constructors for periodic matrices","title":"PeriodicSystems.FourierFunctionMatrix","text":" FourierFunctionMatrix(Afun, T) -> A::FourierFunctionMatrix\n\nContinuous-time Fourier function matrix representation.\n\nThe Fourier function matrix object A of period T is built using the Fourier series representation of a periodic matrix Afun(t) of subperiod T′ = T/k,  where each entry of Afun(t) has the form\n\n         p\n  a_0 +  ∑ ( ac_i*cos(i*t*2*π/T′)+as_i*sin(i*2*π*t/T′) ) ,\n        i=1\n\nwhere k ≥ 1 is the number of subperiods (default: k = 1).    The matrix Afun containing the Fourier representation, the period T and the  number of subperiods k can be accessed via A.M, A.period and A.nperiod, respectively.\n\n\n\n\n\n","category":"type"},{"location":"pstypes.html#PeriodicSystems.PeriodicSwitchingMatrix","page":"Constructors for periodic matrices","title":"PeriodicSystems.PeriodicSwitchingMatrix","text":"PeriodicSwitchingMatrix(At, ts, T; nperiod = k) -> A::PeriodicSwitchingMatrix\n\nContinuous-time periodic switching matrix representation.\n\nThe continuous-time periodic switching matrix object A of period T is built from a  p-vector At of real matrices, a p-vector ts of increasingly ordered switching time values with ts[1] = 0, and  the associated subperiod T′ = T/k, where k ≥ 1 is the number of subperiods (default: k = 1).  At contains the cyclic component matrices At[i], i = 1,..., p,  where At[i] is the constant value of a time periodic matrix A(t) of period T′ for t ∈ [ts[i],ts[i+1]), if i < p, or t ∈ [ts[i],T′), if i = p.  It is assumed that At[i] := At[mod(i-1,p)+1] and ts[i] := ts[mod(i-1,p)+1] for arbitrary i.  All component matrices must have the same dimensions. The component matrices At, the switching times ts, the period T and the number of subperiods k can be accessed via A.values, A.ts, A.period, and A.nperiod, respectively. \n\n\n\n\n\n","category":"type"},{"location":"psconv.html#Periodic-matrix-conversions","page":"Periodic matrix conversions","title":"Periodic matrix conversions","text":"","category":"section"},{"location":"psconv.html","page":"Periodic matrix conversions","title":"Periodic matrix conversions","text":"ts2hr   Conversion of  a periodic time series matrix to a harmonic array approximation.\npfm2hr  Conversion of  a periodic function matrix to a harmonic array representation. \nts2pfm  Conversion of  an interpolated periodic time series matrix to a periodic function matrix.\nhr2psm  Conversion of  a harmonic array representation to a periodic symbolic matrix.\npsm2hr  Conversion of  a periodic symbolic matrix into a harmonic array representation.\npm2pa   Conversion of  a discrete-time periodic matrix object to a periodic array object.\nffm2hr  Conversion of  a Fourier function matrix to a harmonic array representation. \nhr2bt   Building a block Toeplitz matrix approximation of a harmonic (Fourier) array representation. \nhr2btupd  Building an updated block Toeplitz matrix approximation of a harmonic (Fourier) array representation. ","category":"page"},{"location":"psconv.html","page":"Periodic matrix conversions","title":"Periodic matrix conversions","text":"ts2hr\npfm2hr\nts2pfm\nhr2psm\npsm2hr\npm2pa\nffm2hr\nhr2bt\nhr2btupd","category":"page"},{"location":"psconv.html#PeriodicSystems.ts2hr","page":"Periodic matrix conversions","title":"PeriodicSystems.ts2hr","text":" ts2hr(A::PeriodicTimeSeriesMatrix; atol = 0, rtol, n, squeeze = true) -> Ahr::HarmonicArray\n\nCompute the harmonic (Fourier) approximation of a periodic matrix specified by a time series matrix.  The periodic matrix A(t) is specified as a continuous-time periodic time series matrix A,  with m matrices contained in the vector of matrices A.values, where A.values[k]  is the value of A(t) at time moment (k-1)T/m, with T = A.period being the period.  The resulting harmonic approximation Ahr(t) of A(t) has the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T)+As_i*sin(i*2*π*t/T) ) \n                i=1\n\nwhere A_0 is the constant term (the mean value), Ac_i and As_i are the   coefficient matrices of the i-th cosinus and sinus terms, respectively.  The order of the approximation p is determined using the maximum order specified by n  (default: n = (m-1)/2) and the absolute and relative tolerances atol and rtol, as follows: p is the minimum between n, (m-1)/2 and the maximum index k  such that Ac_k and/or As_k are nonzero. The tolerance used to assess nonzero elements is tol = max(atol, rtol*maxnorm), where  maxnorm is the maximum norm of the matrices contained in A.values. The default values of tolerances are atol = 0 and rtol = 10*p*ϵ, where ϵ is the working machine precision.\n\nThe resulting harmonic approximation Ahr(t) is returned in the harmonic array object Ahr  (see HarmonicArray). \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.pfm2hr","page":"Periodic matrix conversions","title":"PeriodicSystems.pfm2hr","text":" pfm2hr(A::PeriodicFunctionMatrix; nsample, NyquistFreq) -> Ahr::HarmonicArray\n\nConvert a periodic function matrix into a harmonic array representation.  If A(t) is a periodic function matrix of period T, then the harmonic array representation Ahr is determined by applying the fast Fourier transform to the sampled arrays A(iΔ), i = 0, ..., k, where Δ = T/k is the sampling period and k is the number of samples specified by the keyword argument nsample = k (default: k = 128). If the Nyquist frequency f is specified via the keyword argument NyquistFreq = f, then k is chosen k = 2*f*T to avoid signal aliasing.     \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.ts2pfm","page":"Periodic matrix conversions","title":"PeriodicSystems.ts2pfm","text":" ts2pfm(At::PeriodicTimeSeriesMatrix; method = \"linear\") -> A::PeriodicFunctionMatrix\n\nCompute the periodic function matrix corresponding to an interpolated periodic time series matrix.  For the given periodic time series matrix At, a periodic function matrix A(t) is defined as the  mapping A(t) = t -> etpf(t), where etpf(t) is a periodic interpolation/extrapolation object,   as provided in the Interpolations.jl  package.  The keyword parameter method specifies the interpolation/extrapolation method to be used as follows:\n\nmethod = \"constant\" - use periodic B-splines of degree 0 (periodic constant interpolation);\n\nmethod = \"linear\" - use periodic B-splines of degree 1 (periodic linear interpolation) (default);\n\nmethod = \"quadratic\" - use periodic B-splines of degree 2 (periodic quadratic interpolation); \n\nmethod = \"cubic\" - use periodic B-splines of degree 3 (periodic cubic interpolation). \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.hr2psm","page":"Periodic matrix conversions","title":"PeriodicSystems.hr2psm","text":" hr2psm(Ahr::HarmonicArray, nrange) -> A::Matrix{Num}\n\nConvert a range of harmonic components nrange of the harmonic array Ahr to a symbolic matrix A.  The default range is nrange = 0:n, where n is the order of the maximum harmonics.  \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.psm2hr","page":"Periodic matrix conversions","title":"PeriodicSystems.psm2hr","text":" psm2hr(A::PeriodicSymbolicMatrix; nsample, NyquistFreq) -> Ahr::HarmonicArray\n\nConvert a periodic symbolic matrix into a harmonic array representation.  If A(t) is a periodic symbolic matrix of period T, then the harmonic array representation Ahr is determined by applying the fast Fourier transform to the sampled arrays A(iΔ), i = 0, ..., k, where Δ = T/k is the sampling period and k is the number of samples specified by the keyword argument nsample = k (default: k = 128). If the Nyquist frequency f is specified via the keyword argument NyquistFreq = f, then k is chosen k = 2*f*T to avoid signal aliasing.     \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.pm2pa","page":"Periodic matrix conversions","title":"PeriodicSystems.pm2pa","text":" pm2pa(At::PeriodicMatrix) -> A::PeriodicArray\n\nConvert a discrete-time periodic matrix object into a discrete-time periodic array object.\n\nThe discrete-time periodic matrix object At contains a   p-vector At of real matrices At[i], i = 1,..., p,  the associated time period T and the number of subperiods k. The resulting discrete-time periodic array object A of period T and number of subperiods k  is built from a m×n×p real array A, such that A[:,:,i]  contains At[i], for i = 1,..., p.  For non-constant dimensions, the resulting m and n are the maximum row and column dimensions, respectively, and the resulting component matrices A[:,:,i] contain At[i], appropriately padded with zero entries. \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.ffm2hr","page":"Periodic matrix conversions","title":"PeriodicSystems.ffm2hr","text":" ffm2hr(Afun::FourierFunctionMatrix; atol = 0, rtol = √ϵ, squeeze = true) -> Ahr::HarmonicArray\n\nCompute the harmonic (Fourier) representation of a Fourier periodic matrix object. \n\nThe Fourier function matrix object Afun of period T is built using the Fourier series representation of a periodic matrix Afun(t) of subperiod T′ = T/k,  where each entry of Afun(t) has the form\n\n         p\n  a_0 +  ∑ ( ac_i*cos(i*t*2*π/T′)+as_i*sin(i*2*π*t/T′) ) ,\n        i=1\n\nwhere k ≥ 1 is the number of subperiods (default: k = 1).   \n\nThe harmonic array object Ahr of period T is built using the harmonic representation of a periodic matrix Ahr(t) of subperiod T′′ = T/k′ in the form\n\n                 p′\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T′′)+As_i*sin(i*2*π*t/T′′) ) ,\n                i=1\n\nwhere p′ is the maximum index j, such that Ac_j and/or As_j are nonzero. The tolerance used to assess nonzero elements is tol = max(atol, rtol*maxnorm), where  maxnorm is the maximum absolute value of the coefficients ac_i and as_i in Afun(t). The default values of tolerances are atol = 0 and rtol = √ϵ, where ϵ is the working machine precision. The resulting harmonic approximation Ahr(t) is returned in the harmonic array object Ahr  (see HarmonicArray). \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.hr2bt","page":"Periodic matrix conversions","title":"PeriodicSystems.hr2bt","text":" hr2bt(Ahr::HarmonicArray, N; P, nperiod]) -> Abt::Matrix\n\nBuild the block Toeplitz matrix of a harmonic (Fourier) array representation of a periodic matrix. \n\nThe harmonic representation object Ahr of period T of a periodic matrix Ahr(t)  of subperiod T′ = T/k is in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T′)+As_i*sin(i*2*π*t/T′) ) ,\n                i=1\n\nwhere k ≥ 1 is the number of subperiods. Ahr(t) can be equivalently expressed in the Fourier series representation form\n\n            p\n Ahr(t) =   ∑ A_i*exp(im*i*ωh*t) ,\n           i=-p\n\nwhere ωh = 2π/T′, A_i = (Ac_i-im*As_i)/2 and  A_{-i} = (Ac_i+im*As_i)/2.  N is the number of selected harmonic components (or Fourier modes) used for approximation.  The keyword parameter P is the number of full periods to be considered (default: P = 1) and nperiod is the number of subperiods to be considered, such that 1 ≤ nperiod ≤ k (default: nperiod = k). \n\nFor a given number N ≥ p, if the number of period is P = 1 and the number of subperiods is nperiod = 1,  then the banded block Toeplitz matrix Abt with (2N+1)×(2N+1) blocks is constructed\n\n       ( A_0  A_{-1} …  A_{-p}        0    )\n       ( A_1   A_0             ⋱           )\n       (  ⋮         ⋱            ⋱         )\n Abt = ( A_p             ⋱          A_{-p} )\n       (        ⋱           ⋱         ⋮    )\n       (  0        A_p      …         A_0  )\n\nIf N < p, then a truncated full block Toeplitz matrix is built using the first N harmonic components. \n\nGenerally, for given P ≥ 1 and  nperiod ≥ 1, the block Toeplitz matrix Abt is constructed with (2N*np+1)×(2N*np+1) blocks, with np = P*nperiod, such that each A_i is preceeded in its column by np-1 zero blocks,  each A_{-i} is preceeded in its row by np-1 zero blocks and all diagonal blocks are equal toA_0.   \n\n\n\n\n\n","category":"function"},{"location":"psconv.html#PeriodicSystems.hr2btupd","page":"Periodic matrix conversions","title":"PeriodicSystems.hr2btupd","text":" hr2btupd(Ahr::HarmonicArray, N; P, nperiod, shift]) -> Ab::Matrix\n\nBuild the updated block Toeplitz matrix of a harmonic (Fourier) array representation of a periodic matrix. \n\nIf BT is the block Toeplitz matrix of the harmonic array representation of the n × n periodic matrix Ahr of subperiod T′  (see HarmonicArray) as constructed with hr2bt, then the updated matrix Ab = BT-NT is constructed,  with NT a block-diagonal matrix with n × n diagonal blocks. The k-th diagonal block of NT is the diagonal matrix im*(μ + k*ωh)*I, where μ is a shift specified via  the keyword parameter shift = μ (default: μ = 0)  and ωh is the base frequency computed as ωh = 2π*nperiod/(P*T′).  The value of shift must satisfy 0 ≤ μ ≤ ωh/2. \n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = PeriodicSystems\nDocTestSetup = quote\n    using PeriodicSystems\nend","category":"page"},{"location":"index.html#PeriodicSystems.jl","page":"Home","title":"PeriodicSystems.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"PeriodicSystems.jl is intended to be a collection of Julia functions for numerical computations related to periodic system representations in the continuous-time form","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":" dx(t)/dt = A(t)x(t) + B(t)u(t) ,\n y(t)     = C(t)x(t) + D(t)u(t) ,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"or in the discrete-time form","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":" x(t+1)  = A(t)x(t) + B(t)u(t) ,\n y(t)    = C(t)x(t) + D(t)u(t) ,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"where x(t), u(t) and y(t) are the system state vector, system input vector and system output vector, respectively, and t is the continuous or discrete time variable. The system matrices satisfy A(t) = A(t+T), B(t) = B(t+T), C(t) = C(t+T), D(t) = D(t+T),  i.e., are periodic with period T. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Many control applications are formulated as genuine periodic control problems as for example, satellite attitude control, helicopter forward flight control, orbital stabilization of underactuated systems, etc. Besides that, periodic systems represent a general framework to analyze and design multi-rate sampled-data systems. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The targeted functionality of this package is described in [1] and will cover both continuous-time and discrete-time periodic systems. The following categories of functions are currently implemented:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Building periodic system state-space models","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"PeriodicStateSpace   Periodic state space system representation.\nps  Construction of periodic state-space models.\npsmrc2d  Discretization/resampling of a multirate LTI system. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Basic connections and operations","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"psparallel Parallel connection of periodic systems.\npsseries   Series connection of periodic systems.\npsappend   Appending of periodic systems.\npshorzcat  Horizontal concatenation of periodic systems.\npsvertcat  Vertical concatenation of periodic systems.\npsfeedback  Periodic output feedback connection.\npssfeedback  Periodic state feedback connection.\npssofeedback  Periodic state feedback with state estimator connection.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Discretization of continuous-time periodic systems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"psc2d  Discretization of a continuous-time periodic system. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Conversions to LTI representations","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"psaverage  Computation of the averaged LTI system of a continuous-time periodic system.\npsteval  Computation of the time evaluated LTI system of a continuous-time periodic system.\nps2fls  Computation of a complex frequency-lifted LTI representation of a continuous-time periodic system. \nps2frls  Computation of a real frequency-lifted LTI representation of a continuous-time periodic system. \nps2ls  Computation of a time-lifted LTI representation of a discrete-time periodic system. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic system analysis","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pspole  Computation of the poles of a periodic system.\npszero  Computation of the zeros of a periodic system.\nisstable  Assessment of stability of a periodic system.\npshanorm  Evaluation of the Hankel-norm of a periodic system.\npsh2norm  Evaluation of the H2-norm of a periodic system.\npslinfnorm  Evaluation of the L∞/H∞-norm of a periodic system.\npstimeresp  Time response of a periodic system.\npsstepresp  Step response of a periodic system.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solving periodic Lyapunov equations","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pclyap Solution of periodic Lyapunov differential equations. \nprclyap Solution of reverse-time periodic Lyapunov differential equations. \npfclyap  Solution of forward-time periodic Lyapunov differential equations.\npgclyap Computation of periodic generators for periodic Lyapunov differential equations.\npdlyap Solution of periodic discrete-time Lyapunov equations. \npdlyap2 Solution of a pair of periodic discrete-time Lyapunov equations. \nprdlyap Solution of reverse-time periodic discrete-time Lyapunov equations. \npfdlyap  Solution of forward-time periodic discrete-time Lyapunov equations.\npcplyap Solution of positve periodic Lyapunov differential equations. \nprcplyap Solution of positve reverse-time periodic Lyapunov differential equations.\npfcplyap  Solution of positve forward-time periodic Lyapunov differential equations.\npdplyap Solution of positve periodic discrete-time Lyapunov equations. \nprdplyap Solution of positve reverse-time periodic discrete-time Lyapunov equations. \npfdplyap  Solution of positve forward-time periodic discrete-time Lyapunov equations.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solving periodic Riccati equations","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pcric Solution of periodic Riccati differential equations. \nprcric Solution of control-related reverse-time periodic Riccati differential equation. \npfcric  Solution of filtering-related forward-time periodic Riccati differential equation.\npgcric Computation of periodic generators for periodic Riccati differential equations.\nprdric Solution of control-related reverse-time periodic Riccati difference equation. \npfdric Solution of filtering-related forward-time periodic Riccati difference equation. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Simplification of periodic system models","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic state feedback controller and estimator design ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pclqr  LQ-optimal state feedack stabilization of continuous-time periodic systems. \npclqry LQ-optimal state feedack stabilization with output weighting of continuous-time periodic systems. \npdlqr  LQ-optimal state feedack stabilization of discrete-time periodic systems. \npdlqry LQ-optimal state feedack stabilization with output weighting of discrete-time periodic systems. \npckeg  Kalman estimator gain matrix for continuous-time periodic systems. \npckegw  Kalman estimator gain matrix for continuous-time periodic systems with noise inputs.\npdkeg  Kalman estimator gain matrix for periodic systems. \npdkegw  Kalman estimator gain matrix for periodic systems with noise inputs.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic output feedback controller design ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pcpofstab_sw Stabilization of continuous-time periodic systems using switching periodic output feedback.\npcpofstab_hr Stabilization of continuous-time periodic systems using harmonic output feedback.\npdpofstab_sw Stabilization of discrete-time periodic systems using switching periodic output feedback.\npdpofstab_hr Stabilization of discrete-time periodic systems using discretized harmonic periodic output feedback.\npclqofc_sw LQ-optimal stabilization of continuous-time periodic systems using switching periodic output feedback.\npclqofc_hr LQ-optimal stabilization of continuous-time periodic systems using harmonic output feedback.\npdlqofc LQ-optimal stabilization of discrete-time periodic systems using periodic output feedback.\npdlqofc_sw LQ-optimal stabilization of discrete-time periodic systems using switching periodic output feedback.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic Schur decompositions","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"phess  Periodic Hessenberg decomposition of a product of matrices.\npschur  Periodic Schur decompositions of products or quotient products of matrices. \npsordschur!  Reordering of periodic Schur decompositions of products or quotient products of matrices.\npsordschur1!  Reordering of periodic Schur decompositions of products or quotient products of square matrices.\npgschur  Generalized real periodic Schur decomposition of a formal product of matrices.\npgschur  Generalized real periodic Schur decomposition of a formal product of matrices.\npgschur!  Generalized real periodic Schur decompositions of formal products of matrices (in place computation).\npgschur  Generalized real periodic Schur decompositions of formal products of matrices.\npgordschur!  Reordering of generalized real periodic Schur decompositions a formal products of matrices.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/PeriodicSystems.jl/blob/master/ReleaseNotes.md)","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"[1] A. Varga. A Periodic Systems Toolbox for Matlab. Proc. of IFAC 2005 World Congress, Prague, Czech Republic, 2005.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[2] S. Bittanti and P. Colaneri. Periodic Systems - Filtering and Control, Springer Verlag, 2009.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[4]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"}]
}
