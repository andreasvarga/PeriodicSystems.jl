<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Periodic Riccati equation solvers · PeriodicSystems.jl</title><meta name="title" content="Periodic Riccati equation solvers · PeriodicSystems.jl"/><meta property="og:title" content="Periodic Riccati equation solvers · PeriodicSystems.jl"/><meta property="twitter:title" content="Periodic Riccati equation solvers · PeriodicSystems.jl"/><meta name="description" content="Documentation for PeriodicSystems.jl."/><meta property="og:description" content="Documentation for PeriodicSystems.jl."/><meta property="twitter:description" content="Documentation for PeriodicSystems.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PeriodicSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Data Types and Constructors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ps.html">Building periodic systems</a></li></ul></li><li><a class="tocitem" href="psconnect.html">Basic connections and operations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Basic conversions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="psconversions.html">Discretization of continuous-time periodic systems</a></li><li><a class="tocitem" href="pslifting.html">Conversions to LTI representations</a></li></ul></li><li><a class="tocitem" href="psanalysis.html">Analysis of periodic systems</a></li><li><a class="tocitem" href="pslyap.html">Periodic Lyapunov equation solvers</a></li><li class="is-active"><a class="tocitem" href="psric.html">Periodic Riccati equation solvers</a></li><li><a class="tocitem" href="psstab.html">Stabilization of periodic systems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="pstools.html">Periodic system utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="psric.html">Periodic Riccati equation solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="psric.html">Periodic Riccati equation solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andreasvarga/PeriodicSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/master/docs/src/psric.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Periodic-Riccati-equation-solvers"><a class="docs-heading-anchor" href="#Periodic-Riccati-equation-solvers">Periodic Riccati equation solvers</a><a id="Periodic-Riccati-equation-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-Riccati-equation-solvers" title="Permalink"></a></h1><ul><li><strong><a href="psric.html#PeriodicSystems.pcric"><code>pcric</code></a></strong> Solution of periodic Riccati differential equations. </li><li><strong><a href="psric.html#PeriodicSystems.pgcric"><code>pgcric</code></a></strong> Computation of periodic generators for periodic Riccati differential equations.</li><li><strong><a href="psric.html#PeriodicSystems.tvcric_eval"><code>tvcric_eval</code></a></strong> Evaluation of time value of solution from the computed periodic generator.</li><li><strong><a href="psric.html#PeriodicSystems.prcric"><code>prcric</code></a></strong> Solution of control-related reverse-time periodic Riccati differential equation. </li><li><strong><a href="psric.html#PeriodicSystems.pfcric"><code>pfcric</code></a></strong>  Solution of filtering-related forward-time periodic Riccati differential equation.</li><li><strong><a href="psric.html#PeriodicSystems.prdric"><code>prdric</code></a></strong> Solution of control-related reverse-time periodic Riccati difference equation. </li><li><strong><a href="psric.html#PeriodicSystems.pfdric"><code>pfdric</code></a></strong> Solution of filtering-related forward-time periodic Riccati difference equation. </li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pcric" href="#PeriodicSystems.pcric"><code>PeriodicSystems.pcric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcric(A, R, Q; K = 10, adj = false, solver, reltol, abstol, fast, intpol, intpolmeth) -&gt; (X, EVALS)</code></pre><p>Solve the periodic Riccati differential equation</p><pre><code class="nohighlight hljs">.                                                 
X(t) = A(t)X(t) + X(t)A(t)&#39; + Q(t) - X(t)R(t)X(t) ,  if adj = false,</code></pre><p>or </p><pre><code class="nohighlight hljs"> .                                                
-X(t) = A(t)&#39;X(t) + X(t)A(t) + Q(t) - X(t)R(t)X(t) , if adj = true</code></pre><p>and compute the stable closed-loop characteristic multipliers in <code>EVALS</code> (see <a href="psric.html#PeriodicSystems.pgcric"><code>pgcric</code></a> for details).</p><p>The periodic matrices <code>A</code>, <code>R</code> and <code>Q</code> must have the same type, the same dimensions and commensurate periods,  and additionally <code>R</code> and <code>Q</code> must be symmetric. The resulting symmetric periodic solution <code>X</code> has the type <code>PeriodicFunctionMatrix</code> and  <code>X(t)</code> can be used to evaluate the value of <code>X</code> at time <code>t</code>.  <code>X</code> has the period set to the least common commensurate period of <code>A</code>, <code>R</code> and <code>Q</code> and  the number of subperiods is adjusted accordingly.  <em>Note:</em> Presently the <code>PeriodicSwitchingMatrix</code> type is not supported. </p><p>If <code>fast = true</code> (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in <code>t = 0</code> and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If <code>fast = false</code>, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). </p><p>The keyword argument <code>K</code> specifies the number of grid points to be used for the resulting multiple point periodic generator (default: <code>K = 10</code>).  The obtained periodic generator is finally converted into a periodic function matrix which determines for a given <code>t</code>  the function value <code>X(t)</code> by integrating the appropriate ODE from the nearest grid point value. </p><p>To speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument <code>intpol = true</code> (default: <code>intpol = true</code> if <code>solver = &quot;symplectic&quot;</code>, otherwise <code>intpol = false</code>).  In this case the interpolation method to be used can be specified via the keyword argument <code>intpolmeth = meth</code>. The allowable values for <code>meth</code> are: <code>&quot;constant&quot;</code>, <code>&quot;linear&quot;</code>, <code>&quot;quadratic&quot;</code> and <code>&quot;cubic&quot;</code> (default).</p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>, together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>) and  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>For large values of <code>K</code>, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable.  </p><p><em>References</em></p><p>[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. </p><p>[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/pscric.jl#L1-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pgcric" href="#PeriodicSystems.pgcric"><code>PeriodicSystems.pgcric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pgcric(A, R, Q[, K = 1]; adj = false, solver, reltol, abstol, fast, PSD_SLICOT) -&gt; (X, EVALS)</code></pre><p>Compute periodic generators for the periodic Riccati differential equation in the <em>filtering</em> form</p><pre><code class="nohighlight hljs">.                                                  
X(t) = A(t)X(t) + X(t)A(t)&#39; + Q(t) - X(t)R(t)X(t), if adj = false,</code></pre><p>or in the <em>control</em> form</p><pre><code class="nohighlight hljs"> .                                              
-X(t) = A(t)&#39;X(t) + X(t)A(t) + Q(t) - X(t)R(t)X(t) , if adj = true,</code></pre><p>where <code>A(t)</code>, <code>R(t)</code> and <code>Q(t)</code> are periodic matrices of commensurate periods,  with <code>A(t)</code> square, <code>R(t)</code> symmetric and positive definite, and <code>Q(t)</code> symmetric and positive semidefinite.  The resulting <code>X</code> is a collection of periodic generator matrices determined  as a periodic time-series matrix with <code>N</code> components, where <code>N = 1</code> if <code>A(t)</code>, <code>R(t)</code> and <code>Q(t)</code> are constant matrices and <code>N = K</code> otherwise.  <code>EVALS</code> contains the stable characteristic multipliers of the monodromy matrix of  the corresponding Hamiltonian matrix (also called closed-loop characteristic multipliers). The period of <code>X</code> is set to the least common commensurate period of <code>A(t)</code>, <code>R(t)</code> and <code>Q(t)</code> and the number of subperiods is adjusted accordingly.  Any component matrix of <code>X</code> is a valid initial value to be used to generate the   solution over a full period by integrating the appropriate differential equation. </p><p>If <code>fast = true</code> (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in <code>t = 0</code> and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If <code>fast = false</code>, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). </p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>, together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>) and  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>For large values of <code>K</code>, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable.  </p><p><em>References</em></p><p>[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. </p><p>[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/pscric.jl#L314-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.tvcric_eval" href="#PeriodicSystems.tvcric_eval"><code>PeriodicSystems.tvcric_eval</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tvcric_eval(t, W, A, R, Q; adj, solver, reltol, abstol, dt) -&gt; Xval</code></pre><p>Compute the time value <code>Xval := X(t)</code> of the solution of the periodic Riccati differential equation</p><pre><code class="nohighlight hljs">  .                                                
  X(t) = A(t)X(t) + X(t)A(t)&#39; + Q(t) - X(t)R(t)X(t) ,  X(t0) = W(t0), t0 &lt; t, if adj = false (default),</code></pre><p>or </p><pre><code class="nohighlight hljs">  .                                                
 -X(t) = A(t)&#39;X(t) + X(t)A(t) + Q(t) - X(t)R(t)X(t) ,  X(t0) = W(t0), t0 &gt; t, if adj = true,</code></pre><p>using the periodic generator <code>W</code> determined with the function <a href="psric.html#PeriodicSystems.pgcric"><code>pgcric</code></a> for the same periodic matrices <code>A</code>, <code>R</code> and <code>Q</code> and the same value of the keyword argument <code>adj</code>.  The initial time <code>t0</code> is the nearest time grid value to <code>t</code>, from below, if <code>adj = false</code>, or from above, if <code>adj = true</code>.  The resulting <code>Xval</code> is a symmetric matrix. </p><p>The ODE solver to be employed can be specified using the keyword argument <code>solver</code>,  (default: <code>solver = &quot;symplectic&quot;</code>) together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and/or  the fixed step length <code>dt</code> (default: <code>dt =  min(A.period/A.nperiod/100,tf-t0)</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/pscric.jl#L635-L673">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.prcric" href="#PeriodicSystems.prcric"><code>PeriodicSystems.prcric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prcric(A, B, R, Q; K = 10, solver, intpol, intpolmeth, reltol, abstol, fast) -&gt; (X, EVALS, F)</code></pre><p>Compute the symmetric stabilizing solution <code>X(t)</code> of the periodic control related Riccati differential equation</p><pre><code class="nohighlight hljs"> .                                                -1 
-X(t) = A(t)&#39;X(t) + X(t)A(t) + Q(t) - X(t)B(t)R(t)  B(t)&#39;X(t) ,</code></pre><p>the periodic stabilizing state-feedback gain </p><pre><code class="nohighlight hljs">           -1
F(t) = R(t)  B(t)&#39;X(t)</code></pre><p>and the corresponding stable characteristic multipliers <code>EVALS</code> of <code>A(t)-B(t)F(t)</code>. </p><p>The periodic matrices <code>A</code>, <code>B</code>, <code>R</code> and <code>Q</code> must have the same type and commensurate periods,  and additionally <code>R</code> must be symmetric positive definite and <code>Q</code> must be symmetric positive semidefinite.  The resulting symmetric periodic solution <code>X</code> has the period  set to the least common commensurate period of <code>A</code>, <code>B</code>, <code>R</code> and <code>Q</code> and the number of subperiods is adjusted accordingly. </p><p>If <code>fast = true</code> (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in <code>t = 0</code> and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If <code>fast = false</code>, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). </p><p>The keyword argument <code>K</code> specifies the number of grid points to be used for the resulting multiple point periodic generator (default: <code>K = 10</code>).  The obtained periodic generator is finally converted into a periodic function matrix which determines for a given <code>t</code>  the function value <code>X(t)</code> by integrating the appropriate ODE from the nearest grid point value. </p><p>To speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument <code>intpol = true</code> (default: <code>intpol = true</code> if <code>solver = &quot;symplectic&quot;</code>, otherwise <code>intpol = false</code>).  In this case the interpolation method to be used can be specified via the keyword argument <code>intpolmeth = meth</code>. The allowable values for <code>meth</code> are: <code>&quot;constant&quot;</code>, <code>&quot;linear&quot;</code>, <code>&quot;quadratic&quot;</code> and <code>&quot;cubic&quot;</code> (default).</p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>, together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>) and  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>For large values of <code>K</code>, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable.  </p><p><em>References</em></p><p>[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. </p><p>[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/pscric.jl#L243-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pfcric" href="#PeriodicSystems.pfcric"><code>PeriodicSystems.pfcric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pfcric(A, C, R, Q; K = 10, solver, intpol, intpolmeth, reltol, abstol, fast) -&gt; (X, EVALS, F)</code></pre><p>Compute the symmetric stabilizing solution <code>X(t)</code> of the periodic filtering related Riccati differential equation</p><pre><code class="nohighlight hljs">.                                                 -1 
X(t) = A(t)X(t) + X(t)A(t)&#39; + Q(t) - X(t)C(t)&#39;R(t)  C(t)X(t) ,</code></pre><p>the periodic stabilizing Kalman gain </p><pre><code class="nohighlight hljs">                    -1
F(t) = X(t)C(t)&#39;R(t)</code></pre><p>and the corresponding stable characteristic multipliers <code>EVALS</code> of <code>A(t)-F(t)C(t)</code>. </p><p>The periodic matrices <code>A</code>, <code>C</code>, <code>R</code> and <code>Q</code> must have the same type and commensurate periods,  and additionally <code>R</code> must be symmetric positive definite and <code>Q</code> must be symmetric positive semidefinite.  The resulting symmetric periodic solution <code>X</code> has the period  set to the least common commensurate period of <code>A</code>, <code>C</code>, <code>R</code> and <code>Q</code> and the number of subperiods is adjusted accordingly. </p><p>If <code>fast = true</code> (default) the multiple-shooting method is used in conjunction with fast pencil reduction techniques, as proposed in [1], to determine the periodic solution in <code>t = 0</code> and a multiple point generator of the appropriate periodic differential Riccati equation is determined  (see [2] for details).  If <code>fast = false</code>, the multiple-shooting method is used in  conjunction with the periodic Schur decomposition to determine multiple point generators directly from the stable periodic invariant subspace of  an appropriate symplectic transition matrix (see also [2] for more details). </p><p>The keyword argument <code>K</code> specifies the number of grid points to be used for the resulting multiple point periodic generator (default: <code>K = 10</code>).  The obtained periodic generator is finally converted into a periodic function matrix which determines for a given <code>t</code>  the function value <code>X(t)</code> by integrating the appropriate ODE from the nearest grid point value. </p><p>To speedup function evaluations, interpolation based function evaluations can be used  by setting the keyword argument <code>intpol = true</code> (default: <code>intpol = true</code> if <code>solver = &quot;symplectic&quot;</code>, otherwise <code>intpol = false</code>).  In this case the interpolation method to be used can be specified via the keyword argument <code>intpolmeth = meth</code>. The allowable values for <code>meth</code> are: <code>&quot;constant&quot;</code>, <code>&quot;linear&quot;</code>, <code>&quot;quadratic&quot;</code> and <code>&quot;cubic&quot;</code> (default).</p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>, together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>) and  absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;linear&quot;</code> - use a special solver for linear ODEs (<code>MagnusGL6()</code>) with fixed time step <code>dt</code>;</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>For large values of <code>K</code>, parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable.  </p><p><em>References</em></p><p>[1] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. </p><p>[2] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/pscric.jl#L172-L241">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.prdric" href="#PeriodicSystems.prdric"><code>PeriodicSystems.prdric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> prdric(A, B, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -&gt; (X, EVALS, F)</code></pre><p>Solve the periodic Riccati difference equation</p><pre><code class="nohighlight hljs">  X(i) = Q(i) + A(i)&#39;X(i+1)A(i) - (A(i)&#39;X(i+1)B(i) + S(i))*
                                 -1
         (B(i)&#39;X(i+1)B(i) + R(i))  (A(i)&#39;X(i+1)B(i) + S(i))&#39;</code></pre><p>and compute the stabilizing periodic state feedback</p><pre><code class="nohighlight hljs">                                  -1
  F(i) = -(B(i)&#39;X(i+1)B(i) + R(i))  (B(i)&#39;X(i+1)A(i) + S(i)&#39;)</code></pre><p>and the corresponding stable closed-loop characteristic multipliers of <code>A(i)-B(i)F(i)</code> in <code>EVALS</code>. </p><p>The <code>n×n</code> and <code>n×m</code> periodic matrices <code>A(i)</code> and <code>B(i)</code> are contained in the  <code>PeriodicArray</code> objects <code>A</code> and <code>B</code>, and must have the same sampling time.  <code>R(i)</code>, <code>Q(i)</code> and <code>S(i)</code> are <code>m×m</code>, <code>n×n</code> and <code>n×m</code> periodic matrices of same sampling times  as  <code>A</code> and <code>B</code>, and such that <code>R(i)</code> and <code>Q(i)</code> are symmetric. <code>R(i)</code>, <code>Q(i)</code> and <code>S(i)</code> are contained in the  <code>PeriodicArray</code> objects <code>R</code>, <code>Q</code> and <code>S</code>.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices.  The resulting symmetric periodic solution <code>X</code> and periodic state feedback gain <code>F</code> have the period  set to the least common commensurate period of <code>A</code>, <code>B</code>, <code>R</code> and <code>Q</code> and the number of subperiods is adjusted accordingly. </p><p>If <code>fast = true</code>, the fast structure exploiting pencil reduction based method of [1] is used to determine a periodic generator in <code>X(1)</code>, which allows to generate iteratively the solution  over the whole period.   If <code>fast = false</code> (default), the periodic Schur decomposition based approach of [1] is employed, applied to a  symplectic pair of periodic matrices. If <code>nodeflate = false</code> (default), the underlying periodic pencil  is preprocessed to eliminate (deflate) the infinite characteristic multipliers originating  from the problem structure. If <code>nodeflate = true</code>, no preliminary deflation is performed.</p><p>An iterative refining of the accuracy of the computed solution  can be performed by using <code>itmax = k</code>, with <code>k &gt; 0</code> (default: <code>k = 0</code>). </p><p>To detect singularities of involved matrices, the keyword parameter <code>rtol = tol</code> can be used to   specify the lower bound for the 1-norm reciprocal condition number.  The default value of  <code>tol</code> is <code>n*ϵ</code>, where <code>ϵ</code> is the working <em>machine epsilon</em>.</p><p><em>References</em></p><p>[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/psdric.jl#L1-L47">source</a></section><section><div><pre><code class="language-julia hljs"> prdric(A, B, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -&gt; (X, EVALS, F)</code></pre><p>Solve the periodic Riccati difference equation</p><pre><code class="nohighlight hljs">  X(i) = Q(i) + A(i)&#39;X(i+1)A(i) - (A(i)&#39;X(i+1)B(i) + S(i))*
                                 -1
         (B(i)&#39;X(i+1)B(i) + R(i))  (A(i)&#39;X(i+1)B(i) + S(i))&#39;</code></pre><p>and compute the stabilizing periodic state feedback</p><pre><code class="nohighlight hljs">                                  -1
  F(i) = -(B(i)&#39;X(i+1)B(i) + R(i))  (B(i)&#39;X(i+1)A(i) + S(i)&#39;)</code></pre><p>and the corresponding stable closed-loop <em>core</em> characteristic multipliers of <code>A(i)-B(i)F(i)</code> in <code>EVALS</code>. </p><p>The <code>n(i+1)×n(i)</code> and <code>n(i+1)×m</code> periodic matrices <code>A(i)</code> and <code>B(i)</code> are contained in the  <code>PeriodicMatrix</code> objects <code>A</code> and <code>B</code>, and must have the same sampling time.  <code>R(i)</code>, <code>Q(i)</code> and <code>S(i)</code> are <code>m×m</code>, <code>n(i)×n(i)</code> and <code>n(i)×m</code> periodic matrices of same sampling times  as  <code>A</code> and <code>B</code>, and such that <code>R(i)</code> and <code>Q(i)</code> are symmetric. <code>R(i)</code>, <code>Q(i)</code> and <code>S(i)</code> are contained in the  <code>PeriodicMatrix</code> objects <code>R</code>, <code>Q</code> and <code>S</code>.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices.  The resulting <code>n(i)×n(i)</code> symmetric periodic solution <code>X(i)</code> and <code>m×n(i)</code> periodic state feedback gain <code>F(i)</code> have the period  set to the least common commensurate period of <code>A</code>, <code>B</code>, <code>R</code> and <code>Q</code> and the number of subperiods is adjusted accordingly. </p><p>If <code>fast = true</code>, the fast structure exploiting pencil reduction based method of [1] is used to determine a periodic generator in <code>X(j)</code>, which allows to generate iteratively the solution  over the whole period. The value of <code>j</code> corresponds to the least dimension <code>nc</code> of <code>n(i)</code>  (which is also the number of core characteristic multipliers).  If <code>fast = false</code> (default), the periodic Schur decomposition based approach of [1] is employed, applied to a  symplectic pair of periodic matrices. If <code>nodeflate = false</code> (default), the underlying periodic pencil  is preprocessed to eliminate (deflate) the infinite characteristic multipliers originating  from the problem structure. If <code>nodeflate = true</code>, no preliminary deflation is performed.</p><p>An iterative refining of the accuracy of the computed solution  can be performed by using <code>itmax = k</code>, with <code>k &gt; 0</code> (default: <code>k = 0</code>). </p><p>To detect singularities of involved matrices, the keyword parameter <code>rtol = tol</code> can be used to   specify the lower bound for the 1-norm reciprocal condition number.  The default value of  <code>tol</code> is <code>n*ϵ</code>, where <code>ϵ</code> is the working <em>machine epsilon</em> and <code>n</code> is the maximum of <code>n(i)</code>.</p><p><em>References</em></p><p>[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/psdric.jl#L241-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pfdric" href="#PeriodicSystems.pfdric"><code>PeriodicSystems.pfdric</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pfdric(A, C, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -&gt; (X, EVALS, F)</code></pre><p>Solve the periodic Riccati difference equation</p><pre><code class="nohighlight hljs">  X(i+1) = Q(i) + A(i)X(i)A(i)&#39; - (A(i)X(i)C(i)&#39; + S(i))*
                                 -1
           (C(i)X(i)C(i)&#39; + R(i))  (A(i)X(i)C(i)&#39; + S(i))&#39;</code></pre><p>and compute the stabilizing periodic Kalman gain</p><pre><code class="nohighlight hljs">                                                       -1
  F(i) = -(C(i)X(i)A(i)&#39; + S(i)&#39;)(C(i)X(i)C(i)&#39; + R(i))</code></pre><p>and the corresponding stable Kalman filter characteristic multipliers of <code>A(i)-F(i)C(i)</code> in <code>EVALS</code>. </p><p>The <code>n×n</code> and <code>m×n</code> periodic matrices <code>A(i)</code> and <code>C(i)</code> are contained in the  <code>PeriodicArray</code> objects <code>A</code> and <code>C</code>, and must have the same sampling time.  <code>R(i)</code>, <code>Q(i)</code> and <code>S(i)</code> are <code>m×m</code>, <code>n×n</code> and <code>m×n</code> periodic matrices of same sampling times  as  <code>A</code> and <code>C</code>, and such that <code>R(i)</code> and <code>Q(i)</code> are symmetric.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices.  The resulting symmetric periodic solution <code>X</code> and Kalman filter gain <code>F</code> have the period  set to the least common commensurate period of <code>A</code>, <code>C</code>, <code>R</code> and <code>Q</code> and the number of subperiods is adjusted accordingly. </p><p>The dual method of [1] is employed (see <a href="psric.html#PeriodicSystems.prdric"><code>prdric</code></a> for the description of keyword parameters).</p><p><em>References</em></p><p>[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/psdric.jl#L440-L472">source</a></section><section><div><pre><code class="language-julia hljs"> pfdric(A, C, R, Q[, S]; itmax = 0, nodeflate = false, fast, rtol) -&gt; (X, EVALS, F)</code></pre><p>Solve the periodic Riccati difference equation</p><pre><code class="nohighlight hljs">  X(i+1) = Q(i) + A(i)X(i)A(i)&#39; - (A(i)X(i)C(i)&#39; + S(i))*
                                 -1
           (C(i)X(i)C(i)&#39; + R(i))  (A(i)X(i)C(i)&#39; + S(i))&#39;</code></pre><p>and compute the stabilizing periodic Kalman gain</p><pre><code class="nohighlight hljs">                                                       -1
  F(i) = -(C(i)X(i)A(i)&#39; + S(i)&#39;)(C(i)X(i)C(i)&#39; + R(i))</code></pre><p>and the corresponding stable Kalman filter <em>core</em> characteristic multipliers of <code>A(i)-F(i)C(i)</code> in <code>EVALS</code>. </p><p>The <code>n(i+1)×n(i)</code> and <code>m×n(i)</code> periodic matrices <code>A(i)</code> and <code>C(i)</code> are contained in the  <code>PeriodicMatrix</code> objects <code>A</code> and <code>C</code>, and must have the same sampling time.  <code>R(i)</code>, <code>Q(i)</code> and <code>S(i)</code> are <code>m×m</code>, <code>n(i)×n(i)</code> and <code>m×n(i)</code> periodic matrices of same sampling times  as  <code>A</code> and <code>C</code>, and such that <code>R(i)</code> and <code>Q(i)</code> are symmetric.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices.  The resulting symmetric periodic solution <code>X</code> and Kalman filter gain <code>F</code> have the period  set to the least common commensurate period of <code>A</code>, <code>C</code>, <code>R</code> and <code>Q</code> and the number of subperiods is adjusted accordingly. </p><p>The dual method of [1] is employed (see <a href="psric.html#PeriodicSystems.prdric"><code>prdric</code></a> for the description of keyword parameters).</p><p><em>References</em></p><p>[1] A. Varga. On solving periodic Riccati equations.       Numerical Linear Algebra with Applications, 15:809-835, 2008.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/d2701628121e11003ef85475d5987fbe35bcb2f1/src/psdric.jl#L493-L524">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="pslyap.html">« Periodic Lyapunov equation solvers</a><a class="docs-footer-nextpage" href="psstab.html">Stabilization of periodic systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Saturday 9 November 2024 09:48">Saturday 9 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
