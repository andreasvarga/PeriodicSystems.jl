<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stabilization of periodic systems · PeriodicSystems.jl</title><meta name="title" content="Stabilization of periodic systems · PeriodicSystems.jl"/><meta property="og:title" content="Stabilization of periodic systems · PeriodicSystems.jl"/><meta property="twitter:title" content="Stabilization of periodic systems · PeriodicSystems.jl"/><meta name="description" content="Documentation for PeriodicSystems.jl."/><meta property="og:description" content="Documentation for PeriodicSystems.jl."/><meta property="twitter:description" content="Documentation for PeriodicSystems.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">PeriodicSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Data Types and Constructors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="ps.html">Building periodic systems</a></li></ul></li><li><a class="tocitem" href="psconnect.html">Basic connections and operations</a></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Basic conversions</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="psconversions.html">Discretization of continuous-time periodic systems</a></li><li><a class="tocitem" href="pslifting.html">Conversions to LTI representations</a></li></ul></li><li><a class="tocitem" href="psanalysis.html">Analysis of periodic systems</a></li><li><a class="tocitem" href="pslyap.html">Periodic Lyapunov equation solvers</a></li><li><a class="tocitem" href="psric.html">Periodic Riccati equation solvers</a></li><li class="is-active"><a class="tocitem" href="psstab.html">Stabilization of periodic systems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="pstools.html">Periodic system utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="psstab.html">Stabilization of periodic systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="psstab.html">Stabilization of periodic systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andreasvarga/PeriodicSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/master/docs/src/psstab.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Stabilization-of-periodic-systems"><a class="docs-heading-anchor" href="#Stabilization-of-periodic-systems">Stabilization of periodic systems</a><a id="Stabilization-of-periodic-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Stabilization-of-periodic-systems" title="Permalink"></a></h1><p><strong>Periodic state feedback controller and estimator design</strong> </p><ul><li><strong><a href="psstab.html#PeriodicSystems.pclqr"><code>pclqr</code></a></strong>  LQ-optimal state feedack stabilization of continuous-time periodic systems </li><li><strong><a href="psstab.html#PeriodicSystems.pclqry"><code>pclqry</code></a></strong> LQ-optimal state feedack stabilization with output weighting of continuous-time periodic systems </li><li><strong><a href="psstab.html#PeriodicSystems.pdlqr"><code>pdlqr</code></a></strong>  LQ-optimal state feedack stabilization of discrete-time periodic systems </li><li><strong><a href="psstab.html#PeriodicSystems.pdlqry"><code>pdlqry</code></a></strong> LQ-optimal state feedack stabilization with output weighting of discrete-time periodic systems </li><li><strong><a href="psstab.html#PeriodicSystems.pckeg"><code>pckeg</code></a></strong>  Kalman estimator gain matrix for continuous-time periodic systems </li><li><strong><a href="psstab.html#PeriodicSystems.pckegw"><code>pckegw</code></a></strong>  Kalman estimator gain matrix for continuous-time periodic systems with noise inputs</li><li><strong><a href="psstab.html#PeriodicSystems.pdkeg"><code>pdkeg</code></a></strong>  Kalman estimator gain matrix for periodic systems </li><li><strong><a href="psstab.html#PeriodicSystems.pdkegw"><code>pdkegw</code></a></strong>  Kalman estimator gain matrix for periodic systems with noise inputs</li></ul><p><strong>Periodic output feedback controller design</strong> </p><ul><li><strong><a href="psstab.html#PeriodicSystems.pcpofstab_sw"><code>pcpofstab_sw</code></a></strong> Stabilization of continuous-time periodic systems using switching periodic output feedback.</li><li><strong><a href="psstab.html#PeriodicSystems.pcpofstab_hr"><code>pcpofstab_hr</code></a></strong> Stabilization of continuous-time periodic systems using harmonic output feedback.</li><li><strong><a href="psstab.html#PeriodicSystems.pdpofstab_sw"><code>pdpofstab_sw</code></a></strong> Stabilization of discrete-time periodic systems using switching periodic output feedback.</li><li><strong><a href="psstab.html#PeriodicSystems.pdpofstab_hr"><code>pdpofstab_hr</code></a></strong> Stabilization of discrete-time periodic systems using discretized harmonic periodic output feedback.</li><li><strong><a href="psstab.html#PeriodicSystems.pclqofc_sw"><code>pclqofc_sw</code></a></strong> LQ-optimal stabilization of continuous-time periodic systems using switching periodic output feedback.</li><li><strong><a href="psstab.html#PeriodicSystems.pclqofc_hr"><code>pclqofc_hr</code></a></strong> LQ-optimal stabilization of continuous-time periodic systems using harmonic output feedback.</li><li><strong><a href="psstab.html#PeriodicSystems.pdlqofc"><code>pdlqofc</code></a></strong> LQ-optimal stabilization of discrete-time periodic systems using periodic output feedback.</li><li><strong><a href="psstab.html#PeriodicSystems.pdlqofc_sw"><code>pdlqofc_sw</code></a></strong> LQ-optimal stabilization of discrete-time periodic systems using switching periodic output feedback.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pclqr" href="#PeriodicSystems.pclqr"><code>PeriodicSystems.pclqr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pclqr(psys, Q, R, S; intpol = true, kwargs...) -&gt; (F, EVALS)</code></pre><p>Compute the optimal periodic stabilizing gain matrix <code>F(t)</code>, such that for a continuous-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">  .
  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t),</code></pre><p>the state feedback control law</p><pre><code class="nohighlight hljs"> u(t) = F(t)x(t)</code></pre><p>minimizes the quadratic index</p><pre><code class="nohighlight hljs"> J = Integral {x&#39;(t)Q(t)x(t) + u(t)&#39;R(t)u(t) + 2*x&#39;(t)S(t)u(t)} dt.</code></pre><p>For a system of order <code>n</code> with <code>m</code> inputs, <code>Q(t)</code> and <code>R(t)</code> are <code>n×n</code> and <code>m×m</code> symmetric matrices, respectively, and <code>S(t)</code> is an <code>n×m</code> matrix.                 The matrix <code>S</code> is set to zero when omitted. The dimension of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices. </p><p>Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)+B(t)F(t)</code>.</p><p>For <code>intpol = true</code> (default), the resulting periodic gain <code>F(t)</code> is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If <code>intpol = false</code>, the gain <code>F(t)</code> is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   </p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.prcric"><code>prcric</code></a> (excepting intpol). </p><p>Note: The pair <code>(A(t),B(t))</code> must be stabilizable, <code>R</code> must be positive definite and <code>[Q S;S&#39; R]</code> must be nonnegative definite .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L34-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pclqry" href="#PeriodicSystems.pclqry"><code>PeriodicSystems.pclqry</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pclqry(psys, Q, R, S; intpol = true, kwargs...) -&gt; (F, EVALS)</code></pre><p>Compute the optimal periodic stabilizing gain matrix F(t), such that for a periodic  continuous-time state-space model <code>psys</code> of the form        .       x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)        y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,</p><p>the state feedback control law</p><pre><code class="nohighlight hljs"> u(t) = F(t)x(t)</code></pre><p>minimizes the quadratic index</p><pre><code class="nohighlight hljs"> J = Integral {y&#39;(t)Q(t)y(t) + u&#39;(t)R(t)u(t) + 2*y&#39;(t)S(t)u(t)} dt</code></pre><p>For a system with <code>m</code> control inputs <code>u(t)</code> and <code>p</code> outputs, <code>Q(t)</code> and <code>R(t)</code> are <code>p×p</code> and <code>m×m</code> symmetric matrices, respectively, and <code>S(t)</code> is an <code>p×m</code> matrix.  The dimension of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices.                              The matrix <code>S</code> is set to zero when omitted. </p><p>Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)+B(t)F(t)</code>.</p><p>For <code>intpol = true</code> (default), the resulting periodic gain <code>F(t)</code> is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If <code>intpol = false</code>, the gain <code>F(t)</code> is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   </p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.prcric"><code>prcric</code></a> (excepting intpol).  </p><p>Note: The pair <code>(A(t),B(t))</code> must be stabilizable and <code>[Q S;S&#39; R]</code> must be nonnegative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L145-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdlqr" href="#PeriodicSystems.pdlqr"><code>PeriodicSystems.pdlqr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pdlqr(psys, Q, R, S; kwargs...) -&gt; (F, EVALS)</code></pre><p>Compute the optimal periodic stabilizing gain matrix <code>F(t)</code>, such that for a discrete-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">x(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t) 
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t)</code></pre><p>the state feedback control law</p><pre><code class="nohighlight hljs"> u(t) = F(t)x(t)</code></pre><p>minimizes the quadratic index</p><pre><code class="nohighlight hljs"> J = Sum {x&#39;(t)Q(t)x(t) + u&#39;(t)R(t)u(t) + 2*x&#39;(t)S(t)u(t)}</code></pre><p>For a system of order <code>n(t)</code> with <code>m</code> control inputs in <code>u(t)</code>, <code>Q(t)</code> and <code>R(t)</code> are <code>n(t)×n(t)</code> and <code>m×m</code> symmetric matrices, respectively, and <code>S(t)</code> is an <code>n(t)×m</code> matrix.                 The matrix <code>S</code> is set to zero when omitted. The dimension of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices. </p><p>Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)+B(t)F(t)</code>.</p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.prdric"><code>prdric</code></a>. </p><p>Note: The pair <code>(A(t),B(t))</code> must be stabilizable and <code>[Q S;S&#39; R]</code> must be nonnegative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdlqry" href="#PeriodicSystems.pdlqry"><code>PeriodicSystems.pdlqry</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pdlqry(psys, Q, R, S; kwargs...) -&gt; (F, EVALS)</code></pre><p>Compute the optimal periodic stabilizing gain matrix <code>F(t)</code>, such that for a periodic discrete-time  state-space model <code>psys</code> of the form</p><pre><code class="nohighlight hljs">x(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t),</code></pre><p>the state feedback control law</p><pre><code class="nohighlight hljs"> u(t) = F(t)x(t)</code></pre><p>minimizes the quadratic index</p><pre><code class="nohighlight hljs"> J = Sum {y&#39;(t)Q(t)y(t) + u&#39;(t)R(t)u(t) + 2*y&#39;(t)S(t)u(t)}</code></pre><p>For a system with <code>m</code> control inputs <code>u(t)</code> and <code>p</code> outputs, <code>Q(t)</code> and <code>R(t)</code> are <code>p×p</code> and <code>m×m</code> symmetric matrices, respectively, and <code>S(t)</code> is a <code>p×m</code> matrix.   The dimension of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>R</code>, <code>Q</code> and <code>S</code> can be alternatively provided as constant real matrices.                The matrix <code>S</code> is set to zero when omitted. </p><p>Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)+B(t)F(t)</code>.</p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.prdric"><code>prdric</code></a>. </p><p>Note: The pair <code>(A(t),B(t))</code> must be stabilizable and <code>[Q S;S&#39; R]</code> must be nonnegative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L97-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pckeg" href="#PeriodicSystems.pckeg"><code>PeriodicSystems.pckeg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pckeg(psys, Qw, Rv, Sn; intpol = true, kwargs...) -&gt; (L, EVALS)</code></pre><p>Compute the Kalman estimator periodic gain matrix <code>L(t)</code> for a continuous-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">  .
  x(t) = A(t)x(t) + B(t)u(t) + w(t)
  y(t) = C(t)x(t) + D(t)u(t) + v(t)</code></pre><p>and the noise covariance data <code>E{w(t)w(t)&#39;} = Qw(t)</code>, <code>E{v(t)v(t)&#39;} = Rv(t)</code>, <code>E{w(t)v(t)&#39;} = Sn(t)</code>,  for a Kalman estimator </p><pre><code class="nohighlight hljs">   .
  xe(t) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))</code></pre><p>For a system of order <code>n</code> with <code>p</code> outputs, <code>Qw</code> and <code>Rv</code> are <code>n×n</code> and <code>p×p</code> symmetric matrices, respectively, and <code>Sn</code> is an <code>n×p</code> matrix.                 <code>Qw</code>, <code>Rv</code> and <code>Sn</code> can be alternatively provided as constant real matrices.  The matrix <code>Sn</code> is set to zero when omitted. </p><p>Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)-L(t)C(t)</code>.</p><p>For <code>intpol = true</code> (default), the resulting periodic gain <code>L(t)</code> is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If <code>intpol = false</code>, the gain <code>L(t)</code> is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   </p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.pfcric"><code>pfcric</code></a> (excepting intpol). </p><p>Note: The pair <code>(A(t),C(t))</code> must be detectable and <code>[Qw Sn;Sn&#39; Rv]</code> must be nonnegative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L235-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pckegw" href="#PeriodicSystems.pckegw"><code>PeriodicSystems.pckegw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pckegw(psys, Qw, Rv, Sn; intpol = true, kwargs...) -&gt; (L, EVALS)</code></pre><p>Compute the Kalman estimator periodic gain matrix <code>L(t)</code> for a continuous-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">  .
  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) + v(t)</code></pre><p>and the noise covariance data <code>E{w(t)w(t)&#39;} = Qw(t)</code>, <code>E{v(t)v(t)&#39;} = Rv(t)</code>, <code>E{w(t)v(t)&#39;} = Sn(t)</code>,  for a Kalman estimator </p><pre><code class="nohighlight hljs">   .
  xe(t) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))</code></pre><p>For a system with <code>mw</code> disturbance inputs and <code>p</code> outputs, <code>Qw</code> and <code>Rv</code> are <code>mw×mw</code> and <code>p×p</code> symmetric matrices, respectively, and <code>Sn</code> is an <code>mw×p</code> matrix.                 <code>Qw</code>, <code>Rv</code> and <code>Sn</code> can be alternatively provided as constant real matrices.                The matrix <code>Sn</code> is set to zero when omitted. The number of disturbance inputs <code>mw</code> is defined by the order of matrix <code>Qw</code>.  Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)-L(t)C(t)</code>.</p><p>For <code>intpol = true</code> (default), the resulting periodic gain <code>L(t)</code> is computed from the  stabilizing solution of a continuous-time periodic matrix differential Riccati equation using interpolation based formulas.  If <code>intpol = false</code>, the gain <code>L(t)</code> is computed from a multi-point solution of the Riccati differential equation  by the integration of the corresponding ODE using the nearest point value as initial condition.  This option is not recommended to be used jointly with symplectic integrators, which are used by default.   </p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.pfcric"><code>pfcric</code></a> (excepting intpol). </p><p>Note: The pair <code>(A(t),C(t))</code> must be detectable,  <code>Qw</code> must be non-negative definite,  <code>Rv</code> must be positive definite and <code>[Qw Sn; Sn&#39; Rv]</code> must be nonnegative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L345-L376">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdkeg" href="#PeriodicSystems.pdkeg"><code>PeriodicSystems.pdkeg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pdkeg(psys, Qw, Rv, Sn; kwargs...) -&gt; (L, EVALS)</code></pre><p>Compute the Kalman estimator periodic gain matrix <code>L(t)</code> for a discrete-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">x(t+1) = A(t)x(t) + B(t)u(t) + w(t)
  y(t) = C(t)x(t) + D(t)u(t) + v(t)</code></pre><p>and the noise covariance data <code>E{w(t)w(t)&#39;} = Qw(t)</code>, <code>E{v(t)v(t)&#39;} = Rv(t)</code>, <code>E{w(t)v(t)&#39;} = Sn(t)</code>,  for a Kalman estimator </p><pre><code class="nohighlight hljs">  xe(t+1) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))</code></pre><p>For a system of order <code>n</code> with <code>p</code> outputs, <code>Qw</code> and <code>Rv</code> are <code>n×n</code> and <code>p×p</code> symmetric matrices, respectively, and <code>Sn</code> is an <code>n×p</code> matrix.                 <code>Qw</code>, <code>Rv</code> and <code>Sn</code> can be alternatively provided as constant real matrices.                The matrix <code>Sn</code> is set to zero when omitted. </p><p>Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)-L(t)C(t)</code>.</p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.pfdric"><code>pfdric</code></a>. </p><p>Note: The pair <code>(A(t),C(t))</code> must be detectable and <code>[Qw Sn;Sn&#39; Rv]</code> must be nonnegative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L206-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdkegw" href="#PeriodicSystems.pdkegw"><code>PeriodicSystems.pdkegw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> pdkegw(psys, Qw, Rv, Sn; kwargs...) -&gt; (L, EVALS)</code></pre><p>Compute the Kalman estimator periodic gain matrix <code>L(t)</code> for a discrete-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">x(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) + v(t)</code></pre><p>and the noise covariance data <code>E{w(t)w(t)&#39;} = Qw(t)</code>, <code>E{v(t)v(t)&#39;} = Rv(t)</code>, <code>E{w(t)v(t)&#39;} = Sn(t)</code>,  for a Kalman estimator </p><pre><code class="nohighlight hljs">  xe(t+1) = A(t)xe(t) + B(t)u(t) + L(t)(y(t)-C(t)xe(t)-D(t)u(t))</code></pre><p>For a system with <code>mw</code> disturbance inputs and <code>p</code> outputs, <code>Qw</code> and <code>Rv</code> are <code>mw×mw</code> and <code>p×p</code> symmetric matrices, respectively, and <code>Sn</code> is an <code>mw×p</code> matrix.   <code>Qw</code>, <code>Rv</code> and <code>Sn</code> can be alternatively provided as constant real matrices.                The matrix <code>Sn</code> is set to zero when omitted. The number of disturbance inputs <code>mw</code> is defined by the order of matrix <code>Qw</code>. </p><p>Also returned are the closed-loop characteristic exponents <code>EVALS</code> of <code>A(t)-L(t)C(t)</code>.</p><p>The keyword arguments contained in <code>kwargs</code> are those used for the function <a href="psric.html#PeriodicSystems.pfdric"><code>pfdric</code></a>. </p><p>Note: The pair <code>(A(t),C(t))</code> must be detectable,  <code>Qw</code> must be non-negative definite,  <code>Rv</code> must be positive definite and <code>[Qw Sn; Sn&#39; Rv]</code> must be nonnegative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L294-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pcpofstab_sw" href="#PeriodicSystems.pcpofstab_sw"><code>PeriodicSystems.pcpofstab_sw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcpofstab_sw(psys, ts = missing; K = 100, vinit, optimizer, maxit, vtol, Jtol, gtol, show_trace) -&gt; (Fstab,info)</code></pre><p>For a continuous-time periodic system <code>psys = (A(t), B(t), C(t), D(t))</code> of period <code>T</code> determine a periodic output feedback gain matrix  <code>Fstab(t)</code> of the same period and switching times <code>ts</code>,   such that the characteristic exponents <code>Λ</code> of the closed-loop state-matrix <code>A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t)</code> are stable.  The matrices of the system <code>psys</code> are of type <code>PeriodicFunctionMatrix</code>.  The <code>ns</code> switching times contained in the vector <code>ts</code> must satisfy <code>0 = ts[1] &lt; ts[2] &lt; ... &lt; ts[ns] &lt; T</code>.  If <code>ts = missing</code>, then <code>ts = [0]</code> is used by default (i.e., constant output feedback). </p><p>The output feedback gain <code>Fstab(t)</code> is computed as <code>Fstab(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code>  defined as </p><pre><code class="nohighlight hljs"> F(t) = F_i  for t ∈ [ts[i],ts[i+1]) and i ∈ {1, ..., ns-1} or 
 F(t) = F_ns for t ∈ [ts[ns],T)</code></pre><p>where <code>F_i</code> is the <code>i</code>-th gain.   The resulting periodic matrix <code>Fstab(t)</code> is of type <code>PeriodicSwitchingMatrix</code>. The corresponding closed-loop periodic system can be obtained using the function <a href="psconnect.html#PeriodicSystems.psfeedback"><code>psfeedback</code></a>.</p><p>For the determination of the optimal feedback gains <code>F_i</code> for <code>i = 1, ...., ns</code> an optimization-based approach is employed using  tools available in the optimization package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>.  By default, the gradient-free <em>Nelder-Mead</em> local search method for unconstrained minimizations  is employed using the keyword argument setting <code>optimizer = Optim.NelderMead()</code>.    The alternative gradient-free <em>Simulated Annealing</em> global search method can be selected with <code>optimizer = Optim.SimulatedAnnealing()</code>. </p><p>For a system with <code>m</code> inputs and <code>p</code> outputs,  an internal optimization variable <code>v</code> is used, formed as an <code>m×p×ns</code> array with <code>v[:,:,i] := F_i</code>, for <code>i = 1, ..., ns</code>.  The performance index to be minimized is <code>J := sdeg(v)</code>,  where <code>sdeg(v)</code> is the stability degree defined as the largest real part of the characteristic exponents  of <code>Af(t) := A(t)+B(t)*F(t)*C(t)</code>. The keyword argument <code>K</code> is the number of factors used to express the monodromy matrix of <code>Af(t)</code> (default: <code>K = 100</code>),  when evaluating the characteristic exponents.    By default, <code>v</code> is initialized as <code>v = 0</code> (i.e., a zero array of appropriate dimensions).  The keyword argument <code>vinit = v0</code> can be used to initialize <code>v</code> with an arbitrary <code>m×p×ns</code> array <code>v0</code>.  </p><p>The optimization process is controlled using several keyword parameters.  The keyword parameter <code>maxit</code> can be used to specify the maximum number of iterations to be performed (default: <code>maxit = 1000</code>). The keyword argument <code>vtol</code> can be used to specify the absolute tolerance in  the changes of the optimization variable <code>v</code> (default: <code>vtol = 0</code>). The keyword argument <code>Jtol</code> can be used to specify the relative tolerance in the changes of the optimization criterion <code>J</code> (default: <code>Jtol = 0</code>),  while <code>gtol</code> is the method specific main convergence tolerance (default: <code>gtol = 1e-3</code>).  With the keyword argument <code>show_trace = true</code>,  a trace of the optimization algorithm&#39;s state is shown on <code>stdout</code> (default <code>show_trace = false</code>).    (see the documentation of the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> package for additional information). </p><p>The returned named tuple <code>info</code> contains <code>(fopt, sdeg0, sdeg, vopt, optres)</code>, where:</p><p><code>info.fopt</code> is the resulting value of the optimal performance <code>J</code>;</p><p><code>info.sdeg0</code> is the initial stability degree of the closed-loop characteristic exponents;</p><p><code>info.sdeg</code> is the resulting stability degree of the closed-loop characteristic exponents;</p><p><code>info.vopt</code> is the resulting value of the optimization variable <code>v</code>; </p><p><code>info.optres</code> is the result returned by the <code>Optim.optimize(...)</code> function of the  <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a> package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L1889-L1949">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pcpofstab_hr" href="#PeriodicSystems.pcpofstab_hr"><code>PeriodicSystems.pcpofstab_hr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pcpofstab_hr(psys,  nh = 0; K = 100, vinit, optimizer = &quot;local&quot;, maxiter, vtol, Jtol, gtol, show_trace) -&gt; (Fstab,info)</code></pre><p>For a continuoous-time periodic system <code>psys = (A(t), B(t), C(t), D(t))</code> of period <code>T</code> determine a periodic output feedback gain matrix  <code>Fstab(t)</code> of the same period,   such that the characteristic exponents <code>Λ</code> of the closed-loop state-matrix <code>A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t)</code> are stable.  The matrices of the system <code>psys</code> are of type <code>HarmonicArray</code>. </p><p>The resulting output feedback gain <code>Fstab(t)</code> is computed as <code>Fstab(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code> in the harmonic representation form </p><pre><code class="nohighlight hljs">              nh
 F(t) = F0 +  ∑ ( Fc_i*cos(i*t*2*π/T)+Fs_i*sin(i*2*π*t/T) ) ,
             i=1</code></pre><p>where <code>F0</code> is the constant term, <code>Fc_i</code> is the <code>i</code>-th cosinus coefficient matrix and <code>Fs_i</code> is the <code>i</code>-th sinus coefficient matrix.  By default, the number of harmonics is <code>nh = 0</code> (i.e., constant output feedback is used). The resulting periodic matrix <code>Fstab(t)</code> is of type <code>HarmonicArray</code>. The corresponding closed-loop periodic system can be obtained using the function <a href="psconnect.html#PeriodicSystems.psfeedback"><code>psfeedback</code></a>.</p><p>For the determination of the optimal feedback gains <code>F0</code>, <code>Fc_i</code> and <code>Fs_i</code> for <code>i = 1, ...., nh</code>  an optimization-based approach is employed using using  tools available in the optimization package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>.  By default, the gradient-free <em>Nelder-Mead</em> local search method for unconstrained minimizations  is employed using the keyword argument setting <code>optimizer = Optim.NelderMead()</code>.    The alternative gradient-free <em>Simulated Annealing</em> global search method can be selected with  <code>optimizer = Optim.SimulatedAnnealing()</code>. </p><p>For a system with <code>m</code> inputs and <code>p</code> outputs,  an internal optimization variable <code>v</code> is used, formed as an <code>m*p*(2*nh+1)</code> dimensional vector  <code>v := [vec(F0); vec(Fc_1); vec(Fs_1), ... ; vec(Fc_nh); vec(Fs_nh)]</code>.  The performance index to be minimized is <code>J := sdeg(v)</code>,  where <code>sdeg(v)</code> is the stability degree defined as the largest real part of the characteristic exponents  of <code>Af(t) := A(t)+B(t)*F(t)*C(t)</code>. The keyword argument <code>K</code> is the number of factors used to express the monodromy matrix of <code>Af(t)</code> (default: <code>K = 100</code>),  when evaluating the characteristic exponents.    By default, <code>v</code> is initialized as <code>v = 0</code> (i.e., a zero array of appropriate dimensions).  The keyword argument <code>vinit = v0</code> can be used to initialize <code>v</code> with an arbitrary <code>m*p*(2*nh+1)</code> array <code>v0</code>.  </p><p>The optimization process is controlled using several keyword parameters.  The keyword parameter <code>maxiter = maxit</code> can be used to specify the maximum number of iterations to be performed (default: <code>maxit = 1000</code>). The keyword argument <code>vtol</code> can be used to specify the absolute tolerance in  the changes of the optimization variable <code>v</code> (default: <code>vtol = 0</code>). The keyword argument <code>Jtol</code> can be used to specify the relative tolerance in the changes of the optimization criterion <code>J</code> (default: <code>Jtol = 0</code>),  while <code>gtol</code> is the method specific main convergence tolerance (default: <code>gtol = 1e-3</code>).  With the keyword argument <code>show_trace = true</code>,  a trace of the optimization algorithm&#39;s state is shown on <code>stdout</code> (default <code>show_trace = false</code>).    (see the documentation of the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> package for additional information). </p><p>The returned named tuple <code>info</code> contains <code>(fopt, sdeg0, sdeg, vopt, optres)</code>, where:</p><p><code>info.fopt</code> is the resulting value of the optimal performance <code>J</code>;</p><p><code>info.sdeg0</code> is the initial stability degree of the closed-loop characteristic exponents;</p><p><code>info.sdeg</code> is the resulting stability degree of the closed-loop characteristic exponents;</p><p><code>info.vopt</code> is the resulting value of the optimization variable <code>v</code>; </p><p><code>info.optres</code> is the result returned by the <code>Optim.optimize(...)</code> function of the  <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a> package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L2003-L2064">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdpofstab_sw" href="#PeriodicSystems.pdpofstab_sw"><code>PeriodicSystems.pdpofstab_sw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pdpofstab_sw(psys, ns = missing; vinit, optimizer, maxit, vtol, Jtol, gtol, show_trace) -&gt; (Fstab,info)</code></pre><p>For a discrete-time periodic system <code>psys = (A(t), B(t), C(t), D(t))</code> determine a periodic output feedback gain matrix  <code>Fstab(t)</code> of the same period,   such that the characteristic exponents <code>Λ</code> of the closed-loop state-matrix <code>A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t)</code> are stable.  The matrices of the system <code>psys</code> are of type <code>PeriodicArray</code>.  The switching times for the resulting switching periodic gain <code>Fstab(t)</code> are specified by the  <code>N</code>-dimensional integer vector <code>ns</code>.  By default, <code>ns = [N]</code>, where <code>N</code> is the maximal number of samples (i.e., <code>N = psys.period/psys.Ts</code>), which corresponds to a constant gain.  </p><p>The output feedback gain <code>Fstab(t)</code> is computed as <code>Fstab(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code>  defined as </p><pre><code class="nohighlight hljs">F(t) = F_i for t ∈ [ns[i]Δ,ns[i+1]Δ) and i ∈ {1, ..., N-1}, or
F(t) = F_N for t ∈ [ns[N]Δ,T),</code></pre><p>where <code>T</code> is the system period (i.e., <code>T = psys.period</code>), <code>Δ</code> is the system sampling time (i.e., <code>Δ = psys.Ts</code>),   and <code>F_i</code> is the <code>i</code>-th gain.  The resulting periodic matrix <code>Fstab(t)</code> is of type <code>SwitchingPeriodicArray</code>. The corresponding closed-loop periodic system can be obtained using the function <a href="psconnect.html#PeriodicSystems.psfeedback"><code>psfeedback</code></a>.</p><p>For the determination of the optimal feedback gains <code>F_i</code> for <code>i = 1, ...., N</code>  an optimization-based approach is employed using using  tools available in the optimization package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>.  By default, the gradient-free <em>Nelder-Mead</em> local search method for unconstrained minimizations  is employed using the keyword argument setting <code>optimizer = Optim.NelderMead()</code>.    The alternative gradient-free <em>Simulated Annealing</em> global search method can be selected with <code>optimizer = Optim.SimulatedAnnealing()</code>. </p><p>For a system with <code>m</code> inputs and <code>p</code> outputs,  an internal optimization variable <code>v</code> is used, defined as an <code>m×p×N</code> array.  By default, <code>v</code> is initialized as <code>v = 0</code> (i.e., a zero array of appropriate dimensions).  The keyword argument <code>vinit = v0</code> can be used to initialize <code>v</code> with an arbitrary <code>m×p×N</code> array <code>v0</code>.  </p><p>The performance index to be minimized is <code>J := sdeg(v)</code>,  where <code>sdeg(v)</code> is the stability degree defined as the largest modulus of the characteristic exponents  of <code>Af(t) := A(t)+B(t)*F(t)*C(t)</code>. The optimization process is controlled using several keyword parameters.  The keyword parameter <code>maxit</code> can be used to specify the maximum number of iterations to be performed (default: <code>maxit = 1000</code>). The keyword argument <code>vtol</code> can be used to specify the absolute tolerance in  the changes of the optimization variable <code>v</code> (default: <code>vtol = 0</code>). The keyword argument <code>Jtol</code> can be used to specify the relative tolerance in the changes of the optimization criterion <code>J</code> (default: <code>Jtol = 0</code>),  while <code>gtol</code> is the method specific main convergence tolerance (default: <code>gtol = 1e-3</code>).  With the keyword argument <code>show_trace = true</code>,  a trace of the optimization algorithm&#39;s state is shown on <code>stdout</code> (default <code>show_trace = false</code>).    (see the documentation of the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> package for additional information). </p><p>The returned named tuple <code>info</code> contains <code>(fopt, sdeg0, sdeg, vopt, optres)</code>, where:</p><p><code>info.fopt</code> is the resulting value of the optimal performance <code>J</code>;</p><p><code>info.sdeg0</code> is the initial stability degree of the closed-loop characteristic exponents;</p><p><code>info.sdeg</code> is the resulting stability degree of the closed-loop characteristic exponents;</p><p><code>info.vopt</code> is the resulting value of the optimization variable <code>v</code>; </p><p><code>info.optres</code> is the result returned by the <code>Optim.optimize(...)</code> function of the  <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a> package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L2113-L2174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdpofstab_hr" href="#PeriodicSystems.pdpofstab_hr"><code>PeriodicSystems.pdpofstab_hr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pdpofstab_hr(psys, nh = 0; vinit, optimizer, maxit, vtol, Jtol, gtol, show_trace) -&gt; (Fstab,info)</code></pre><p>For a discrete-time periodic system <code>psys = (A(t), B(t), C(t), D(t))</code> of period <code>T</code> determine a periodic output feedback gain matrix  <code>Fstab(t)</code> of the same period,   such that the characteristic exponents <code>Λ</code> of the closed-loop state-matrix <code>A(t)+B(t)*Fstab(t)*inv(I-D(t)*Fstab(t))*C(t)</code> are stable.  The matrices of the system <code>psys</code> are of type <code>HarmonicArray</code>. </p><p>The resulting output feedback gain <code>Fstab(t)</code> is of type <code>PeriodicMatrix</code> and is computed as <code>Fstab(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code>, of type <code>PeriodicMatrix</code>, built by sampling, with the sample time <code>Δ = abs(psys.Ts)</code>, the harmonic representation form </p><pre><code class="nohighlight hljs">              nh
Fh(t) = F0 +  ∑ ( Fc_i*cos(i*t*2*π/T)+Fs_i*sin(i*2*π*t/T) ) ,
             i=1</code></pre><p>where <code>F0</code> is the constant term, <code>Fc_i</code> is the <code>i</code>-th cosinus coefficient matrix and <code>Fs_i</code> is the <code>i</code>-th sinus coefficient matrix.  <code>F(t)</code> is defined as  <code>F(t) = Fh((Δ(i-1))</code>)&#39; for t ∈ [Δ(i-1), Δi), i = 1, ..., T/Δ.  By default, the number of harmonics is <code>nh = 0</code> (i.e., constant output feedback is used).  The corresponding closed-loop periodic system can be obtained using the function <a href="psconnect.html#PeriodicSystems.psfeedback"><code>psfeedback</code></a>.</p><p>For the determination of the optimal feedback gains <code>F0</code>, <code>Fc_i</code> and <code>Fs_i</code> for <code>i = 1, ...., nh</code>  an optimization-based approach is employed using using  tools available in the optimization package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>.  By default, the gradient-free <em>Nelder-Mead</em> local search method for unconstrained minimizations  is employed using the keyword argument setting <code>optimizer = Optim.NelderMead()</code>.    The alternative gradient-free <em>Simulated Annealing</em> global search method can be selected with  <code>optimizer = Optim.SimulatedAnnealing()</code>. </p><p>For a system with <code>m</code> inputs and <code>p</code> outputs,  an internal optimization variable <code>v</code> is used, formed as an <code>m*p*(2*nh+1)</code> dimensional vector  <code>v := [vec(F0); vec(Fc_1); vec(Fs_1), ... ; vec(Fc_nh); vec(Fs_nh)]&#39;.  The performance index to be minimized is</code>J := sdeg(v)<code>,  where</code>sdeg(v)<code>is the stability degree defined as the largest modulus of the  characteristic exponents  of</code>Af(t) := A(t)+B(t)<em>F(t)</em>C(t)<code>.  By default,</code>v<code>is initialized as</code>v = 0<code>(i.e., a zero array of appropriate dimensions).  The keyword argument</code>vinit = v0<code>can be used to initialize</code>v<code>with an arbitrary</code>m<em>p</em>(2*nh+1)<code>array</code>v0`.  </p><p>The optimization process is controlled using several keyword parameters.  The keyword parameter <code>maxiter = maxit</code> can be used to specify the maximum number of iterations to be performed (default: <code>maxit = 1000</code>). The keyword argument <code>vtol</code> can be used to specify the absolute tolerance in  the changes of the optimization variable <code>v</code> (default: <code>vtol = 0</code>). The keyword argument <code>Jtol</code> can be used to specify the relative tolerance in the changes of the optimization criterion <code>J</code> (default: <code>Jtol = 0</code>),  while <code>gtol</code> is the method specific main convergence tolerance (default: <code>gtol = 1e-3</code>).  With the keyword argument <code>show_trace = true</code>,  a trace of the optimization algorithm&#39;s state is shown on <code>stdout</code> (default <code>show_trace = false</code>).    (see the documentation of the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> package for additional information). </p><p>The returned named tuple <code>info</code> contains <code>(fopt, sdeg0, sdeg, vopt, optres)</code>, where:</p><p><code>info.fopt</code> is the resulting value of the optimal performance <code>J</code>;</p><p><code>info.sdeg0</code> is the initial stability degree of the closed-loop characteristic exponents;</p><p><code>info.sdeg</code> is the resulting stability degree of the closed-loop characteristic exponents;</p><p><code>info.vopt</code> is the resulting value of the optimization variable <code>v</code>; </p><p><code>info.optres</code> is the result returned by the <code>Optim.optimize(...)</code> function of the  <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a> package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L2219-L2282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pclqofc_sw" href="#PeriodicSystems.pclqofc_sw"><code>PeriodicSystems.pclqofc_sw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pclqofc_sw(psys, Q, R, ts = missing; K = 1, sdeg = 0, G = I, vinit, optimizer, stabilizer,
           maxiter, vtol, Jtol, gtol, show_trace, solver, reltol, abstol, dt,
           N = 128, intpolmeth = &quot;cubic&quot;, quad = false ) -&gt; (Fopt,info)</code></pre><p>Compute the optimal periodic stabilizing gain matrix <code>Fopt(t)</code>, such that for a continuous-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">  .
  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)  
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,</code></pre><p>the output feedback control law</p><pre><code class="nohighlight hljs">u(t) = Fopt(t)*y(t),</code></pre><p>minimizes the expectation of the quadratic index</p><pre><code class="nohighlight hljs">         ∞
 J = E{ Int [x(t)&#39;*Q(t)*x(t) + u(t)&#39;*R(t)*u(t)]dt },
        t=0</code></pre><p>where <code>Q(t)</code> and <code>R(t)</code> are periodic weighting matrices.  The matrices of the system <code>psys</code> are of type <code>PeriodicFunctionMatrix</code>.  For a system of order <code>n</code> with <code>m</code> control inputs in <code>u(t)</code> and <code>p</code> measurable outputs in <code>y(t)</code>,  <code>Q(t)</code> and <code>R(t)</code> are <code>n×n</code> and <code>m×m</code> symmetric periodic matrices of type <code>PeriodicFunctionMatrix</code>, respectively.                 The dimension <code>m</code> of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>Q</code> and <code>R</code> can be alternatively provided as constant real matrices. </p><p>The resulting <code>m×p</code> periodic output feedback gain <code>Fopt(t)</code> is of type <code>PeriodicSwitchingMatrix</code>,  with the switching times defined by the vector <code>ts</code>.  The <code>ns</code> switching times contained in the vector <code>ts</code> must satisfy <code>0 = ts[1] &lt; ts[2] &lt; ... &lt; ts[ns] &lt; T</code>, where <code>T</code> is the system period.  If <code>ts = missing</code>, then <code>ts = [0]</code> is used by default (i.e., constant output feedback).</p><p>The output feedback gain <code>Fopt(t)</code> is computed as <code>Fopt(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code>  defined as </p><pre><code class="nohighlight hljs"> F(t) = F_i  for t ∈ [ts[i],ts[i+1]) and i ∈ {1, ..., ns-1} or 
 F(t) = F_ns for t ∈ [ts[ns],T)</code></pre><p>where <code>F_i</code> is the <code>i</code>-th gain. </p><p>The covariance matrix of the initial state <code>x(0)</code> can be specified via the keyword argument <code>G</code> (default: <code>G = I</code>) and a desired stability degree of the closed-loop characteristic exponents can be specified using the keyword argument <code>sdeg</code> (default: <code>sdeg = 0</code>). </p><p>For the determination of the optimal feedback gains <code>F_i</code> for <code>i = 1, ...., ns</code> an optimization-based approach is employed using  tools available in the optimization package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>.  By default, the gradient-based limited-memory quasi-Newton method (also known as <code>L-BFGS</code>) for unconstrained minimizations  is employed using the keyword argument setting <code>optimizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))</code>, where  an initial step length for the line search algorithm is chosen using the keyword argument <code>alphaguess</code>  (see the <a href="https://github.com/JuliaNLSolvers/LineSearches.jl"><code>LineSearches.jl</code></a> package for alternative options).  The employed default line search algorithm is <code>HagerZhang()</code> and an alternative method can be specified using the keyword argument <code>linesearch</code>  (e.g., <code>linesearch = LineSearches.MoreThuente()</code>).   Alternative gradient-based methods can be also selected, such as, for example,  the quasi-Newton method <code>BFGS</code> with <code>optimizer = Optim.BFGS()</code>, or  for small size optimization problems, the Nelder-Mead gradient-free method with <code>optimizer = Optim.NelderMead()</code>.  For the computation of the function <code>J</code> and its gradient  <code>∇J</code>, the formulas developed in [1] for stable systems are used. Each evaluation involves the solution of  of a pair of periodic Lyapunov differential equations using single or multiple shooting methods proposed in [2].   If the original system <code>psys</code> is unstable, the computation of a stabilizing feedback is performed using the same optimization techniques applied iteratively to systems  with modified the state matrices of the form  <code>A(t)-αI</code>, where <code>α ≥ 0</code> is chosen such that <code>A(t)-αI</code> is stable, and the values of <code>α</code> are successively decreased until the stabilization is achieved. The optimization method for stabilization can be independently selected using the keyword argument <code>stabilizer</code>, with the default setting   <code>stabilizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))</code>. If only stabilization is desired, then use  <code>optimizer = nothing</code>. </p><p>An internal optimization variable <code>v</code> is used, formed as an <code>m×p×ns</code> array with <code>v[:,:,i] := F_i</code>, for <code>i = 1, ..., ns</code>.  By default, <code>v</code> is initialized as <code>v = 0</code> (i.e., a zero array of appropriate dimensions).  The keyword argument <code>vinit = v0</code> can be used to initialize <code>v</code> with an arbitrary <code>m×p×ns</code> array <code>v0</code>.   </p><p>The optimization process is controlled using several keyword parameters.  The keyword parameter <code>maxiter = maxit</code> can be used to specify the maximum number of iterations to be performed (default: <code>maxit = 1000</code>). The keyword argument <code>vtol</code> can be used to specify the absolute tolerance in  the changes of the optimization variable <code>v</code> (default: <code>vtol = 0</code>). The keyword argument <code>Jtol</code> can be used to specify the relative tolerance in the changes of the optimization criterion <code>J</code> (default: <code>Jtol = 0</code>),  while <code>gtol</code> can be used to specify the absolute tolerance in the gradient  <code>∇J</code>, in infinity norm (default: <code>gtol = 1e-5</code>).  With the keyword argument <code>show_trace = true</code>,  a trace of the optimization algorithm&#39;s state is shown on <code>stdout</code> (default <code>show_trace = false</code>).    For stabilization purposes,  the values <code>Jtol = 1.e-3</code>, <code>gtol = 1.e-2</code>, <code>maxit = 20</code> are used to favor faster convergence. </p><p>The returned named tuple <code>info</code> contains <code>(fopt, sdeg0, sdeg, vopt, optres)</code>, where:</p><p><code>info.fopt</code> is the resulting value of the optimal performance <code>J</code>;</p><p><code>info.sdeg0</code> is the initial stability degree of the closed-loop characteristic exponents;</p><p><code>info.sdeg</code> is the resulting stability degree of the closed-loop characteristic exponents;</p><p><code>info.vopt</code> is the resulting value of the optimization variable <code>v</code>; </p><p><code>info.optres</code> is the result returned by the <code>Optim.optimize(...)</code> function of the  <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a> package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). </p><p>Several keyword arguments can be used to control the integration of the involved ODE&#39;s for the solution of  periodic differential Lyapunov equations for function and gradient evaluations. </p><p>If <code>K = 1</code> (default), the single shooting method is employed to compute periodic generators [1].  If <code>K &gt; 1</code>, the multiple-shooting method of [2] is employed, first, to convert the continuous-time periodic Lyapunov differential equations into discrete-time periodic Lyapunov equations satisfied by  the generator solution in <code>K</code> grid points and then to compute the solution by solving an appropriate discrete-time periodic Lyapunov  equation using the periodic Schur method of [3]. If quad = true, a quadrature-based evaluation of gradients is used, as proposed in [1], in conjunction with interpolation techniques. The interpolation method to be used can be specified using the keyword parameter <code>intpolmeth</code> (default: <code>intpolmeth = &quot;cubic&quot;</code>).  Other interpolation options are <code>&quot;intpolmeth = quadratic&quot;</code>, <code>intpolmeth = &quot;linear&quot;</code> and <code>intpolmeth = &quot;constant&quot;</code>. The number of sample values to be used for interpolation can be specified with the keyword parameter <code>N</code> (deafult: <code>N = 128</code>). </p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>,  together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),   absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and stepsize <code>dt</code> (default: <code>dt = 0</code>, only used if <code>solver = &quot;symplectic&quot;</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>Parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable. </p><p>[1] L. Vigano, M. Bergamasco, M. Lovera, and A. Varga. Optimal periodic output feedback control: a continuous-time approach and a case study.     Int. J. Control, Vol. 83, pp. 897–914, 2010.  </p><p>[2] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. </p><p>[3] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L1085-L1219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pclqofc_hr" href="#PeriodicSystems.pclqofc_hr"><code>PeriodicSystems.pclqofc_hr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pclqofc_hr(psys, Q, R, nh = 0; K = 1, sdeg = 0, G = I, vinit, optimizer, stabilizer,
           maxiter, vtol, Jtol, gtol, show_trace, solver, reltol, abstol, dt,
           N = 128, intpolmeth = &quot;cubic&quot;, quad = false ) -&gt; (Fopt,info)</code></pre><p>Compute the optimal periodic stabilizing gain matrix <code>Fopt(t)</code>, such that for a continuous-time periodic state-space model  <code>psys</code> of the form</p><pre><code class="nohighlight hljs">  .
  x(t) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)  
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,</code></pre><p>the output feedback control law</p><pre><code class="nohighlight hljs">u(t) = Fopt(t)*y(t),</code></pre><p>minimizes the expectation of the quadratic index</p><pre><code class="nohighlight hljs">         ∞
 J = E{ Int [x(t)&#39;*Q(t)*x(t) + u(t)&#39;*R(t)*u(t)]dt },
        t=0</code></pre><p>where <code>Q(t)</code> and <code>R(t)</code> are periodic weighting matrices.  The matrices of the system <code>psys</code> are of type <code>HarmonicArray</code>.  For a system of order <code>n</code> with <code>m</code> control inputs in <code>u(t)</code> and <code>p</code> measurable outputs in <code>y(t)</code>,  <code>Q(t)</code> and <code>R(t)</code> are <code>n×n</code> and <code>m×m</code> symmetric periodic matrices of type <code>HarmonicArray</code>, respectively.                 The dimension <code>m</code> of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>Q</code> and <code>R</code> can be alternatively provided as constant real matrices. </p><p>The resulting <code>m×p</code> periodic output feedback gain <code>Fopt(t)</code> is of type <code>HarmonicArray</code> and is computed as <code>Fopt(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code> in the harmonic representation form </p><pre><code class="nohighlight hljs">              nh
 F(t) = F0 +  ∑ ( Fc_i*cos(i*t*2*π/T)+Fs_i*sin(i*2*π*t/T) ) ,
             i=1</code></pre><p>where <code>T</code> is the system period, <code>F0</code> is the constant term, <code>Fc_i</code> is the <code>i</code>-th cosinus coefficient matrix and <code>Fs_i</code> is the <code>i</code>-th sinus coefficient matrix.  By default, the number of harmonics is <code>nh = 0</code> (i.e., constant output feedback is used).</p><p>The covariance matrix of the initial state <code>x(0)</code> can be specified via the keyword argument <code>G</code> (default: <code>G = I</code>) and a desired stability degree of the closed-loop characteristic exponents can be specified using the keyword argument <code>sdeg</code> (default: <code>sdeg = 0</code>). </p><p>For the determination of the optimal feedback gains <code>F0</code>, <code>Fc_i</code> and <code>Fs_i</code> for <code>i = 1, ...., nh</code> an optimization-based approach is employed using  tools available in the optimization package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>.  By default, the gradient-based limited-memory quasi-Newton method (also known as <code>L-BFGS</code>) for unconstrained minimizations  is employed using the keyword argument setting <code>optimizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))</code>, where  an initial step length for the line search algorithm is chosen using the keyword argument <code>alphaguess</code>  (see the <a href="https://github.com/JuliaNLSolvers/LineSearches.jl"><code>LineSearches.jl</code></a> package for alternative options).  The employed default line search algorithm is <code>HagerZhang()</code> and an alternative method can be specified using the keyword argument <code>linesearch</code>  (e.g., <code>linesearch = LineSearches.MoreThuente()</code>).   Alternative gradient-based methods can be also selected, such as, for example,  the quasi-Newton method <code>BFGS</code> with <code>optimizer = Optim.BFGS()</code>, or  for small size optimization problems, the Nelder-Mead gradient-free method with <code>optimizer = Optim.NelderMead()</code>.  For the computation of the function <code>J</code> and its gradient  <code>∇J</code>, the formulas developed in [1] for stable systems are used. Each evaluation involves the solution of  of a pair of periodic Lyapunov differential equations using single or multiple shooting methods proposed in [2].   If the original system <code>psys</code> is unstable, the computation of a stabilizing feedback is performed using the same optimization techniques applied iteratively to systems  with modified the state matrices of the form  <code>A(t)-αI</code>, where <code>α ≥ 0</code> is chosen such that <code>A(t)-αI</code> is stable, and the values of <code>α</code> are successively decreased until the stabilization is achieved. The optimization method for stabilization can be independently selected using the keyword argument <code>stabilizer</code>, with the default setting   <code>stabilizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))</code>. If only stabilization is desired, then use  <code>optimizer = nothing</code>. </p><p>An internal optimization variable <code>v</code> is used, formed as an <code>m*p*(2*nh+1)</code> dimensional vector <code>v := [vec(F0); vec(Fc_1); vec(Fs_1), ... ; vec(Kc_nh); vec(Ks_nh)]&#39;.  By default,</code>v<code>is initialized as</code>v = 0<code>(i.e., a zero vector of appropriate dimension).  The keyword argument</code>vinit = v0<code>can be used to initialize</code>v<code>with an arbitrary vector</code>v0`.   </p><p>The optimization process is controlled using several keyword parameters.  The keyword parameter <code>maxiter = maxit</code> can be used to specify the maximum number of iterations to be performed (default: <code>maxit = 1000</code>). The keyword argument <code>vtol</code> can be used to specify the absolute tolerance in  the changes of the optimization variable <code>v</code> (default: <code>vtol = 0</code>). The keyword argument <code>Jtol</code> can be used to specify the relative tolerance in the changes of the optimization criterion <code>J</code> (default: <code>Jtol = 0</code>),  while <code>gtol</code> can be used to specify the absolute tolerance in the gradient  <code>∇J</code>, in infinity norm (default: <code>gtol = 1e-5</code>).  With the keyword argument <code>show_trace = true</code>,  a trace of the optimization algorithm&#39;s state is shown on <code>stdout</code> (default <code>show_trace = false</code>).    For stabilization purposes,  the values <code>Jtol = 1.e-3</code>, <code>gtol = 1.e-2</code>, <code>maxit = 20</code> are used to favor faster convergence. </p><p>The returned named tuple <code>info</code> contains <code>(fopt, sdeg0, sdeg, vopt, optres)</code>, where:</p><p><code>info.fopt</code> is the resulting value of the optimal performance <code>J</code>;</p><p><code>info.sdeg0</code> is the initial stability degree of the closed-loop characteristic exponents;</p><p><code>info.sdeg</code> is the resulting stability degree of the closed-loop characteristic exponents;</p><p><code>info.vopt</code> is the resulting value of the optimization variable <code>v</code>; </p><p><code>info.optres</code> is the result returned by the <code>Optim.optimize(...)</code> function of the  <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a> package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). </p><p>Several keyword arguments can be used to control the integration of the involved ODE&#39;s for the solution of  periodic differential Lyapunov equations for function and gradient evaluations. </p><p>If <code>K = 1</code> (default), the single shooting method is employed to compute periodic generators [1].  If <code>K &gt; 1</code>, the multiple-shooting method of [2] is employed, first, to convert the continuous-time periodic Lyapunov differential equations into discrete-time periodic Lyapunov equations satisfied by  the generator solution in <code>K</code> grid points and then to compute the solution by solving an appropriate discrete-time periodic Lyapunov  equation using the periodic Schur method of [3]. If quad = true, a quadrature-based evaluation of gradients is used, as proposed in [1], in conjunction with interpolation techniques. The interpolation method to be used can be specified using the keyword parameter <code>intpolmeth</code> (default: <code>intpolmeth = &quot;cubic&quot;</code>).  Other interpolation options are <code>&quot;intpolmeth = quadratic&quot;</code>, <code>intpolmeth = &quot;linear&quot;</code> and <code>intpolmeth = &quot;constant&quot;</code>. The number of sample values to be used for interpolation can be specified with the keyword parameter <code>N</code> (deafult: <code>N = 128</code>). </p><p>The ODE solver to be employed to convert the continuous-time problem into a discrete-time problem can be specified using the keyword argument <code>solver</code>,  together with the required relative accuracy <code>reltol</code> (default: <code>reltol = 1.e-4</code>),   absolute accuracy <code>abstol</code> (default: <code>abstol = 1.e-7</code>) and stepsize <code>dt</code> (default: <code>dt = 0</code>, only used if <code>solver = &quot;symplectic&quot;</code>).  Depending on the desired relative accuracy <code>reltol</code>, lower order solvers are employed for <code>reltol &gt;= 1.e-4</code>,  which are generally very efficient, but less accurate. If <code>reltol &lt; 1.e-4</code>, higher order solvers are employed able to cope with high accuracy demands. </p><p>The following solvers from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> package can be selected:</p><p><code>solver = &quot;non-stiff&quot;</code> - use a solver for non-stiff problems (<code>Tsit5()</code> or <code>Vern9()</code>);</p><p><code>solver = &quot;stiff&quot;</code> - use a solver for stiff problems (<code>Rodas4()</code> or <code>KenCarp58()</code>);</p><p><code>solver = &quot;symplectic&quot;</code> - use a symplectic Hamiltonian structure preserving solver (<code>IRKGL16()</code>);</p><p><code>solver = &quot;&quot;</code> - use the default solver, which automatically detects stiff problems (<code>AutoTsit5(Rosenbrock23())</code> or <code>AutoVern9(Rodas5())</code>). </p><p>Parallel computation of the matrices of the discrete-time problem can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the <code>-t/--threads</code> command line argument  or by using the <code>JULIA_NUM_THREADS</code> environment variable. </p><p>[1] L. Vigano, M. Bergamasco, M. Lovera, and A. Varga. Optimal periodic output feedback control: a continuous-time approach and a case study.     Int. J. Control, Vol. 83, pp. 897–914, 2010.  </p><p>[2] A. Varga. On solving periodic differential matrix equations with applications to periodic system norms computation.      Proc. IEEE CDC/ECC, Seville, 2005. </p><p>[3] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.      Int. J. Control, vol, 67, pp, 69-87, 1997.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L1540-L1670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdlqofc" href="#PeriodicSystems.pdlqofc"><code>PeriodicSystems.pdlqofc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pdlqofc(psys, Q, R; S, G = I, sdeg = 1, stabilizer, optimizer, vinit, maxiter, vtol, Jtol, gtol, show_trace) -&gt; (Fopt, info)</code></pre><p>Compute for the discrete-time periodic state-space system <code>psys = (A(t),B(t),C(t),D(t))</code> of the form</p><pre><code class="nohighlight hljs">x(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t) 
  y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,</code></pre><p>the optimal periodic feedback gain <code>Fopt(t)</code> in the output feedback control law  </p><pre><code class="nohighlight hljs">u(t) = Fopt(t)*y(t),</code></pre><p>which minimizes the expectation of the quadratic index</p><pre><code class="nohighlight hljs"> J = E{ Sum [x(t)&#39;*Q(t)*x(t) + 2*x(t)&#39;*S(t)*u(t) + u(t)&#39;*R(t)*u(t)] },</code></pre><p>where <code>Q(t)</code>, <code>R(t)</code> and <code>S(t)</code> are periodic weighting matrices.  For a system of order <code>n</code> with <code>m</code> control inputs in <code>u(t)</code> and <code>p</code> measurable outputs in <code>y(t)</code>,  <code>Q(t)</code> and <code>R(t)</code> are <code>n×n</code> and <code>m×m</code> symmetric periodic matrices, respectively, and  <code>S(t)</code> is an <code>n×m</code> periodic matrix, which can be specified via the keyword argument <code>S</code>.  By default <code>S = missing</code>, in which case, <code>S(t) = 0</code> is assumed.    The periodic matrices <code>Q(t)</code>,<code>R(t)</code> and <code>S(t)</code> have the same type as the matrices of the state-space system, i.e., either of type <code>PeriodicMatrix</code> or <code>PeriodicArray</code>.   The dimension <code>m</code> of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>Q</code>, <code>R</code> and <code>S</code> can be alternatively provided as constant real matrices. </p><p>The resulting <code>m×p</code> periodic output feedback gain <code>Fopt(t)</code> has the same type as the state-space system matrices and is computed as <code>Fopt(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code>  defined as </p><pre><code class="nohighlight hljs"> F(t) = F_i  for i ∈ {1, ..., ns}</code></pre><p>where <code>ns</code> is the number of sampling times in a period (i.e., <code>ns = psys.period/psys.Ts</code>) and <code>F_i</code> is the <code>i</code>-th gain. </p><p>The covariance of the initial state <code>x(0)</code> can be specified via the keyword argument <code>G</code> (default: <code>G = I</code>) and a desired stability degree of the closed-loop characteristic multipliers can be specified using the keyword argument <code>sdeg</code> (default: <code>sdeg = 1</code>). </p><p>For the determination of the optimal feedback gains <code>F_i</code> for <code>i = 1, ...., ns</code> an optimization-based approach is employed using  tools available in the optimization package <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a>.  By default, the gradient-based limited-memory quasi-Newton method (also known as <code>L-BFGS</code>) for unconstrained minimizations  is employed using the keyword argument setting <code>optimizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))</code>, where  an initial step length for the line search algorithm is chosen using the keyword argument <code>alphaguess</code>  (see the <a href="https://github.com/JuliaNLSolvers/LineSearches.jl"><code>LineSearches.jl</code></a> package for alternative options).  The employed default line search algorithm is <code>HagerZhang()</code> and an alternative method can be specified using the keyword argument <code>linesearch</code>  (e.g., <code>linesearch = LineSearches.MoreThuente()</code>).   Alternative gradient-based methods can be also selected, such as, for example,  the quasi-Newton method <code>BFGS</code> with <code>optimizer = Optim.BFGS()</code>, or  for small size optimization problems, the Nelder-Mead gradient-free method with <code>optimizer = Optim.NelderMead()</code>.  For the computation of the function <code>J</code> and its gradient  <code>∇J</code>, the formulas developed in [1] for stable systems are used. Each evaluation involves the solution of  of a pair of periodic Lyapunov difference equations using the method proposed in [2].   If the original system <code>psys</code> is unstable, the computation of a stabilizing feedback is performed using the same optimization techniques applied iteratively to systems  with modified state matrices of the form  <code>A(t)/α</code> and control matrices <code>B(t)/α</code>, where <code>α ≥ 1</code> is chosen such that <code>A(t)/α</code> is stable, and the values of <code>α</code> are successively decreased until the stabilization is achieved with <code>α = 1</code>. The optimization method for stabilization can be independently selected using the keyword argument <code>stabilizer</code>, with the default setting   <code>stabilizer = LBFGS(;alphaguess = LineSearches.InitialStatic(;scaled=true))</code>. If only stabilization is desired, then use  <code>optimizer = nothing</code>. </p><p>An internal optimization variable <code>v</code> is used, formed as an <code>m×p×ns</code> array with <code>v[:,:,i] := F_i</code>, for <code>i = 1, ..., ns</code>.  By default, <code>v</code> is initialized as <code>v = 0</code> (i.e., a zero array of appropriate dimensions).  The keyword argument <code>vinit = v0</code> can be used to initialize <code>v</code> with an arbitrary <code>m×p×ns</code> real array <code>v0</code>.   </p><p>The optimization process is controlled using several keyword parameters.  The keyword parameter <code>maxiter = maxit</code> can be used to specify the maximum number of iterations to be performed (default: <code>maxit = 1000</code>). The keyword argument <code>vtol</code> can be used to specify the absolute tolerance in  the changes of the optimization variable <code>v</code> (default: <code>vtol = 0</code>). The keyword argument <code>Jtol</code> can be used to specify the relative tolerance in the changes of the optimization criterion <code>J</code> (default: <code>Jtol = 0</code>),  while <code>gtol</code> can be used to specify the absolute tolerance in the gradient <code>∇J</code>, in infinity norm (default: <code>gtol = 1e-5</code>).  With the keyword argument <code>show_trace = true</code>,  a trace of the optimization algorithm&#39;s state is shown on <code>stdout</code> (default <code>show_trace = false</code>).    For stabilization purposes, the values <code>Jtol = 1.e-3</code>, <code>gtol = 1.e-2</code>, <code>maxit = 20</code> are used to favor faster convergence. </p><p>The returned named tuple <code>info</code> contains <code>(fopt, sdeg0, sdeg, vopt, optres)</code>, where:</p><p><code>info.fopt</code> is the resulting value of the optimal performance <code>J</code>;</p><p><code>info.sdeg0</code> is the initial stability degree of the closed-loop characteristic multipliers;</p><p><code>info.sdeg</code> is the resulting stability degree of the closed-loop characteristic multipliers;</p><p><code>info.vopt</code> is the resulting value of the optimization variable <code>v</code>; </p><p><code>info.optres</code> is the result returned by the <code>Optim.optimize(...)</code> function of the  <a href="https://github.com/JuliaNLSolvers/Optim.jl"><code>Optim.jl</code></a> package;  several functions provided by this package can be used to inquire various information related to the optimization results (see the documention of this package). </p><p>A bound-constrained optimization can be performed using the keyword argument <code>lub = (lb, ub)</code>, where <code>lb</code> is the lower bound and <code>ub</code> is the upper bound on the feedback gains.  By default,  <code>lub = missing</code> in which case the bounds <code>lb = -Inf</code> and <code>ub = Inf</code> are assumed. </p><p><em>References</em>     </p><p>[1] A. Varga and S. Pieters. Gradient-based approach to solve optimal periodic output feedback problems.      Automatica, vol.34, pp. 477-481, 1998.</p><p>[2] A. Varga. Periodic Lyapunov equations: some applications and new algorithms.                Int. J. Control, vol, 67, pp, 69-87, 1997.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L429-L526">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PeriodicSystems.pdlqofc_sw" href="#PeriodicSystems.pdlqofc_sw"><code>PeriodicSystems.pdlqofc_sw</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pdlqofc_sw(psys, Q, R, ns; S, vinit, kwargs...) -&gt; (Fopt, info)</code></pre><p>Compute for the discrete-time periodic state-space system <code>psys = (A(t),B(t),C(t),D(t))</code> of the form</p><p>x(t+1) = A(t)x(t) + B(t)u(t) + Bw(t)w(t)       y(t) = C(t)x(t) + D(t)u(t) + Dw(t)w(t) ,</p><p>the optimal switching periodic feedback gain <code>Fopt(t)</code> in the output feedback control law  </p><pre><code class="nohighlight hljs">u(t) = Fopt(t)*y(t),</code></pre><p>which minimizes the expectation of the quadratic index </p><pre><code class="nohighlight hljs"> J = E{ Sum [x(t)&#39;*Q(t)*x(t) + 2*x(t)&#39;*S(t)*u(t) + u(t)&#39;*R(t)*u(t)] },</code></pre><p>where <code>Q(t)</code>, <code>R(t)</code> and <code>S(t)</code> are periodic weighting matrices.  For a system of order <code>n</code> with <code>m</code> control inputs in <code>u(t)</code> and <code>p</code> measurable outputs in <code>y(t)</code>,  <code>Q(t)</code> and <code>R(t)</code> are <code>n×n</code> and <code>m×m</code> symmetric periodic matrices, respectively, and  <code>S(t)</code> is an <code>n×m</code> periodic matrix, which can be specified via the keyword argument <code>S</code>.  By default <code>S = missing</code>, in which case, <code>S(t) = 0</code> is assumed.    The periodic matrices <code>Q(t)</code>,<code>R(t)</code> and <code>S(t)</code> have the same type as the matrices of the state-space system, i.e., either of type <code>PeriodicMatrix</code> or <code>PeriodicArray</code>.   The dimension <code>m</code> of <code>u(t)</code> is deduced from the dimension of <code>R(t)</code>.  <code>Q</code>, <code>R</code> and <code>S</code> can be alternatively provided as constant real matrices. </p><p>The switching times for the resulting switching periodic gain <code>Fopt(t)</code> are specified by the  <code>N</code>-dimensional integer vector <code>ns</code>.  By default, <code>ns = 1:N</code>, where <code>N</code> is the maximal number of samples (i.e., <code>N = psys.period/psys.Ts</code>). </p><p>The resulting <code>m×p</code> periodic output feedback gain <code>Fopt(t)</code> has the type <code>SwitchingPeriodicArray</code> and is computed as <code>Fopt(t) = inv(I+F(t)D(t))*F(t)</code>, with <code>F(t)</code>  defined as </p><pre><code class="nohighlight hljs"> F(t) = F_i for t ∈ [ns[i]Δ,ns[i+1]Δ) and i ∈ {1, ..., N-1}, or
 F(t) = F_N for t ∈ [ns[N]Δ,T),</code></pre><p>where <code>T</code> is the system period (i.e., <code>T = psys.period</code>), <code>Δ</code> is the system sampling time (i.e., <code>Δ = psys.Ts</code>)  and <code>F_i</code> is the <code>i</code>-th gain. </p><p>If an initial value for the optimization variable <code>v</code> is provided using the keyword argument <code>vinit = gains</code>, then <code>gains</code> must be an <code>m×p×N</code> array, where <code>m</code> and <code>p</code> are the numbers of system control inputs and outputs. By default, <code>vinit = missing</code>, in which case a zero matrix <code>gains = 0</code> is assumed.  </p><p>The rest of keyword arguments contained in <code>kwargs</code> are the same as those used for the function <a href="psstab.html#PeriodicSystems.pdlqofc"><code>pdlqofc</code></a>.  See its documentation for the description of all keyword arguments. </p><p>The computation of gradient fully exploits the switching structure of the feedback gain, using formulas which generalize the case of constant feedback considered in [1].     </p><p><em>References</em>     </p><p>[1] A. Varga and S. Pieters. Gradient-based approach to solve optimal periodic output feedback problems.      Automatica, vol.34, pp. 477-481, 1998.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/PeriodicSystems.jl/blob/ae785af78c2da790f88bd3b91d2e3e8113a2f991/src/psstab.jl#L784-L838">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="psric.html">« Periodic Riccati equation solvers</a><a class="docs-footer-nextpage" href="pstools.html">Periodic system utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 8 November 2024 14:43">Friday 8 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
